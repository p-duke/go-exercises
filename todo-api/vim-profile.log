SCRIPT  /Users/peter.duke/.vim/plugged/nerdtree/syntax/nerdtree.vim
Sourced 2 times
Total time:   0.000994000
 Self time:   0.000994000

count     total (s)      self (s)
    2              0.000007000 let s:tree_up_dir_line = '.. (up a dir)'
    2              0.000013000 syn match NERDTreeIgnore #\~#
    2              0.000012000 exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
                            
                            "highlighting for the .. (up dir) line at the top of the tree
    2              0.000015000 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line .'#'
                            
                            "quickhelp syntax elements
    2              0.000009000 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
    2              0.000008000 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
    2              0.000006000 syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
    2              0.000008000 syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
    2              0.000007000 syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
    2              0.000007000 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
    2              0.000057000 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for sym links
    2              0.000029000 syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
    2              0.000016000 syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
    2              0.000017000 syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
                            
                            "highlighting to conceal the delimiter around the file/dir name
    2              0.000004000 if has('conceal')
    2              0.000014000     exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# conceal containedin=ALL'
    2              0.000007000     setlocal conceallevel=2 concealcursor=nvic
                            else
                                exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# containedin=ALL'
                                hi! link NERDTreeNodeDelimiters Ignore
    2              0.000001000 endif
                            
                            "highlighting for directory nodes and file nodes
    2              0.000016000 syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
                            
    2              0.000002000 if g:NERDTreeDirArrowExpandable !=# ''
    2              0.000035000     exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
    2              0.000033000     exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
    2              0.000009000     let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
    2              0.000013000     exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
    2              0.000027000     exec 'syn match NERDTreeExecFile #^.*'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmarkName'
    2              0.000053000     exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmarkName,NERDTreeExecFile'
                            else
                                exec 'syn match NERDTreeDir #[^'.g:NERDTreeNodeDelimiter.']\{-}/\ze\($\|'.g:NERDTreeNodeDelimiter.'\)#'
                                exec 'syn match NERDTreeExecFile #[^'.g:NERDTreeNodeDelimiter.']\{-}'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmarkName'
                                exec 'syn match NERDTreeFile     #^.*'.g:NERDTreeNodeDelimiter.'.*[^\/]\($\|'.g:NERDTreeNodeDelimiter.'.*\)# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmarkName,NERDTreeExecFile'
    2              0.000002000 endif
                            
                            "highlighting for readonly files
    2              0.000051000 exec 'syn match NERDTreeRO #.*'.g:NERDTreeNodeDelimiter.'\zs.*\ze'.g:NERDTreeNodeDelimiter.'.*\['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmarkName,NERDTreeFile'
                            
    2              0.000056000 exec 'syn match NERDTreeFlags #\[[^\]]*\]\ze'.g:NERDTreeNodeDelimiter.'# containedin=NERDTreeFile,NERDTreeExecFile,NERDTreeLinkFile,NERDTreeRO,NERDTreeDir'
                            
    2              0.000008000 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
    2              0.000007000 syn match NERDTreeBookmarkName # {.*}#hs=s+2,he=e-1
                            
                            "highlighting for the bookmarks table
    2              0.000006000 syn match NERDTreeBookmarksLeader #^>#
    2              0.000014000 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
    2              0.000014000 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
    2              0.000025000 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
    2              0.000013000 hi def link NERDTreePart Special
    2              0.000017000 hi def link NERDTreePartFile Type
    2              0.000012000 hi def link NERDTreeExecFile Title
    2              0.000012000 hi def link NERDTreeDirSlash Identifier
                            
    2              0.000010000 hi def link NERDTreeBookmarksHeader statement
    2              0.000010000 hi def link NERDTreeBookmarksLeader ignore
    2              0.000010000 hi def link NERDTreeBookmarkName Identifier
    2              0.000011000 hi def link NERDTreeBookmark normal
                            
    2              0.000012000 hi def link NERDTreeHelp String
    2              0.000010000 hi def link NERDTreeHelpKey Identifier
    2              0.000011000 hi def link NERDTreeHelpCommand Identifier
    2              0.000010000 hi def link NERDTreeHelpTitle Macro
    2              0.000012000 hi def link NERDTreeToggleOn Question
    2              0.000012000 hi def link NERDTreeToggleOff WarningMsg
                            
    2              0.000010000 hi def link NERDTreeLinkTarget Type
    2              0.000010000 hi def link NERDTreeLinkFile Macro
    2              0.000011000 hi def link NERDTreeLinkDir Macro
                            
    2              0.000013000 hi def link NERDTreeDir Directory
    2              0.000013000 hi def link NERDTreeUp Directory
    2              0.000013000 hi def link NERDTreeFile Normal
    2              0.000012000 hi def link NERDTreeCWD Statement
    2              0.000012000 hi def link NERDTreeOpenable Directory
    2              0.000013000 hi def link NERDTreeClosable Directory
    2              0.000010000 hi def link NERDTreeIgnore ignore
    2              0.000010000 hi def link NERDTreeRO WarningMsg
    2              0.000010000 hi def link NERDTreeBookmark Statement
    2              0.000010000 hi def link NERDTreeFlags Number
                            
    2              0.000010000 hi def link NERDTreeCurrentNode Search
                            
    2              0.000023000 hi NERDTreeFile ctermbg=NONE guibg=NONE

SCRIPT  /Users/peter.duke/.vim/plugged/vim-go/ftplugin/go.vim
Sourced 8 times
Total time:   0.006652000
 Self time:   0.006652000

count     total (s)      self (s)
                            " Copyright 2013 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " go.vim: Vim filetype plugin for Go.
                            
    8              0.000051000 if exists("b:did_ftplugin")
                              finish
    8              0.000008000 endif
    8              0.000018000 let b:did_ftplugin = 1
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    8              0.000022000 let s:cpo_save = &cpo
    8              0.000050000 set cpo&vim
                            
    8              0.000025000 let b:undo_ftplugin = "setl fo< com< cms<"
                                  \ . "| exe 'au! vim-go-buffer * <buffer>'"
                            
    8              0.000019000 setlocal formatoptions-=t
                            
    8              0.000028000 setlocal comments=s1:/*,mb:*,ex:*/,://
    8              0.000012000 setlocal commentstring=//\ %s
                            
    8              0.000048000 setlocal noexpandtab
                            
    8              0.004176000 compiler go
                            
    8              0.000096000 if go#config#CodeCompletionEnabled()
                              " Set autocompletion
    8              0.000031000   setlocal omnifunc=go#complete#Complete
    8              0.000006000 endif
                            
    8              0.000019000 if get(g:, "go_doc_keywordprg_enabled", 1)
                              " keywordprg doesn't allow to use vim commands, override it
    8              0.000089000   nnoremap <buffer> <silent> K :GoDoc<cr>
    8              0.000004000 endif
                            
    8              0.000013000 if get(g:, "go_def_mapping_enabled", 1)
                              " these are default Vim mappings, we're overriding them to make them
                              " useful again for Go source code
    8              0.000026000   nnoremap <buffer> <silent> gd :GoDef<cr>
    8              0.000029000   nnoremap <buffer> <silent> gD :GoDefType<cr>
    8              0.000037000   nnoremap <buffer> <silent> <C-]> :GoDef<cr>
    8              0.000036000   nnoremap <buffer> <silent> <C-LeftMouse> <LeftMouse>:GoDef<cr>
    8              0.000033000   nnoremap <buffer> <silent> g<LeftMouse> <LeftMouse>:GoDef<cr>
    8              0.000055000   nnoremap <buffer> <silent> <C-w><C-]> :<C-u>call go#def#Jump("split", 0)<CR>
    8              0.000056000   nnoremap <buffer> <silent> <C-w>] :<C-u>call go#def#Jump("split", 0)<CR>
    8              0.000045000   if exists('*settagstack') is 0 || has('patch-8.2.0077') is 0
                                nnoremap <buffer> <silent> <C-t> :<C-U>call go#def#StackPop(v:count1)<cr>
    8              0.000006000   endif
    8              0.000004000 endif
                            
    8              0.000013000 if get(g:, "go_textobj_enabled", 1)
    8              0.000050000   onoremap <buffer> <silent> af :<c-u>call go#textobj#Function('a')<cr>
    8              0.000047000   xnoremap <buffer> <silent> af :<c-u>call go#textobj#Function('a')<cr>
                            
    8              0.000043000   onoremap <buffer> <silent> if :<c-u>call go#textobj#Function('i')<cr>
    8              0.000044000   xnoremap <buffer> <silent> if :<c-u>call go#textobj#Function('i')<cr>
                            
    8              0.000044000   onoremap <buffer> <silent> ac :<c-u>call go#textobj#Comment('a')<cr>
    8              0.000040000   xnoremap <buffer> <silent> ac :<c-u>call go#textobj#Comment('a')<cr>
                            
    8              0.000046000   onoremap <buffer> <silent> ic :<c-u>call go#textobj#Comment('i')<cr>
    8              0.000041000   xnoremap <buffer> <silent> ic :<c-u>call go#textobj#Comment('i')<cr>
                            
                              " Remap ]] and [[ to jump betweeen functions as they are useless in Go
    8              0.000079000   nnoremap <buffer> <silent> ]] :<c-u>call go#textobj#FunctionJump('n', 'next')<cr>
    8              0.000052000   nnoremap <buffer> <silent> [[ :<c-u>call go#textobj#FunctionJump('n', 'prev')<cr>
                            
    8              0.000051000   onoremap <buffer> <silent> ]] :<c-u>call go#textobj#FunctionJump('o', 'next')<cr>
    8              0.000053000   onoremap <buffer> <silent> [[ :<c-u>call go#textobj#FunctionJump('o', 'prev')<cr>
                            
    8              0.000050000   xnoremap <buffer> <silent> ]] :<c-u>call go#textobj#FunctionJump('v', 'next')<cr>
    8              0.000053000   xnoremap <buffer> <silent> [[ :<c-u>call go#textobj#FunctionJump('v', 'prev')<cr>
    8              0.000003000 endif
                            
                            " Autocommands
                            " ============================================================================
                            "
    8              0.000013000 augroup vim-go-buffer
    8              0.000298000   autocmd! * <buffer>
                            
                              " The file is registered (textDocument/DidOpen) with gopls in plugin/go.vim
                              " on the FileType event.
                            
    8              0.000066000   if go#util#has_job()
    8              0.000036000     autocmd BufWritePost,FileChangedShellPost <buffer> call go#lsp#DidChange(resolve(expand('<afile>:p')))
    8              0.000018000     autocmd BufDelete <buffer> call go#lsp#DidClose(resolve(expand('<afile>:p')))
    8              0.000004000   endif
                            
                              " send the textDocument/didChange notification when idle. go#lsp#DidChange
                              " will not send an event if the buffer hasn't changed since the last
                              " notification.
    8              0.000019000   autocmd CursorHold,CursorHoldI <buffer> call go#lsp#DidChange(resolve(expand('<afile>:p')))
                            
    8              0.000020000   autocmd BufEnter,CursorHold <buffer> call go#auto#update_autocmd()
                            
                              " Echo the identifier information when completion is done. Useful to see
                              " the signature of a function, etc...
    8              0.000016000   if exists('##CompleteDone')
    8              0.000015000     autocmd CompleteDone <buffer> call go#auto#complete_done()
    8              0.000003000   endif
                            
    8              0.000013000   autocmd BufWritePre <buffer> call go#auto#fmt_autosave()
    8              0.000013000   autocmd BufWritePost <buffer> call go#auto#metalinter_autosave()
                            
                              " TODO(bc): autocmd BufWinLeave call go#lsp#DidChange(expand('<afile>:p'))
                            
    8              0.000017000   if !has('textprop')
                                "TODO(bc): how to clear sameids and diagnostics when a non-go buffer is
                                " loaded into a window and the previously loaded buffer is still loaded in
                                " another window?
                            
                                " TODO(bc): only clear when the new buffer isn't the old buffer
                            
                                " clear SameIds when the buffer is unloaded from its last window so that
                                " loading another buffer (especially of a different filetype) in the same
                                " window doesn't highlight the most recently matched identifier's positions.
                                autocmd BufWinLeave <buffer> call go#sameids#ClearSameIds()
                                " clear SameIds when a new buffer is loaded in the window so that the
                                " previous buffer's highlighting isn't used.
                                autocmd BufWinEnter <buffer> call go#sameids#ClearSameIds()
                            
                                " clear diagnostics when the buffer is unloaded from its last window so that
                                " loading another buffer (especially of a different filetype) in the same
                                " window doesn't highlight the previously loaded buffer's diagnostics.
                                autocmd BufWinLeave <buffer> call go#lsp#ClearDiagnosticHighlights()
                                " clear diagnostics when a new buffer is loaded in the window so that the
                                " previous buffer's diagnostics aren't used.
                                "autocmd BufWinEnter <buffer> call go#lsp#ClearDiagnosticHighlights()
    8              0.000006000   endif
    8              0.000004000 augroup end
                            
                            " restore Vi compatibility settings
    8              0.000023000 let &cpo = s:cpo_save
    8              0.000007000 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/peter.duke/.vim/plugged/vim-go/compiler/go.vim
Sourced 8 times
Total time:   0.000705000
 Self time:   0.000705000

count     total (s)      self (s)
                            " Copyright 2013 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " compiler/go.vim: Vim compiler file for Go.
                            
    8              0.000023000 if exists("g:current_compiler")
                              finish
    8              0.000006000 endif
    8              0.000026000 let g:current_compiler = "go"
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    8              0.000017000 let s:cpo_save = &cpo
    8              0.000021000 set cpo&vim
                            
    8              0.000026000 if exists(":CompilerSet") != 2
                              command -nargs=* CompilerSet setlocal <args>
    8              0.000007000 endif
                            
    8              0.000015000 let s:save_cpo = &cpo
    8              0.000019000 set cpo-=C
    8              0.000105000 if filereadable("makefile") || filereadable("Makefile")
                              CompilerSet makeprg=make
    8              0.000007000 else
    8              0.000042000   CompilerSet makeprg=go\ build
    8              0.000005000 endif
                            
                            " Define the patterns that will be recognized by QuickFix when parsing the
                            " output of Go command that use this errorforamt (when called make, cexpr or
                            " lmake, lexpr). This is the global errorformat, however some command might
                            " use a different output, for those we define them directly and modify the
                            " errorformat ourselves. More information at:
                            " http://vimdoc.sourceforge.net/htmldoc/quickfix.html#errorformat
    8              0.000045000 CompilerSet errorformat =%-G#\ %.%#                                 " Ignore lines beginning with '#' ('# command-line-arguments' line sometimes appears?)
    8              0.000025000 CompilerSet errorformat+=%-G%.%#panic:\ %m                          " Ignore lines containing 'panic: message'
    8              0.000041000 CompilerSet errorformat+=%Ecan\'t\ load\ package:\ %m               " Start of multiline error string is 'can\'t load package'
    8              0.000028000 CompilerSet errorformat+=%A%\\%%(%[%^:]%\\+:\ %\\)%\\?%f:%l:%c:\ %m " Start of multiline unspecified string is 'filename:linenumber:columnnumber:'
    8              0.000023000 CompilerSet errorformat+=%A%\\%%(%[%^:]%\\+:\ %\\)%\\?%f:%l:\ %m    " Start of multiline unspecified string is 'filename:linenumber:'
    8              0.000024000 CompilerSet errorformat+=%C%*\\s%m                                  " Continuation of multiline error message is indented
    8              0.000022000 CompilerSet errorformat+=%-G%.%#                                    " All lines not matching any of the above patterns are ignored
    8              0.000026000 let &cpo = s:save_cpo
    8              0.000012000 unlet s:save_cpo
                            
                            " restore Vi compatibility settings
    8              0.000017000 let &cpo = s:cpo_save
    8              0.000007000 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/compiler/go.vim
Sourced 8 times
Total time:   0.000093000
 Self time:   0.000093000

count     total (s)      self (s)
                            " Vim compiler file
                            " Compiler:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2014 Aug 16
                            "             	2024 Apr 05 by The Vim Project (removed :CompilerSet definition)
                            
    8              0.000040000 if exists('current_compiler')
    8              0.000006000   finish
                            endif
                            let current_compiler = 'go'
                            
                            let s:save_cpo = &cpo
                            set cpo-=C
                            
                            CompilerSet makeprg=go\ build
                            CompilerSet errorformat=
                                \%-G#\ %.%#,
                                \%A%f:%l:%c:\ %m,
                                \%A%f:%l:\ %m,
                                \%C%*\\s%m,
                                \%-G%.%#
                            
                            let &cpo = s:save_cpo
                            unlet s:save_cpo
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /Users/peter.duke/.vim/plugged/vim-go/ftplugin/go/commands.vim
Sourced 8 times
Total time:   0.003890000
 Self time:   0.003846000

count     total (s)      self (s)
                            " -- gorename
    8              0.000104000 command! -nargs=? -complete=customlist,go#rename#Complete GoRename call go#rename#Rename(<bang>0, <f-args>)
                            
    8              0.000060000 command! -range=% GoImplements call go#implements#Implements(<count>)
    8              0.000082000 command! -range=% GoReferrers call go#referrers#Referrers(<count>)
    8              0.000042000 command! -range=0 GoSameIds call go#sameids#SameIds(1)
    8              0.000062000 command! -range=0 GoSameIdsClear call go#sameids#ClearSameIds()
    8              0.000047000 command! -range=0 GoSameIdsToggle call go#sameids#ToggleSameIds()
    8              0.000046000 command! -range=0 GoSameIdsAutoToggle call go#sameids#AutoToggleSameIds()
                            
                            " -- calls
    8              0.000033000 command! -nargs=0 GoCallers call go#calls#Callers()
                            
                            " -- tags
    8              0.000080000 command! -nargs=* -range GoAddTags call go#tags#Add(<line1>, <line2>, <count>, <f-args>)
    8              0.000090000 command! -nargs=* -range GoRemoveTags call go#tags#Remove(<line1>, <line2>, <count>, <f-args>)
                            
                            " -- mod
    8              0.000036000 command! -nargs=0 -range GoModFmt call go#mod#Format()
                            
                            " -- tool
    8              0.000055000 command! -nargs=* -complete=customlist,go#tool#ValidFiles GoFiles echo go#tool#Files(<f-args>)
    8              0.000033000 command! -nargs=0 GoDeps echo go#tool#Deps()
    8              0.000033000 command! -nargs=0 GoInfo call go#tool#Info(1)
    8              0.000045000 command! -nargs=0 GoAutoTypeInfoToggle call go#complete#ToggleAutoTypeInfo()
                            
                            " -- cmd
    8              0.000051000 command! -nargs=* -bang GoBuild call go#cmd#Build(<bang>0,<f-args>)
    8              0.000052000 command! -nargs=? -bang GoBuildTags call go#cmd#BuildTags(<bang>0, <f-args>)
    8              0.000053000 command! -nargs=* -bang GoGenerate call go#cmd#Generate(<bang>0,<f-args>)
    8              0.000072000 command! -nargs=* -bang -complete=file GoRun call go#cmd#Run(<bang>0,<f-args>)
    8              0.000055000 command! -nargs=* -bang GoInstall call go#cmd#Install(<bang>0, <f-args>)
                            
                            " -- test
    8              0.000057000 command! -nargs=* -bang GoTest call go#test#Test(<bang>0, 0, <f-args>)
    8              0.000055000 command! -nargs=* -bang GoTestCompile call go#test#Test(<bang>0, 1, <f-args>)
    8              0.000054000 command! -nargs=* -bang GoTestFile call go#test#File(<bang>0, <f-args>)
    8              0.000053000 command! -nargs=* -bang GoTestFunc call go#test#Func(<bang>0, <f-args>)
                            
                            " -- cover
    8              0.000054000 command! -nargs=* -bang GoCoverage call go#coverage#Buffer(<bang>0, <f-args>)
    8              0.000037000 command! -nargs=* -bang GoCoverageClear call go#coverage#Clear()
    8              0.000085000 command! -nargs=* -bang GoCoverageToggle call go#coverage#BufferToggle(<bang>0, <f-args>)
    8              0.000076000 command! -nargs=* -bang GoCoverageBrowser call go#coverage#Browser(<bang>0, <f-args>)
    8              0.000046000 command! -nargs=1 -complete=file GoCoverageOverlay call go#coverage#Overlay(<f-args>)
                            
                            " -- play
    8              0.000068000 command! -nargs=0 -range=% GoPlay call go#play#Share(<count>, <line1>, <line2>)
                            
                            " -- def
    8              0.000038000 command! -nargs=* -range GoDef :call go#def#Jump('', 0)
    8              0.000036000 command! -nargs=* -range GoDefType :call go#def#Jump('', 1)
    8              0.000041000 command! -nargs=? GoDefPop :call go#def#StackPop(<f-args>)
    8              0.000039000 command! -nargs=? GoDefStack :call go#def#Stack(<f-args>)
    8              0.000044000 command! -nargs=? GoDefStackClear :call go#def#StackClear(<f-args>)
                            
                            " -- doc
    8              0.000054000 command! -nargs=* -range -complete=customlist,go#package#Complete GoDoc call go#doc#Open('new', 'split', <f-args>)
    8              0.000046000 command! -nargs=* -range -complete=customlist,go#package#Complete GoDocBrowser call go#doc#OpenBrowser(<f-args>)
                            
                            " -- fmt
    8              0.000032000 command! -nargs=0 GoFmt call go#fmt#Format(0)
    8              0.000044000 command! -nargs=0 GoFmtAutoSaveToggle call go#fmt#ToggleFmtAutoSave()
    8              0.000038000 command! -nargs=0 GoImports call go#fmt#Format(1)
                            
                            " -- asmfmt
    8              0.000045000 command! -nargs=0 GoAsmFmtAutoSaveToggle call go#asmfmt#ToggleAsmFmtAutoSave()
                            
                            " -- import
    8              0.000059000 command! -nargs=? -complete=customlist,go#package#Complete GoDrop call go#import#SwitchImport(0, '', <f-args>, '')
    8              0.000074000 command! -nargs=1 -bang -complete=customlist,go#package#Complete GoImport call go#import#SwitchImport(1, '', <f-args>, '<bang>')
    8              0.000065000 command! -nargs=* -bang -complete=customlist,go#package#Complete GoImportAs call go#import#SwitchImport(1, <f-args>, '<bang>')
                            
                            " -- linters
    8              0.000058000 command! -nargs=* -bang GoMetaLinter call go#lint#Gometa(<bang>0, 0, <f-args>)
    8              0.000050000 command! -nargs=0 GoMetaLinterAutoSaveToggle call go#lint#ToggleMetaLinterAutoSave()
    8              0.000051000 command! -nargs=* -bang GoLint call go#lint#Golint(<bang>0, <f-args>)
    8              0.000055000 command! -nargs=* -bang GoVet call go#lint#Vet(<bang>0, <f-args>)
    8              0.000055000 command! -nargs=* -bang -complete=customlist,go#package#Complete GoErrCheck call go#lint#Errcheck(<bang>0, <f-args>)
                            
                            " -- alternate
    8              0.000050000 command! -bang GoAlternate call go#alternate#Switch(<bang>0, '')
                            
                            " -- decls
    8              0.000045000 command! -nargs=? -complete=file GoDecls call go#decls#Decls(0, <q-args>)
    8              0.000049000 command! -nargs=? -complete=dir GoDeclsDir call go#decls#Decls(1, <q-args>)
                            
                            " -- impl
    8              0.000045000 command! -nargs=* -complete=customlist,go#impl#Complete GoImpl call go#impl#Impl(<f-args>)
                            
                            " -- template
    8              0.000048000 command! -nargs=0 GoTemplateAutoCreateToggle call go#template#ToggleAutoCreate()
                            
                            " -- keyify
    8   0.000374000   0.000330000 if go#package#InGOPATH()
                              command! -nargs=0 GoKeyify call go#keyify#Keyify()
    8              0.000003000 endif
                            
                            " -- fillstruct
    8              0.000045000 command! -nargs=0 GoFillStruct call go#fillstruct#FillStruct()
                            
                            " -- debug
    8              0.000019000 if !exists(':GoDebugStart')
                              command! -nargs=* -complete=customlist,go#package#Complete GoDebugStart call go#debug#Start('debug', <f-args>)
                              command! -nargs=* -complete=customlist,go#package#Complete GoDebugTest  call go#debug#Start('test', <f-args>)
                              command! -nargs=* GoDebugTestFunc  call go#debug#TestFunc(<f-args>)
                              command! -nargs=1 GoDebugAttach call go#debug#Start('attach', <f-args>)
                              command! -nargs=? GoDebugConnect call go#debug#Start('connect', <f-args>)
                              command! -nargs=? GoDebugBreakpoint call go#debug#Breakpoint(<f-args>)
    8              0.000005000 endif
                            
                            " -- issue
    8              0.000033000 command! -nargs=0 GoReportGitHubIssue call go#issue#New()
                            
                            " -- iferr
    8              0.000038000 command! -nargs=0 GoIfErr call go#iferr#Generate()
                            
                            " -- lsp
    8              0.000059000 command! -nargs=+ -complete=dir GoAddWorkspace call go#lsp#AddWorkspaceDirectory(<f-args>)
    8              0.000037000 command! -nargs=0 GoLSPDebugBrowser call go#lsp#DebugBrowser()
    8              0.000060000 command! -nargs=* -bang GoDiagnostics call go#lint#Diagnostics(<bang>0, <f-args>)
    8              0.000037000 command! -nargs=? GoModReload call go#lsp#ModReload()
                            
                            " -- term
    8              0.000046000 command! GoToggleTermCloseOnExit call go#term#ToggleCloseOnExit()
                            
                            " -- extract
    8              0.000062000 command! -range GoExtract call go#extract#Extract(<line1>, <line2>)
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/peter.duke/.vim/plugged/vim-go/ftplugin/go/mappings.vim
Sourced 8 times
Total time:   0.004230000
 Self time:   0.004230000

count     total (s)      self (s)
                            " go_jump_to_error defines whether we should pass the bang attribute to the
                            " command or not. This is only used for mappings, because the user can't pass
                            " the bang attribute to the plug mappings below. So instead of hardcoding it
                            " as 0 (no '!' attribute) or 1 (with '!' attribute) we pass the user setting,
                            " which by default is enabled. For commands the user has the ability to pass
                            " the '!', such as :GoBuild or :GoBuild!
    8              0.000026000 if !exists("g:go_jump_to_error")
                              let g:go_jump_to_error = 1
    8              0.000006000 endif
                            
                            " Some handy plug mappings
    8              0.000188000 nnoremap <silent> <Plug>(go-run) :<C-u>call go#cmd#Run(!g:go_jump_to_error)<CR>
                            
    8              0.000033000 if has("nvim") || has("terminal")
    8              0.000102000   nnoremap <silent> <Plug>(go-run-vertical) :<C-u>call go#cmd#RunTerm(!g:go_jump_to_error, 'vsplit', [])<CR>
    8              0.000095000   nnoremap <silent> <Plug>(go-run-split) :<C-u>call go#cmd#RunTerm(!g:go_jump_to_error, 'split', [])<CR>
    8              0.000085000   nnoremap <silent> <Plug>(go-run-tab) :<C-u>call go#cmd#RunTerm(!g:go_jump_to_error, 'tabe', [])<CR>
    8              0.000003000 endif
                            
    8              0.000077000 nnoremap <silent> <Plug>(go-build) :<C-u>call go#cmd#Build(!g:go_jump_to_error)<CR>
    8              0.000077000 nnoremap <silent> <Plug>(go-generate) :<C-u>call go#cmd#Generate(!g:go_jump_to_error)<CR>
    8              0.000074000 nnoremap <silent> <Plug>(go-install) :<C-u>call go#cmd#Install(!g:go_jump_to_error)<CR>
    8              0.000076000 nnoremap <silent> <Plug>(go-test) :<C-u>call go#test#Test(!g:go_jump_to_error, 0)<CR>
    8              0.000074000 nnoremap <silent> <Plug>(go-test-func) :<C-u>call go#test#Func(!g:go_jump_to_error)<CR>
    8              0.000077000 nnoremap <silent> <Plug>(go-test-compile) :<C-u>call go#test#Test(!g:go_jump_to_error, 1)<CR>
    8              0.000072000 nnoremap <silent> <Plug>(go-test-file) :<C-u>call go#test#File(!g:go_jump_to_error)<CR>
                            
    8              0.000076000 nnoremap <silent> <Plug>(go-coverage) :<C-u>call go#coverage#Buffer(!g:go_jump_to_error)<CR>
    8              0.000077000 nnoremap <silent> <Plug>(go-coverage-clear) :<C-u>call go#coverage#Clear()<CR>
    8              0.000094000 nnoremap <silent> <Plug>(go-coverage-toggle) :<C-u>call go#coverage#BufferToggle(!g:go_jump_to_error)<CR>
    8              0.000085000 nnoremap <silent> <Plug>(go-coverage-browser) :<C-u>call go#coverage#Browser(!g:go_jump_to_error)<CR>
                            
    8              0.000056000 nnoremap <silent> <Plug>(go-files) :<C-u>call go#tool#Files()<CR>
    8              0.000061000 nnoremap <silent> <Plug>(go-deps) :<C-u>call go#tool#Deps()<CR>
    8              0.000057000 nnoremap <silent> <Plug>(go-info) :<C-u>call go#tool#Info(1)<CR>
    8              0.000100000 nnoremap <silent> <Plug>(go-import) :<C-u>call go#import#SwitchImport(1, '', expand('<cword>'), '')<CR>
    8              0.000062000 nnoremap <silent> <Plug>(go-imports) :<C-u>call go#fmt#Format(1)<CR>
    8              0.000057000 nnoremap <silent> <Plug>(go-fmt) :<C-u>call go#fmt#Format(0)<CR>
                            
    8              0.000071000 nnoremap <silent> <Plug>(go-implements) :<C-u>call go#implements#Implements(-1)<CR>
    8              0.000067000 nnoremap <silent> <Plug>(go-referrers) :<C-u>call go#referrers#Referrers(-1)<CR>
    8              0.000061000 nnoremap <silent> <Plug>(go-sameids) :<C-u>call go#sameids#SameIds(1)<CR>
    8              0.000073000 nnoremap <silent> <Plug>(go-sameids-toggle) :<C-u>call go#sameids#ToggleSameIds()<CR>
                            
    8              0.000074000 nnoremap <silent> <Plug>(go-rename) :<C-u>call go#rename#Rename(!g:go_jump_to_error)<CR>
                            
    8              0.000058000 nnoremap <silent> <Plug>(go-decls) :<C-u>call go#decls#Decls(0, '')<CR>
    8              0.000063000 nnoremap <silent> <Plug>(go-decls-dir) :<C-u>call go#decls#Decls(1, '')<CR>
                            
    8              0.000058000 nnoremap <silent> <Plug>(go-def) :<C-u>call go#def#Jump('', 0)<CR>
    8              0.000069000 nnoremap <silent> <Plug>(go-def-vertical) :<C-u>call go#def#Jump("vsplit", 0)<CR>
    8              0.000064000 nnoremap <silent> <Plug>(go-def-split) :<C-u>call go#def#Jump("split", 0)<CR>
    8              0.000061000 nnoremap <silent> <Plug>(go-def-tab) :<C-u>call go#def#Jump("tab", 0)<CR>
                            
    8              0.000059000 nnoremap <silent> <Plug>(go-def-type) :<C-u>call go#def#Jump('', 1)<CR>
    8              0.000073000 nnoremap <silent> <Plug>(go-def-type-vertical) :<C-u>call go#def#Jump("vsplit", 1)<CR>
    8              0.000069000 nnoremap <silent> <Plug>(go-def-type-split) :<C-u>call go#def#Jump("split", 1)<CR>
    8              0.000066000 nnoremap <silent> <Plug>(go-def-type-tab) :<C-u>call go#def#Jump("tab", 1)<CR>
                            
    8              0.000058000 nnoremap <silent> <Plug>(go-def-pop) :<C-u>call go#def#StackPop()<CR>
    8              0.000057000 nnoremap <silent> <Plug>(go-def-stack) :<C-u>call go#def#Stack()<CR>
    8              0.000067000 nnoremap <silent> <Plug>(go-def-stack-clear) :<C-u>call go#def#StackClear()<CR>
                            
    8              0.000065000 nnoremap <silent> <Plug>(go-doc) :<C-u>call go#doc#Open("new", "split")<CR>
    8              0.000070000 nnoremap <silent> <Plug>(go-doc-tab) :<C-u>call go#doc#Open("tabnew", "tabe")<CR>
    8              0.000085000 nnoremap <silent> <Plug>(go-doc-vertical) :<C-u>call go#doc#Open("vnew", "vsplit")<CR>
    8              0.000069000 nnoremap <silent> <Plug>(go-doc-split) :<C-u>call go#doc#Open("new", "split")<CR>
    8              0.000063000 nnoremap <silent> <Plug>(go-doc-browser) :<C-u>call go#doc#OpenBrowser()<CR>
                            
    8              0.000081000 nnoremap <silent> <Plug>(go-metalinter) :<C-u>call go#lint#Gometa(!g:go_jump_to_error, 0)<CR>
    8              0.000069000 nnoremap <silent> <Plug>(go-lint) :<C-u>call go#lint#Golint(!g:go_jump_to_error)<CR>
    8              0.000069000 nnoremap <silent> <Plug>(go-vet) :<C-u>call go#lint#Vet(!g:go_jump_to_error)<CR>
                            
    8              0.000075000 nnoremap <silent> <Plug>(go-alternate-edit) :<C-u>call go#alternate#Switch(0, "edit")<CR>
    8              0.000081000 nnoremap <silent> <Plug>(go-alternate-vertical) :<C-u>call go#alternate#Switch(0, "vsplit")<CR>
    8              0.000076000 nnoremap <silent> <Plug>(go-alternate-split) :<C-u>call go#alternate#Switch(0, "split")<CR>
                            
                            " go-iferr is deprecated, but remains for backward compatibility
    8              0.000058000 nnoremap <silent> <Plug>(go-iferr) :<C-u>call go#iferr#Generate()<CR>
    8              0.000057000 nnoremap <silent> <Plug>(go-if-err) :<C-u>call go#iferr#Generate()<CR>
                            
    8              0.000081000 nnoremap <silent> <Plug>(go-diagnostics) :<C-u>call go#lint#Diagnostics(!g:go_jump_to_error)<CR>
                            
    8              0.000069000 nnoremap <silent> <Plug>(go-fill-struct) :<C-u>call go#fillstruct#FillStruct()<CR>
                            
    8              0.000065000 xnoremap <silent> <Plug>(go-extract) :<C-u>call go#extract#Extract(0)<CR>
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/peter.duke/.vim/plugged/vim-go/ftplugin/go/snippets.vim
Sourced 8 times
Total time:   0.000106000
 Self time:   0.000106000

count     total (s)      self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    8              0.000025000 let s:cpo_save = &cpo
    8              0.000023000 set cpo&vim
                            
    8              0.000022000 if exists("g:go_loaded_gosnippets")
    8              0.000005000   finish
                            endif
                            let g:go_loaded_gosnippets = 1
                            
                            function! s:GoUltiSnips() abort
                              if get(g:, 'did_plugin_ultisnips') isnot 1
                                return
                              endif
                            
                              if !exists("g:UltiSnipsSnippetDirectories")
                                let g:UltiSnipsSnippetDirectories = ["gosnippets/UltiSnips"]
                              else
                                let g:UltiSnipsSnippetDirectories += ["gosnippets/UltiSnips"]
                              endif
                            endfunction
                            
                            function! s:GoNeosnippet() abort
                              if get(g:, 'loaded_neosnippet') isnot 1
                                return
                              endif
                            
                              let g:neosnippet#enable_snipmate_compatibility = 1
                            
                              let l:gosnippets_dir = globpath(&rtp, 'gosnippets/snippets')
                              if type(g:neosnippet#snippets_directory) == type([])
                                let g:neosnippet#snippets_directory += [l:gosnippets_dir]
                              elseif type(g:neosnippet#snippets_directory) == type("")
                                if strlen(g:neosnippet#snippets_directory) > 0
                                  let g:neosnippet#snippets_directory = g:neosnippet#snippets_directory . "," . l:gosnippets_dir
                                else
                                  let g:neosnippet#snippets_directory = l:gosnippets_dir
                                endif
                              endif
                            endfunction
                            
                            function! s:GoMinisnip() abort
                              if get(g:, 'loaded_minisnip') isnot 1
                                return
                              endif
                            
                              if exists('g:minisnip_dir')
                                let g:minisnip_dir .= go#util#PathListSep() . globpath(&rtp, 'gosnippets/minisnip')
                              else
                                let g:minisnip_dir = globpath(&rtp, 'gosnippets/minisnip')
                              endif
                            endfunction
                            
                            
                            let s:engine = go#config#SnippetEngine()
                            if s:engine is? 'ultisnips'
                              call s:GoUltiSnips()
                            elseif s:engine is? 'neosnippet'
                              call s:GoNeosnippet()
                            elseif s:engine is? 'minisnip'
                              call s:GoMinisnip()
                            endif
                            
                            " restore Vi compatibility settings
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /Users/peter.duke/.vim/plugged/vim-go/ftplugin/go/tagbar.vim
Sourced 8 times
Total time:   0.013409000
 Self time:   0.012141000

count     total (s)      self (s)
                            " Check if tagbar is installed under plugins or is directly under rtp
                            " this covers pathogen + Vundle/Bundle
                            "
                            " Also make sure the ctags command exists
                            "
    8              0.003544000 if !executable('ctags')
                              finish
    8              0.001836000 elseif globpath(&rtp, 'plugin/tagbar.vim') == ""
                              finish
    8              0.000003000 endif
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    8              0.000017000 let s:cpo_save = &cpo
    8              0.000019000 set cpo&vim
                            
    8              0.000018000 if !exists("g:go_gotags_bin")
                              let g:go_gotags_bin = "gotags"
    8              0.000005000 endif
                            
                            
    8              0.000030000 function! s:SetTagbar()
                              let bin_path = go#path#CheckBinPath(g:go_gotags_bin)
                              if empty(bin_path)
                                return
                              endif
                            
                              if !exists("g:tagbar_type_go")
                                let g:tagbar_type_go = {
                                      \ 'ctagstype' : 'go',
                                      \ 'kinds'     : [
                                      \ 'p:package',
                                      \ 'i:imports',
                                      \ 'c:constants',
                                      \ 'v:variables',
                                      \ 't:types',
                                      \ 'n:interfaces',
                                      \ 'w:fields',
                                      \ 'e:embedded',
                                      \ 'm:methods',
                                      \ 'r:constructor',
                                      \ 'f:functions'
                                      \ ],
                                      \ 'sro' : '.',
                                      \ 'kind2scope' : {
                                      \ 't' : 'ctype',
                                      \ 'n' : 'ntype'
                                      \ },
                                      \ 'scope2kind' : {
                                      \ 'ctype' : 't',
                                      \ 'ntype' : 'n'
                                      \ },
                                      \ 'ctagsbin'  : bin_path,
                                      \ 'ctagsargs' : '-sort -silent'
                                      \ }
                              endif
                            endfunction
                            
                            
    8   0.007654000   0.006386000 call s:SetTagbar()
                            
                            " restore Vi compatibility settings
    8              0.000025000 let &cpo = s:cpo_save
    8              0.000009000 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/ftplugin/go.vim
Sourced 8 times
Total time:   0.000066000
 Self time:   0.000066000

count     total (s)      self (s)
                            " Vim filetype plugin file
                            " Language:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2014 Aug 16
                            
    8              0.000023000 if exists('b:did_ftplugin')
    8              0.000004000   finish
                            endif
                            let b:did_ftplugin = 1
                            
                            setlocal formatoptions-=t
                            
                            setlocal comments=s1:/*,mb:*,ex:*/,://
                            setlocal commentstring=//\ %s
                            
                            let b:undo_ftplugin = 'setl fo< com< cms<'
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /Users/peter.duke/.vim/plugged/vim-go/indent/go.vim
Sourced 8 times
Total time:   0.000285000
 Self time:   0.000285000

count     total (s)      self (s)
                            " Copyright 2011 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " indent/go.vim: Vim indent file for Go.
                            "
                            " TODO:
                            " - function invocations split across lines
                            " - general line splits (line ends in an operator)
                            
    8              0.000025000 if exists("b:did_indent")
                              finish
    8              0.000004000 endif
    8              0.000013000 let b:did_indent = 1
                            
                            " C indentation is too far off useful, mainly due to Go's := operator.
                            " Let's just define our own.
    8              0.000087000 setlocal nolisp
    8              0.000015000 setlocal autoindent
    8              0.000021000 setlocal indentexpr=GoIndent(v:lnum)
    8              0.000034000 setlocal indentkeys+=<:>,0=},0=)
                            
    8              0.000018000 if exists("*GoIndent")
    8              0.000004000   finish
                            endif
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            function! GoIndent(lnum) abort
                              let prevlnum = prevnonblank(a:lnum-1)
                              if prevlnum == 0
                                " top of file
                                return 0
                              endif
                            
                              " grab the previous and current line, stripping comments.
                              let prevl = substitute(getline(prevlnum), '//.*$', '', '')
                              let thisl = substitute(getline(a:lnum), '//.*$', '', '')
                              let previ = indent(prevlnum)
                            
                              let ind = previ
                            
                              for synid in synstack(a:lnum, 1)
                                if synIDattr(synid, 'name') == 'goRawString'
                                  if prevl =~ '\%(\%(:\?=\)\|(\|,\)\s*`[^`]*$'
                                    " previous line started a multi-line raw string
                                    return 0
                                  endif
                                  " return -1 to keep the current indent.
                                  return -1
                                endif
                              endfor
                            
                              if prevl =~ '[({]\s*$'
                                " previous line opened a block
                                let ind += shiftwidth()
                              endif
                              if prevl =~# '^\s*\(case .*\|default\):$'
                                " previous line is part of a switch statement
                                let ind += shiftwidth()
                              endif
                              " TODO: handle if the previous line is a label.
                            
                              if thisl =~ '^\s*[)}]'
                                " this line closed a block
                                let ind -= shiftwidth()
                              endif
                            
                              " Colons are tricky.
                              " We want to outdent if it's part of a switch ("case foo:" or "default:").
                              " We ignore trying to deal with jump labels because (a) they're rare, and
                              " (b) they're hard to disambiguate from a composite literal key.
                              if thisl =~# '^\s*\(case .*\|default\):$'
                                let ind -= shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
                            " restore Vi compatibility settings
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/indent/go.vim
Sourced 8 times
Total time:   0.000103000
 Self time:   0.000103000

count     total (s)      self (s)
                            " Vim indent file
                            " Language:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2017 Jun 13
                            "		2023 Aug 28 by Vim Project (undo_indent)
                            "
                            " TODO:
                            " - function invocations split across lines
                            " - general line splits (line ends in an operator)
                            
    8              0.000036000 if exists('b:did_indent')
    8              0.000005000   finish
                            endif
                            let b:did_indent = 1
                            
                            " C indentation is too far off useful, mainly due to Go's := operator.
                            " Let's just define our own.
                            setlocal nolisp
                            setlocal autoindent
                            setlocal indentexpr=GoIndent(v:lnum)
                            setlocal indentkeys+=<:>,0=},0=)
                            
                            let b:undo_indent = "setl ai< inde< indk< lisp<"
                            
                            if exists('*GoIndent')
                              finish
                            endif
                            
                            function! GoIndent(lnum)
                              let l:prevlnum = prevnonblank(a:lnum-1)
                              if l:prevlnum == 0
                                " top of file
                                return 0
                              endif
                            
                              " grab the previous and current line, stripping comments.
                              let l:prevl = substitute(getline(l:prevlnum), '//.*$', '', '')
                              let l:thisl = substitute(getline(a:lnum), '//.*$', '', '')
                              let l:previ = indent(l:prevlnum)
                            
                              let l:ind = l:previ
                            
                              if l:prevl =~ '[({]\s*$'
                                " previous line opened a block
                                let l:ind += shiftwidth()
                              endif
                              if l:prevl =~# '^\s*\(case .*\|default\):$'
                                " previous line is part of a switch statement
                                let l:ind += shiftwidth()
                              endif
                              " TODO: handle if the previous line is a label.
                            
                              if l:thisl =~ '^\s*[)}]'
                                " this line closed a block
                                let l:ind -= shiftwidth()
                              endif
                            
                              " Colons are tricky.
                              " We want to outdent if it's part of a switch ("case foo:" or "default:").
                              " We ignore trying to deal with jump labels because (a) they're rare, and
                              " (b) they're hard to disambiguate from a composite literal key.
                              if l:thisl =~# '^\s*\(case .*\|default\):$'
                                let l:ind -= shiftwidth()
                              endif
                            
                              return l:ind
                            endfunction
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /Users/peter.duke/.vim/plugged/vim-go/syntax/go.vim
Sourced 16 times
Total time:   0.027345000
 Self time:   0.027210000

count     total (s)      self (s)
                            " Copyright 2009 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " go.vim: Vim syntax file for Go.
                            
                            " Quit when a (custom) syntax file was already loaded
   16              0.000045000 if exists("b:current_syntax")
                              finish
   16              0.000006000 endif
                            
   16              0.000016000 syn case match
                            
   16              0.000196000 syn keyword     goPackage           package
   16              0.000056000 syn keyword     goImport            import    contained
   16              0.000045000 syn keyword     goVar               var       contained
   16              0.000045000 syn keyword     goConst             const     contained
                            
   16              0.000174000 hi def link     goPackage           Statement
   16              0.000091000 hi def link     goImport            Statement
   16              0.000087000 hi def link     goVar               Keyword
   16              0.000083000 hi def link     goConst             Keyword
   16              0.000095000 hi def link     goDeclaration       Keyword
                            
                            " Keywords within functions
   16              0.000069000 syn keyword     goStatement         defer go goto return break continue fallthrough
   16              0.000056000 syn keyword     goConditional       if else switch select
   16              0.000045000 syn keyword     goLabel             case default
   16              0.000043000 syn keyword     goRepeat            for range
                            
   16              0.000098000 hi def link     goStatement         Statement
   16              0.000090000 hi def link     goConditional       Conditional
   16              0.000084000 hi def link     goLabel             Label
   16              0.000091000 hi def link     goRepeat            Repeat
                            
                            " Predefined types
   16              0.000060000 syn keyword     goType              chan map bool string error any comparable
   16              0.000051000 syn keyword     goSignedInts        int int8 int16 int32 int64 rune
   16              0.000050000 syn keyword     goUnsignedInts      byte uint uint8 uint16 uint32 uint64 uintptr
   16              0.000044000 syn keyword     goFloats            float32 float64
   16              0.000058000 syn keyword     goComplexes         complex64 complex128
                            
   16              0.000083000 hi def link     goType              Type
   16              0.000090000 hi def link     goSignedInts        Type
   16              0.000083000 hi def link     goUnsignedInts      Type
   16              0.000081000 hi def link     goFloats            Type
   16              0.000083000 hi def link     goComplexes         Type
                            
                            " Predefined functions and values
   16              0.000074000 syn keyword     goBuiltins                 append cap clear close complex copy delete imag len
   16              0.000066000 syn keyword     goBuiltins                 make max min new panic print println real recover
   16              0.000044000 syn keyword     goBoolean                  true false
   16              0.000044000 syn keyword     goPredefinedIdentifiers    nil iota
                            
   16              0.000110000 hi def link     goBuiltins                 Identifier
   16              0.000105000 hi def link     goPredefinedIdentifiers    Constant
                            " Boolean links to Constant by default by vim: goBoolean and goPredefinedIdentifiers
                            " will be highlighted the same, but having the separate allows users to have
                            " separate highlighting for them if they desire.
   16              0.000086000 hi def link     goBoolean                  Boolean
                            
                            " Comments; their contents
   16              0.000057000 syn keyword     goTodo              contained TODO FIXME XXX BUG
   16              0.000082000 syn cluster     goCommentGroup      contains=goTodo
                            
   16              0.000177000 syn region      goComment           start="//" end="$" contains=goGenerate,@goCommentGroup,@Spell
   16   0.000280000   0.000270000 if go#config#FoldEnable('comment')
                              syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell fold
                              syn match     goComment           "\v(^\s*//.*\n)+" contains=goGenerate,@goCommentGroup,@Spell fold
   16              0.000010000 else
   16              0.000073000   syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell
   16              0.000011000 endif
                            
   16              0.000088000 hi def link     goComment           Comment
   16              0.000086000 hi def link     goTodo              Todo
                            
   16   0.000095000   0.000093000 if go#config#HighlightGenerateTags()
   16              0.000121000   syn match       goGenerateVariables contained /\%(\$GOARCH\|\$GOOS\|\$GOFILE\|\$GOLINE\|\$GOPACKAGE\|\$DOLLAR\)\>/
   16              0.000145000   syn region      goGenerate          start="^\s*//go:generate" end="$" contains=goGenerateVariables
   16              0.000090000   hi def link     goGenerate          PreProc
   16              0.000088000   hi def link     goGenerateVariables Special
   16              0.000010000 endif
                            
                            " Go escapes
   16              0.000080000 syn match       goEscapeOctal       display contained "\\[0-7]\{3}"
   16              0.000073000 syn match       goEscapeC           display contained +\\[abfnrtv\\'"]+
   16              0.000064000 syn match       goEscapeX           display contained "\\x\x\{2}"
   16              0.000067000 syn match       goEscapeU           display contained "\\u\x\{4}"
   16              0.000066000 syn match       goEscapeBigU        display contained "\\U\x\{8}"
   16              0.000082000 syn match       goEscapeError       display contained +\\[^0-7xuUabfnrtv\\'"]+
                            
   16              0.000071000 hi def link     goEscapeOctal       goSpecialString
   16              0.000064000 hi def link     goEscapeC           goSpecialString
   16              0.000098000 hi def link     goEscapeX           goSpecialString
   16              0.000060000 hi def link     goEscapeU           goSpecialString
   16              0.000060000 hi def link     goEscapeBigU        goSpecialString
   16              0.000085000 hi def link     goSpecialString     Special
   16              0.000083000 hi def link     goEscapeError       Error
                            
                            " Strings and their contents
   16              0.000345000 syn cluster     goStringGroup       contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU,goEscapeError
   16   0.000112000   0.000110000 if go#config#HighlightStringSpellcheck()
   16              0.000129000   syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup,@Spell
   16              0.000060000   syn region      goRawString         start=+`+ end=+`+ contains=@Spell
                            else
                              syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup
                              syn region      goRawString         start=+`+ end=+`+
   16              0.000013000 endif
                            
   16              0.000164000 syn match       goImportString      /^\%(\s\+\|import \)\(\h\w* \)\?\zs"[^"]\+"/ contained containedin=goImport
                            
   16   0.000083000   0.000081000 if go#config#HighlightFormatStrings()
                              " [n] notation is valid for specifying explicit argument indexes
                              " 1. Match a literal % not preceded by a %.
                              " 2. Match any number of -, #, 0, space, or +
                              " 3. Match * or [n]* or any number or nothing before a .
                              " 4. Match * or [n]* or any number or nothing after a .
                              " 5. Match [n] or nothing before a verb
                              " 6. Match a formatting verb
   16              0.000339000   syn match       goFormatSpecifier   /\
                                    \%([^%]\%(%%\)*\)\
                                    \@<=%[-#0 +]*\
                                    \%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\
                                    \%(\.\%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\)\=\
                                    \%(\[\d\+\]\)\=[vTtbcdoqxXUeEfFgGspw]/ contained containedin=goString,goRawString
   16              0.000075000   hi def link     goFormatSpecifier   goSpecialString
   16              0.000011000 endif
                            
   16              0.000086000 hi def link     goImportString      String
   16              0.000089000 hi def link     goString            String
   16              0.000084000 hi def link     goRawString         String
                            
                            " Characters; their contents
   16              0.000291000 syn cluster     goCharacterGroup    contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU
   16              0.000106000 syn region      goCharacter         start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@goCharacterGroup
                            
   16              0.000087000 hi def link     goCharacter         Character
                            
                            " Regions
   16              0.000061000 syn region      goParen             start='(' end=')' transparent
   16   0.000248000   0.000240000 if go#config#FoldEnable('block')
   16              0.000062000   syn region    goBlock             start="{" end="}" transparent fold
                            else
                              syn region    goBlock             start="{" end="}" transparent
   16              0.000010000 endif
                            
                            " import
   16   0.000186000   0.000180000 if go#config#FoldEnable('import')
   16              0.000248000   syn region    goImport            start='import (' end=')' transparent fold contains=goImport,goImportString,goComment
   16              0.000116000   syn match     goImport            /^import ()/ transparent fold contains=goImport
                            else
                              syn region    goImport            start='import (' end=')' transparent contains=goImport,goImportString,goComment
                              syn match     goImport            /^import ()/ transparent contains=goImport
   16              0.000009000 endif
                            
                            " var, const
   16   0.000181000   0.000175000 if go#config#FoldEnable('varconst')
   16              0.000638000   syn region    goVar               start='var ('   end='^\s*)$' transparent fold
                                                              \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
   16              0.000122000   syn match     goVar               /var ()/ transparent fold
                                                              \ contains=goVar
   16              0.000594000   syn region    goConst             start='const (' end='^\s*)$' transparent fold
                                                              \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
   16              0.000111000   syn match     goConst             /const ()/ transparent fold
                                                              \ contains=goConst
                            else
                              syn region    goVar               start='var ('   end='^\s*)$' transparent
                                                              \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn match     goVar               /var ()/ transparent
                                                              \ contains=goVar
                              syn region    goConst             start='const (' end='^\s*)$' transparent
                                                              \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn match     goConst             /const ()/ transparent
                                                              \ contains=goConst
   16              0.000008000 endif
                            
                            " Single-line var, const, and import.
   16              0.000240000 syn match       goSingleDecl        /\%(import\|var\|const\) [^(]\@=/ contains=goImport,goVar,goConst
                            
                            " Integers
   16              0.000076000 syn match       goDecimalInt        "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)\>"
   16              0.000078000 syn match       goHexadecimalInt    "\<-\=0[xX]_\?\%(\x\|\x_\x\)\+\>"
   16              0.000068000 syn match       goOctalInt          "\<-\=0[oO]\?_\?\%(\o\|\o_\o\)\+\>"
   16              0.000076000 syn match       goBinaryInt         "\<-\=0[bB]_\?\%([01]\|[01]_[01]\)\+\>"
                            
   16              0.000061000 hi def link     goDecimalInt        Integer
   16              0.000080000 hi def link     goDecimalError      Error
   16              0.000065000 hi def link     goHexadecimalInt    Integer
   16              0.000078000 hi def link     goHexadecimalError  Error
   16              0.000061000 hi def link     goOctalInt          Integer
   16              0.000077000 hi def link     goOctalError        Error
   16              0.000061000 hi def link     goBinaryInt         Integer
   16              0.000082000 hi def link     goBinaryError       Error
   16              0.000081000 hi def link     Integer             Number
                            
                            " Floating point
                            "float_lit         = decimal_float_lit | hex_float_lit .
                            "
                            "decimal_float_lit = decimal_digits "." [ decimal_digits ] [ decimal_exponent ] |
                            "                    decimal_digits decimal_exponent |
                            "                    "." decimal_digits [ decimal_exponent ] .
                            "decimal_exponent  = ( "e" | "E" ) [ "+" | "-" ] decimal_digits .
                            "
                            "hex_float_lit     = "0" ( "x" | "X" ) hex_mantissa hex_exponent .
                            "hex_mantissa      = [ "_" ] hex_digits "." [ hex_digits ] |
                            "                    [ "_" ] hex_digits |
                            "                    "." hex_digits .
                            "hex_exponent      = ( "p" | "P" ) [ "+" | "-" ] decimal_digits .
                            " decimal floats with a decimal point
   16              0.000126000 syn match       goFloat             "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)\.\%(\%(\%(\d\|\d_\d\)\+\)\=\%([Ee][-+]\=\%(\d\|\d_\d\)\+\)\=\>\)\="
   16              0.000090000 syn match       goFloat             "\s\zs-\=\.\%(\d\|\d_\d\)\+\%(\%([Ee][-+]\=\%(\d\|\d_\d\)\+\)\>\)\="
                            " decimal floats without a decimal point
   16              0.000082000 syn match       goFloat             "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)[Ee][-+]\=\%(\d\|\d_\d\)\+\>"
                            " hexadecimal floats with a decimal point
   16              0.000110000 syn match       goHexadecimalFloat  "\<-\=0[xX]\%(_\x\|\x\)\+\.\%(\%(\x\|\x_\x\)\+\)\=\%([Pp][-+]\=\%(\d\|\d_\d\)\+\)\=\>"
   16              0.000102000 syn match       goHexadecimalFloat  "\<-\=0[xX]\.\%(\x\|\x_\x\)\+\%([Pp][-+]\=\%(\d\|\d_\d\)\+\)\=\>"
                            " hexadecimal floats without a decimal point
   16              0.000078000 syn match       goHexadecimalFloat  "\<-\=0[xX]\%(_\x\|\x\)\+[Pp][-+]\=\%(\d\|\d_\d\)\+\>"
                            
   16              0.000082000 hi def link     goFloat             Float
   16              0.000082000 hi def link     goHexadecimalFloat  Float
                            
                            " Imaginary literals
   16              0.000069000 syn match       goImaginaryDecimal        "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)i\>"
   16              0.000069000 syn match       goImaginaryHexadecimal    "\<-\=0[xX]_\?\%(\x\|\x_\x\)\+i\>"
   16              0.000067000 syn match       goImaginaryOctal          "\<-\=0[oO]\?_\?\%(\o\|\o_\o\)\+i\>"
   16              0.000072000 syn match       goImaginaryBinary         "\<-\=0[bB]_\?\%([01]\|[01]_[01]\)\+i\>"
                            
                            " imaginary decimal floats with a decimal point
   16              0.000125000 syn match       goImaginaryFloat             "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)\.\%(\%(\%(\d\|\d_\d\)\+\)\=\%([Ee][-+]\=\%(\d\|\d_\d\)\+\)\=\)\=i\>"
   16              0.000096000 syn match       goImaginaryFloat             "\s\zs-\=\.\%(\d\|\d_\d\)\+\%([Ee][-+]\=\%(\d\|\d_\d\)\+\)\=i\>"
                            " imaginary decimal floats without a decimal point
   16              0.000077000 syn match       goImaginaryFloat             "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)[Ee][-+]\=\%(\d\|\d_\d\)\+i\>"
                            " imaginary hexadecimal floats with a decimal point
   16              0.000107000 syn match       goImaginaryHexadecimalFloat  "\<-\=0[xX]\%(_\x\|\x\)\+\.\%(\%(\x\|\x_\x\)\+\)\=\%([Pp][-+]\=\%(\d\|\d_\d\)\+\)\=i\>"
   16              0.000094000 syn match       goImaginaryHexadecimalFloat  "\<-\=0[xX]\.\%(\x\|\x_\x\)\+\%([Pp][-+]\=\%(\d\|\d_\d\)\+\)\=i\>"
                            " imaginary hexadecimal floats without a decimal point
   16              0.000078000 syn match       goImaginaryHexadecimalFloat  "\<-\=0[xX]\%(_\x\|\x\)\+[Pp][-+]\=\%(\d\|\d_\d\)\+i\>"
                            
   16              0.000083000 hi def link     goImaginaryDecimal             Number
   16              0.000083000 hi def link     goImaginaryHexadecimal         Number
   16              0.000085000 hi def link     goImaginaryOctal               Number
   16              0.000083000 hi def link     goImaginaryBinary              Number
   16              0.000082000 hi def link     goImaginaryFloat               Float
   16              0.000083000 hi def link     goImaginaryHexadecimalFloat    Float
                            
                            " Spaces after "[]"
   16   0.000126000   0.000123000 if go#config#HighlightArrayWhitespaceError()
                              syn match goSpaceError display "\%(\[\]\)\@<=\s\+"
   16              0.000008000 endif
                            
                            " Spacing errors around the 'chan' keyword
   16   0.000078000   0.000076000 if go#config#HighlightChanWhitespaceError()
                              " receive-only annotation on chan type
                              "
                              " \(\<chan\>\)\@<!<-  (only pick arrow when it doesn't come after a chan)
                              " this prevents picking up 'chan<- chan<-' but not '<- chan'
                              syn match goSpaceError display "\%(\%(\<chan\>\)\@<!<-\)\@<=\s\+\%(\<chan\>\)\@="
                            
                              " send-only annotation on chan type
                              "
                              " \(<-\)\@<!\<chan\>  (only pick chan when it doesn't come after an arrow)
                              " this prevents picking up '<-chan <-chan' but not 'chan <-'
                              syn match goSpaceError display "\%(\%(<-\)\@<!\<chan\>\)\@<=\s\+\%(<-\)\@="
                            
                              " value-ignoring receives in a few contexts
                              syn match goSpaceError display "\%(\%(^\|[={(,;]\)\s*<-\)\@<=\s\+"
   16              0.000010000 endif
                            
                            " Extra types commonly seen
   16   0.000078000   0.000076000 if go#config#HighlightExtraTypes()
   16              0.000063000   syn match goExtraType /\<bytes\.\%(Buffer\)\>/
   16              0.000060000   syn match goExtraType /\<context\.\%(Context\)\>/
   16              0.000124000   syn match goExtraType /\<io\.\%(Reader\|ReadSeeker\|ReadWriter\|ReadCloser\|ReadWriteCloser\|Writer\|WriteCloser\|Seeker\)\>/
   16              0.000063000   syn match goExtraType /\<reflect\.\%(Kind\|Type\|Value\)\>/
   16              0.000056000   syn match goExtraType /\<unsafe\.Pointer\>/
   16              0.000007000 endif
                            
                            " Space-tab error
   16   0.000081000   0.000079000 if go#config#HighlightSpaceTabError()
                              syn match goSpaceError display " \+\t"me=e-1
   16              0.000010000 endif
                            
                            " Trailing white space error
   16   0.000081000   0.000079000 if go#config#HighlightTrailingWhitespaceError()
                              syn match goSpaceError display excludenl "\s\+$"
   16              0.000010000 endif
                            
   16              0.000083000 hi def link     goExtraType         Type
   16              0.000081000 hi def link     goSpaceError        Error
                            
                            
                            
                            " included from: https://github.com/athom/more-colorful.vim/blob/master/after/syntax/go.vim
                            "
                            " Comments; their contents
   16              0.000049000 syn keyword     goTodo              contained NOTE
   16              0.000079000 hi def link     goTodo              Todo
                            
   16              0.000049000 syn match goVarArgs /\.\.\./
                            
                            " Operators;
   16   0.000074000   0.000073000 if go#config#HighlightOperators()
                              " match single-char operators:          - + % < > ! & | ^ * =
                              " and corresponding two-char operators: -= += %= <= >= != &= |= ^= *= ==
   16              0.000061000   syn match goOperator /[-+%<>!&|^*=]=\?/
                              " match / and /=
   16              0.000053000   syn match goOperator /\/\%(=\|\ze[^/*]\)/
                              " match two-char operators:               << >> &^
                              " and corresponding three-char operators: <<= >>= &^=
   16              0.000056000   syn match goOperator /\%(<<\|>>\|&^\)=\?/
                              " match remaining two-char operators: := && || <- ++ --
   16              0.000054000   syn match goOperator /:=\|||\|<-\|++\|--/
                              " match ~
   16              0.000058000   syn match goOperator /\~/
                              " match ...
                            
   16              0.000066000   hi def link     goPointerOperator   goOperator
   16              0.000060000   hi def link     goVarArgs           goOperator
   16              0.000009000 endif
   16              0.000080000 hi def link     goOperator          Operator
                            
                            "                               -> type constraint opening bracket
                            "                               |-> start non-counting group
                            "                               ||  -> any word character
                            "                               ||  |  -> at least one, as many as possible
                            "                               ||  |  |    -> start non-counting group
                            "                               ||  |  |    |   -> match ~
                            "                               ||  |  |    |   | -> at most once
                            "                               ||  |  |    |   | |     -> allow a slice type
                            "                               ||  |  |    |   | |     |      -> any word character
                            "                               ||  |  |    |   | |     |      | -> start a non-counting group
                            "                               ||  |  |    |   | |     |      | | -> that matches word characters and |
                            "                               ||  |  |    |   | |     |      | | |     -> close the non-counting group
                            "                               ||  |  |    |   | |     |      | | |     | -> close the non-counting group
                            "                               ||  |  |    |   | |     |      | | |     | |-> any number of matches
                            "                               ||  |  |    |   | |     |      | | |     | || -> start a non-counting group
                            "                               ||  |  |    |   | |     |      | | |     | || | -> a comma and whitespace
                            "                               ||  |  |    |   | |     |      | | |     | || | |      -> at most once
                            "                               ||  |  |    |   | |     |      | | |     | || | |      | -> close the non-counting group
                            "                               ||  |  |    |   | |     |      | | |     | || | |      | | -> at least one of those non-counting groups, as many as possible
                            "                               ||  |  |    |   | | --------   | | |     | || | |      | | | -> type constraint closing bracket
                            "                               ||  |  |    |   | ||        |  | | |     | || | |      | | | |
   16              0.000250000 syn match goTypeParams        /\[\%(\w\+\s\+\%(\~\?\%(\[]\)\?\w\%(\w\||\)\)*\%(,\s*\)\?\)\+\]/ nextgroup=goSimpleParams,goDeclType contained
                            
                            " Functions;
   16   0.000090000   0.000088000 if go#config#HighlightFunctions() || go#config#HighlightFunctionParameters()
   16              0.000223000   syn match goDeclaration       /\<func\>/ nextgroup=goReceiver,goFunction,goSimpleParams skipwhite skipnl
   16              0.000279000   syn match goReceiverDecl      /(\s*\zs\%(\%(\w\+\s\+\)\?\*\?\w\+\%(\[\%(\%(\[\]\)\?\w\+\%(,\s*\)\?\)\+\]\)\?\)\ze\s*)/ contained contains=goReceiverVar,goReceiverType,goPointerOperator
   16              0.000169000   syn match goReceiverVar       /\w\+\ze\s\+\%(\w\|\*\)/ nextgroup=goPointerOperator,goReceiverType skipwhite skipnl contained
   16              0.000100000   syn match goPointerOperator   /\*/ nextgroup=goReceiverType contained skipwhite skipnl
   16              0.000147000   syn match goFunction          /\w\+/ nextgroup=goSimpleParams,goTypeParams contained skipwhite skipnl
   16              0.000097000   syn match goReceiverType      /\w\+\%(\[\%(\%(\[\]\)\?\w\+\%(,\s*\)\?\)\+\]\)\?\ze\s*)/ contained
   16   0.000115000   0.000112000   if go#config#HighlightFunctionParameters()
                                syn match goSimpleParams      /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType nextgroup=goFunctionReturn skipwhite skipnl
                                syn match goFunctionReturn   /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType skipwhite skipnl
                                syn match goParamName        /\w\+\%(\s*,\s*\w\+\)*\ze\s\+\%(\w\|\.\|\*\|\[\)/ contained nextgroup=goParamType skipwhite skipnl
                                syn match goParamType        /\%([^,)]\|\_s\)\+,\?/ contained nextgroup=goParamName skipwhite skipnl
                                                      \ contains=goVarArgs,goType,goSignedInts,goUnsignedInts,goFloats,goComplexes,goDeclType,goBlock
                                hi def link   goReceiverVar    goParamName
                                hi def link   goParamName      Identifier
   16              0.000008000   endif
   16              0.000209000   syn match goReceiver          /(\s*\%(\w\+\s\+\)\?\*\?\s*\w\+\%(\[\%(\%(\[\]\)\?\w\+\%(,\s*\)\?\)\+\]\)\?\s*)\ze\s*\w/ contained nextgroup=goFunction contains=goReceiverDecl skipwhite skipnl
                            else
                              syn keyword goDeclaration func
   16              0.000011000 endif
   16              0.000077000 hi def link     goFunction          Function
                            
                            " Function calls;
   16   0.000076000   0.000074000 if go#config#HighlightFunctionCalls()
                              syn match goFunctionCall      /\w\+\ze\%(\[\%(\%(\[]\)\?\w\+\(,\s*\)\?\)\+\]\)\?(/ contains=goBuiltins,goDeclaration
   16              0.000008000 endif
   16              0.000080000 hi def link     goFunctionCall      Type
                            
                            " Fields;
   16   0.000072000   0.000070000 if go#config#HighlightFields()
                              " 1. Match a sequence of word characters coming after a '.'
                              " 2. Require the following but dont match it: ( \@= see :h E59)
                              "    - The symbols: / - + * %   OR
                              "    - The symbols: [] {} <> )  OR
                              "    - The symbols: \n \r space OR
                              "    - The symbols: , : .
                              " 3. Have the start of highlight (hs) be the start of matched
                              "    pattern (s) offsetted one to the right (+1) (see :h E401)
   16              0.000145000   syn match       goField   /\.\w\+\
                                    \%(\%([\/\-\+*%]\)\|\
                                    \%([\[\]{}<\>\)]\)\|\
                                    \%([\!=\^|&]\)\|\
                                    \%([\n\r\ ]\)\|\
                                    \%([,\:.]\)\)\@=/hs=s+1
   16              0.000013000 endif
   16              0.000084000 hi def link    goField              Identifier
                            
                            " Structs & Interfaces;
   16   0.000078000   0.000077000 if go#config#HighlightTypes()
   16              0.000053000   syn match goTypeConstructor      /\<\w\+{\@=/
   16              0.000098000   syn match goTypeDecl             /\<type\>/ nextgroup=goTypeName skipwhite skipnl
   16              0.000170000   syn match goTypeName             /\w\+/ contained nextgroup=goDeclType,goTypeParams skipwhite skipnl
   16              0.000076000   syn match goDeclType             /\<\%(interface\|struct\)\>/ skipwhite skipnl
   16              0.000083000   hi def link     goReceiverType      Type
                            else
                              syn keyword goDeclType           struct interface
                              syn keyword goDeclaration        type
   16              0.000006000 endif
   16              0.000093000 hi def link     goTypeConstructor   Type
   16              0.000084000 hi def link     goTypeName          Type
   16              0.000078000 hi def link     goTypeDecl          Keyword
   16              0.000099000 hi def link     goDeclType          Keyword
                            
                            " Variable Assignments
   16   0.000099000   0.000097000 if go#config#HighlightVariableAssignments()
                              syn match goVarAssign /\v[_.[:alnum:]]+(,\s*[_.[:alnum:]]+)*\ze(\s*([-^+|^\/%&]|\*|\<\<|\>\>|\&\^)?\=[^=])/
                              hi def link   goVarAssign         Special
   16              0.000012000 endif
                            
                            " Variable Declarations
   16   0.000070000   0.000068000 if go#config#HighlightVariableDeclarations()
                              syn match goVarDefs /\v\w+(,\s*\w+)*\ze(\s*:\=)/
                              hi def link   goVarDefs           Special
   16              0.000009000 endif
                            
                            " Build Constraints
   16   0.000071000   0.000069000 if go#config#HighlightBuildConstraints()
   16              0.000069000   syn match   goBuildKeyword      display contained "+build\|go:build"
                              " Highlight the known values of GOOS, GOARCH, and other +build options.
   16              0.000129000   syn keyword goBuildDirectives   contained
                                    \ android darwin dragonfly freebsd linux nacl netbsd openbsd plan9
                                    \ solaris windows 386 amd64 amd64p32 arm armbe arm64 arm64be ppc64
                                    \ ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc
                                    \ s390 s390x sparc sparc64 cgo ignore race
                            
                              " Other words in the build directive are build tags not listed above, so
                              " avoid highlighting them as comments by using a matchgroup just for the
                              " start of the comment.
                              " The rs=s+2 option lets the \s*+build portion be part of the inner region
                              " instead of the matchgroup so it will be highlighted as a goBuildKeyword.
   16              0.000219000   syn region  goBuildComment      matchgroup=goBuildCommentStart
                                    \ start="//\(\s*+build\s\|go:build\)"rs=s+2 end="$"
                                    \ contains=goBuildKeyword,goBuildDirectives
   16              0.000085000   hi def link goBuildCommentStart Comment
   16              0.000082000   hi def link goBuildDirectives   Type
   16              0.000089000   hi def link goBuildKeyword      PreProc
   16              0.000007000 endif
                            
   16   0.000078000   0.000077000 if go#config#HighlightBuildConstraints() || go#config#FoldEnable('package_comment')
                              " One or more line comments that are followed immediately by a "package"
                              " declaration are treated like package documentation, so these must be
                              " matched as comments to avoid looking like working build constraints.
                              " The he, me, and re options let the "package" itself be highlighted by
                              " the usual rules.
   16   0.000370000   0.000363000   exe 'syn region  goPackageComment    start=/\v(\/\/.*\n)+\s*package\s/'
                                    \ . ' end=/\v\n\s*package\s/he=e-8,me=e-8,re=e-8'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (go#config#FoldEnable('package_comment') ? ' fold' : '')
   16   0.000352000   0.000345000   exe 'syn region  goPackageComment    start=/\v^\s*\/\*.*\n(.*\n)*\s*\*\/\npackage\s/'
                                    \ . ' end=/\v\*\/\n\s*package\s/he=e-8,me=e-8,re=e-8'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (go#config#FoldEnable('package_comment') ? ' fold' : '')
   16              0.000090000   hi def link goPackageComment    Comment
   16              0.000009000 endif
                            
                            " :GoCoverage commands
   16              0.000086000 hi def link goCoverageNormalText Comment
                            
   16              0.000035000 function! s:hi()
                              hi def link goSameId Search
                              hi def link goDiagnosticError SpellBad
                              hi def link goDiagnosticWarning SpellRare
                            
                              " TODO(bc): is it appropriate to define text properties in a syntax file?
                              " The highlight groups need to be defined before the text properties types
                              " are added, and when users have syntax enabled in their vimrc after
                              " filetype plugin on, the highlight groups won't be defined when
                              " ftplugin/go.vim is executed when the first go file is opened.
                              " See https://github.com/fatih/vim-go/issues/2658.
                              if has('textprop')
                                if empty(prop_type_get('goSameId'))
                                  call prop_type_add('goSameId', {'highlight': 'goSameId'})
                                endif
                                if empty(prop_type_get('goDiagnosticError'))
                                  call prop_type_add('goDiagnosticError', {'highlight': 'goDiagnosticError'})
                                endif
                                if empty(prop_type_get('goDiagnosticWarning'))
                                  call prop_type_add('goDiagnosticWarning', {'highlight': 'goDiagnosticWarning'})
                                endif
                              endif
                            
                              hi def link goDeclsFzfKeyword        Keyword
                              hi def link goDeclsFzfFunction       Function
                              hi def link goDeclsFzfSpecialComment SpecialComment
                              hi def link goDeclsFzfComment        Comment
                            
                              " :GoCoverage commands
                              hi def      goCoverageCovered    ctermfg=green guifg=#A6E22E
                              hi def      goCoverageUncover    ctermfg=red guifg=#F92672
                            
                              " :GoDebug commands
                              if go#config#HighlightDebug()
                                hi def GoDebugBreakpoint term=standout ctermbg=117 ctermfg=0 guibg=#BAD4F5  guifg=Black
                                hi def GoDebugCurrent term=reverse  ctermbg=12  ctermfg=7 guibg=DarkBlue guifg=White
                              endif
                            endfunction
                            
   16              0.000023000 augroup vim-go-hi
   16              0.000514000   autocmd!
   16              0.000072000   autocmd ColorScheme * call s:hi()
   16              0.000011000 augroup end
   16   0.001245000   0.001189000 call s:hi()
                            
                            " Search backwards for a global declaration to start processing the syntax.
                            "syn sync match goSync grouphere NONE /^\(const\|var\|type\|func\)\>/
                            
                            " There's a bug in the implementation of grouphere. For now, use the
                            " following as a more expensive/less precise workaround.
   16              0.000021000 syn sync minlines=500
                            
   16              0.000030000 let b:current_syntax = "go"
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/go.vim
Sourced 16 times
Total time:   0.000177000
 Self time:   0.000177000

count     total (s)      self (s)
                            " Copyright 2009 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " go.vim: Vim syntax file for Go.
                            " Language:             Go
                            " Maintainer:           Billie Cleek <bhcleek@gmail.com>
                            " Latest Revision:      2024-04-13
                            "  2024-03-17:          - fix goPackageComment highlight (by Vim Project)
                            " License:              BSD-style. See LICENSE file in source repository.
                            " Repository:           https://github.com/fatih/vim-go
                            
                            " Quit when a (custom) syntax file was already loaded
   16              0.000057000 if exists("b:current_syntax")
   16              0.000011000   finish
                            endif
                            
                            let s:keepcpo = &cpo
                            set cpo&vim
                            
                            function! s:FoldEnable(...) abort
                              if a:0 > 0
                                return index(s:FoldEnable(), a:1) > -1
                              endif
                              return get(g:, 'go_fold_enable', ['block', 'import', 'varconst', 'package_comment'])
                            endfunction
                            
                            function! s:HighlightArrayWhitespaceError() abort
                              return get(g:, 'go_highlight_array_whitespace_error', 0)
                            endfunction
                            
                            function! s:HighlightChanWhitespaceError() abort
                              return get(g:, 'go_highlight_chan_whitespace_error', 0)
                            endfunction
                            
                            function! s:HighlightExtraTypes() abort
                              return get(g:, 'go_highlight_extra_types', 0)
                            endfunction
                            
                            function! s:HighlightSpaceTabError() abort
                              return get(g:, 'go_highlight_space_tab_error', 0)
                            endfunction
                            
                            function! s:HighlightTrailingWhitespaceError() abort
                              return get(g:, 'go_highlight_trailing_whitespace_error', 0)
                            endfunction
                            
                            function! s:HighlightOperators() abort
                              return get(g:, 'go_highlight_operators', 0)
                            endfunction
                            
                            function! s:HighlightFunctions() abort
                              return get(g:, 'go_highlight_functions', 0)
                            endfunction
                            
                            function! s:HighlightFunctionParameters() abort
                              return get(g:, 'go_highlight_function_parameters', 0)
                            endfunction
                            
                            function! s:HighlightFunctionCalls() abort
                              return get(g:, 'go_highlight_function_calls', 0)
                            endfunction
                            
                            function! s:HighlightFields() abort
                              return get(g:, 'go_highlight_fields', 0)
                            endfunction
                            
                            function! s:HighlightTypes() abort
                              return get(g:, 'go_highlight_types', 0)
                            endfunction
                            
                            function! s:HighlightBuildConstraints() abort
                              return get(g:, 'go_highlight_build_constraints', 0)
                            endfunction
                            
                            function! s:HighlightStringSpellcheck() abort
                              return get(g:, 'go_highlight_string_spellcheck', 1)
                            endfunction
                            
                            function! s:HighlightFormatStrings() abort
                              return get(g:, 'go_highlight_format_strings', 1)
                            endfunction
                            
                            function! s:HighlightGenerateTags() abort
                              return get(g:, 'go_highlight_generate_tags', 0)
                            endfunction
                            
                            function! s:HighlightVariableAssignments() abort
                              return get(g:, 'go_highlight_variable_assignments', 0)
                            endfunction
                            
                            function! s:HighlightVariableDeclarations() abort
                              return get(g:, 'go_highlight_variable_declarations', 0)
                            endfunction
                            
                            syn case match
                            
                            syn keyword     goPackage           package
                            syn keyword     goImport            import    contained
                            syn keyword     goVar               var       contained
                            syn keyword     goConst             const     contained
                            
                            hi def link     goPackage           Statement
                            hi def link     goImport            Statement
                            hi def link     goVar               Keyword
                            hi def link     goConst             Keyword
                            hi def link     goDeclaration       Keyword
                            
                            " Keywords within functions
                            syn keyword     goStatement         defer go goto return break continue fallthrough
                            syn keyword     goConditional       if else switch select
                            syn keyword     goLabel             case default
                            syn keyword     goRepeat            for range
                            
                            hi def link     goStatement         Statement
                            hi def link     goConditional       Conditional
                            hi def link     goLabel             Label
                            hi def link     goRepeat            Repeat
                            
                            " Predefined types
                            syn keyword     goType              chan map bool string error any comparable
                            syn keyword     goSignedInts        int int8 int16 int32 int64 rune
                            syn keyword     goUnsignedInts      byte uint uint8 uint16 uint32 uint64 uintptr
                            syn keyword     goFloats            float32 float64
                            syn keyword     goComplexes         complex64 complex128
                            
                            hi def link     goType              Type
                            hi def link     goSignedInts        Type
                            hi def link     goUnsignedInts      Type
                            hi def link     goFloats            Type
                            hi def link     goComplexes         Type
                            
                            " Predefined functions and values
                            syn keyword     goBuiltins                 append cap clear close complex copy delete imag len
                            syn keyword     goBuiltins                 make max min new panic print println real recover
                            syn keyword     goBoolean                  true false
                            syn keyword     goPredefinedIdentifiers    nil iota
                            
                            hi def link     goBuiltins                 Identifier
                            hi def link     goPredefinedIdentifiers    Constant
                            " Boolean links to Constant by default by vim: goBoolean and goPredefinedIdentifiers
                            " will be highlighted the same, but having the separate groups allows users to
                            " have separate highlighting for them if they desire.
                            hi def link     goBoolean                  Boolean
                            
                            " Comments; their contents
                            syn keyword     goTodo              contained TODO FIXME XXX BUG
                            syn cluster     goCommentGroup      contains=goTodo
                            
                            syn region      goComment           start="//" end="$" contains=goGenerate,@goCommentGroup,@Spell
                            if s:FoldEnable('comment')
                              syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell fold
                              syn match     goComment           "\v(^\s*//.*\n)+" contains=goGenerate,@goCommentGroup,@Spell fold
                            else
                              syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell
                            endif
                            
                            hi def link     goComment           Comment
                            hi def link     goTodo              Todo
                            
                            if s:HighlightGenerateTags()
                              syn match       goGenerateVariables contained /\%(\$GOARCH\|\$GOOS\|\$GOFILE\|\$GOLINE\|\$GOPACKAGE\|\$DOLLAR\)\>/
                              syn region      goGenerate          start="^\s*//go:generate" end="$" contains=goGenerateVariables
                              hi def link     goGenerate          PreProc
                              hi def link     goGenerateVariables Special
                            endif
                            
                            " Go escapes
                            syn match       goEscapeOctal       display contained "\\[0-7]\{3}"
                            syn match       goEscapeC           display contained +\\[abfnrtv\\'"]+
                            syn match       goEscapeX           display contained "\\x\x\{2}"
                            syn match       goEscapeU           display contained "\\u\x\{4}"
                            syn match       goEscapeBigU        display contained "\\U\x\{8}"
                            syn match       goEscapeError       display contained +\\[^0-7xuUabfnrtv\\'"]+
                            
                            hi def link     goEscapeOctal       goSpecialString
                            hi def link     goEscapeC           goSpecialString
                            hi def link     goEscapeX           goSpecialString
                            hi def link     goEscapeU           goSpecialString
                            hi def link     goEscapeBigU        goSpecialString
                            hi def link     goSpecialString     Special
                            hi def link     goEscapeError       Error
                            
                            " Strings and their contents
                            syn cluster     goStringGroup       contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU,goEscapeError
                            if s:HighlightStringSpellcheck()
                              syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup,@Spell
                              syn region      goRawString         start=+`+ end=+`+ contains=@Spell
                            else
                              syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup
                              syn region      goRawString         start=+`+ end=+`+
                            endif
                            
                            syn match       goImportString      /^\%(\s\+\|import \)\(\h\w* \)\?\zs"[^"]\+"/ contained containedin=goImport
                            
                            if s:HighlightFormatStrings()
                              " [n] notation is valid for specifying explicit argument indexes
                              " 1. Match a literal % not preceded by a %.
                              " 2. Match any number of -, #, 0, space, or +
                              " 3. Match * or [n]* or any number or nothing before a .
                              " 4. Match * or [n]* or any number or nothing after a .
                              " 5. Match [n] or nothing before a verb
                              " 6. Match a formatting verb
                              syn match       goFormatSpecifier   /\
                                    \%([^%]\%(%%\)*\)\
                                    \@<=%[-#0 +]*\
                                    \%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\
                                    \%(\.\%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\)\=\
                                    \%(\[\d\+\]\)\=[vTtbcdoqxXUeEfFgGspw]/ contained containedin=goString,goRawString
                              hi def link     goFormatSpecifier   goSpecialString
                            endif
                            
                            hi def link     goImportString      String
                            hi def link     goString            String
                            hi def link     goRawString         String
                            
                            " Characters; their contents
                            syn cluster     goCharacterGroup    contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU
                            syn region      goCharacter         start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@goCharacterGroup
                            
                            hi def link     goCharacter         Character
                            
                            " Regions
                            syn region      goParen             start='(' end=')' transparent
                            if s:FoldEnable('block')
                              syn region    goBlock             start="{" end="}" transparent fold
                            else
                              syn region    goBlock             start="{" end="}" transparent
                            endif
                            
                            " import
                            if s:FoldEnable('import')
                              syn region    goImport            start='import (' end=')' transparent fold contains=goImport,goImportString,goComment
                              syn match     goImport            /^import ()/ transparent fold contains=goImport
                            else
                              syn region    goImport            start='import (' end=')' transparent contains=goImport,goImportString,goComment
                              syn match     goImport            /^import ()/ transparent contains=goImport
                            endif
                            
                            " var, const
                            if s:FoldEnable('varconst')
                              syn region    goVar               start='var ('   end='^\s*)$' transparent fold
                                                              \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn match     goVar               /var ()/ transparent fold
                                                              \ contains=goVar
                              syn region    goConst             start='const (' end='^\s*)$' transparent fold
                                                              \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn match     goConst             /const ()/ transparent fold
                                                              \ contains=goConst
                            else
                              syn region    goVar               start='var ('   end='^\s*)$' transparent
                                                              \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn match     goVar               /var ()/ transparent
                                                              \ contains=goVar
                              syn region    goConst             start='const (' end='^\s*)$' transparent
                                                              \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn match     goConst             /const ()/ transparent
                                                              \ contains=goConst
                            endif
                            
                            " Single-line var, const, and import.
                            syn match       goSingleDecl        /\%(import\|var\|const\) [^(]\@=/ contains=goImport,goVar,goConst
                            
                            " Integers
                            syn match       goDecimalInt        "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)\>"
                            syn match       goHexadecimalInt    "\<-\=0[xX]_\?\%(\x\|\x_\x\)\+\>"
                            syn match       goOctalInt          "\<-\=0[oO]\?_\?\%(\o\|\o_\o\)\+\>"
                            syn match       goBinaryInt         "\<-\=0[bB]_\?\%([01]\|[01]_[01]\)\+\>"
                            
                            hi def link     goDecimalInt        Integer
                            hi def link     goDecimalError      Error
                            hi def link     goHexadecimalInt    Integer
                            hi def link     goHexadecimalError  Error
                            hi def link     goOctalInt          Integer
                            hi def link     goOctalError        Error
                            hi def link     goBinaryInt         Integer
                            hi def link     goBinaryError       Error
                            hi def link     Integer             Number
                            
                            " Floating point
                            "float_lit         = decimal_float_lit | hex_float_lit .
                            "
                            "decimal_float_lit = decimal_digits "." [ decimal_digits ] [ decimal_exponent ] |
                            "                    decimal_digits decimal_exponent |
                            "                    "." decimal_digits [ decimal_exponent ] .
                            "decimal_exponent  = ( "e" | "E" ) [ "+" | "-" ] decimal_digits .
                            "
                            "hex_float_lit     = "0" ( "x" | "X" ) hex_mantissa hex_exponent .
                            "hex_mantissa      = [ "_" ] hex_digits "." [ hex_digits ] |
                            "                    [ "_" ] hex_digits |
                            "                    "." hex_digits .
                            "hex_exponent      = ( "p" | "P" ) [ "+" | "-" ] decimal_digits .
                            " decimal floats with a decimal point
                            syn match       goFloat             "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)\.\%(\%(\%(\d\|\d_\d\)\+\)\=\%([Ee][-+]\=\%(\d\|\d_\d\)\+\)\=\>\)\="
                            syn match       goFloat             "\s\zs-\=\.\%(\d\|\d_\d\)\+\%(\%([Ee][-+]\=\%(\d\|\d_\d\)\+\)\>\)\="
                            " decimal floats without a decimal point
                            syn match       goFloat             "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)[Ee][-+]\=\%(\d\|\d_\d\)\+\>"
                            " hexadecimal floats with a decimal point
                            syn match       goHexadecimalFloat  "\<-\=0[xX]\%(_\x\|\x\)\+\.\%(\%(\x\|\x_\x\)\+\)\=\%([Pp][-+]\=\%(\d\|\d_\d\)\+\)\=\>"
                            syn match       goHexadecimalFloat  "\<-\=0[xX]\.\%(\x\|\x_\x\)\+\%([Pp][-+]\=\%(\d\|\d_\d\)\+\)\=\>"
                            " hexadecimal floats without a decimal point
                            syn match       goHexadecimalFloat  "\<-\=0[xX]\%(_\x\|\x\)\+[Pp][-+]\=\%(\d\|\d_\d\)\+\>"
                            
                            hi def link     goFloat             Float
                            hi def link     goHexadecimalFloat  Float
                            
                            " Imaginary literals
                            syn match       goImaginaryDecimal        "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)i\>"
                            syn match       goImaginaryHexadecimal    "\<-\=0[xX]_\?\%(\x\|\x_\x\)\+i\>"
                            syn match       goImaginaryOctal          "\<-\=0[oO]\?_\?\%(\o\|\o_\o\)\+i\>"
                            syn match       goImaginaryBinary         "\<-\=0[bB]_\?\%([01]\|[01]_[01]\)\+i\>"
                            
                            " imaginary decimal floats with a decimal point
                            syn match       goImaginaryFloat             "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)\.\%(\%(\%(\d\|\d_\d\)\+\)\=\%([Ee][-+]\=\%(\d\|\d_\d\)\+\)\=\)\=i\>"
                            syn match       goImaginaryFloat             "\s\zs-\=\.\%(\d\|\d_\d\)\+\%([Ee][-+]\=\%(\d\|\d_\d\)\+\)\=i\>"
                            " imaginary decimal floats without a decimal point
                            syn match       goImaginaryFloat             "\<-\=\%(0\|\%(\d\|\d_\d\)\+\)[Ee][-+]\=\%(\d\|\d_\d\)\+i\>"
                            " imaginary hexadecimal floats with a decimal point
                            syn match       goImaginaryHexadecimalFloat  "\<-\=0[xX]\%(_\x\|\x\)\+\.\%(\%(\x\|\x_\x\)\+\)\=\%([Pp][-+]\=\%(\d\|\d_\d\)\+\)\=i\>"
                            syn match       goImaginaryHexadecimalFloat  "\<-\=0[xX]\.\%(\x\|\x_\x\)\+\%([Pp][-+]\=\%(\d\|\d_\d\)\+\)\=i\>"
                            " imaginary hexadecimal floats without a decimal point
                            syn match       goImaginaryHexadecimalFloat  "\<-\=0[xX]\%(_\x\|\x\)\+[Pp][-+]\=\%(\d\|\d_\d\)\+i\>"
                            
                            hi def link     goImaginaryDecimal             Number
                            hi def link     goImaginaryHexadecimal         Number
                            hi def link     goImaginaryOctal               Number
                            hi def link     goImaginaryBinary              Number
                            hi def link     goImaginaryFloat               Float
                            hi def link     goImaginaryHexadecimalFloat    Float
                            
                            " Spaces after "[]"
                            if s:HighlightArrayWhitespaceError()
                              syn match goSpaceError display "\%(\[\]\)\@<=\s\+"
                            endif
                            
                            " Spacing errors around the 'chan' keyword
                            if s:HighlightChanWhitespaceError()
                              " receive-only annotation on chan type
                              "
                              " \(\<chan\>\)\@<!<-  (only pick arrow when it doesn't come after a chan)
                              " this prevents picking up 'chan<- chan<-' but not '<- chan'
                              syn match goSpaceError display "\%(\%(\<chan\>\)\@<!<-\)\@<=\s\+\%(\<chan\>\)\@="
                            
                              " send-only annotation on chan type
                              "
                              " \(<-\)\@<!\<chan\>  (only pick chan when it doesn't come after an arrow)
                              " this prevents picking up '<-chan <-chan' but not 'chan <-'
                              syn match goSpaceError display "\%(\%(<-\)\@<!\<chan\>\)\@<=\s\+\%(<-\)\@="
                            
                              " value-ignoring receives in a few contexts
                              syn match goSpaceError display "\%(\%(^\|[={(,;]\)\s*<-\)\@<=\s\+"
                            endif
                            
                            " Extra types commonly seen
                            if s:HighlightExtraTypes()
                              syn match goExtraType /\<bytes\.\%(Buffer\)\>/
                              syn match goExtraType /\<context\.\%(Context\)\>/
                              syn match goExtraType /\<io\.\%(Reader\|ReadSeeker\|ReadWriter\|ReadCloser\|ReadWriteCloser\|Writer\|WriteCloser\|Seeker\)\>/
                              syn match goExtraType /\<reflect\.\%(Kind\|Type\|Value\)\>/
                              syn match goExtraType /\<unsafe\.Pointer\>/
                            endif
                            
                            " Space-tab error
                            if s:HighlightSpaceTabError()
                              syn match goSpaceError display " \+\t"me=e-1
                            endif
                            
                            " Trailing white space error
                            if s:HighlightTrailingWhitespaceError()
                              syn match goSpaceError display excludenl "\s\+$"
                            endif
                            
                            hi def link     goExtraType         Type
                            hi def link     goSpaceError        Error
                            
                            
                            
                            " included from: https://github.com/athom/more-colorful.vim/blob/master/after/syntax/go.vim
                            "
                            " Comments; their contents
                            syn keyword     goTodo              contained NOTE
                            hi def link     goTodo              Todo
                            
                            syn match goVarArgs /\.\.\./
                            
                            " Operators;
                            if s:HighlightOperators()
                              " match single-char operators:          - + % < > ! & | ^ * =
                              " and corresponding two-char operators: -= += %= <= >= != &= |= ^= *= ==
                              syn match goOperator /[-+%<>!&|^*=]=\?/
                              " match / and /=
                              syn match goOperator /\/\%(=\|\ze[^/*]\)/
                              " match two-char operators:               << >> &^
                              " and corresponding three-char operators: <<= >>= &^=
                              syn match goOperator /\%(<<\|>>\|&^\)=\?/
                              " match remaining two-char operators: := && || <- ++ --
                              syn match goOperator /:=\|||\|<-\|++\|--/
                              " match ~
                              syn match goOperator /\~/
                              " match ...
                            
                              hi def link     goPointerOperator   goOperator
                              hi def link     goVarArgs           goOperator
                            endif
                            hi def link     goOperator          Operator
                            
                            "                               -> type constraint opening bracket
                            "                               |-> start non-counting group
                            "                               ||  -> any word character
                            "                               ||  |  -> at least one, as many as possible
                            "                               ||  |  |    -> start non-counting group
                            "                               ||  |  |    |   -> match ~
                            "                               ||  |  |    |   | -> at most once
                            "                               ||  |  |    |   | |     -> allow a slice type
                            "                               ||  |  |    |   | |     |      -> any word character
                            "                               ||  |  |    |   | |     |      | -> start a non-counting group
                            "                               ||  |  |    |   | |     |      | | -> that matches word characters and |
                            "                               ||  |  |    |   | |     |      | | |     -> close the non-counting group
                            "                               ||  |  |    |   | |     |      | | |     | -> close the non-counting group
                            "                               ||  |  |    |   | |     |      | | |     | |-> any number of matches
                            "                               ||  |  |    |   | |     |      | | |     | || -> start a non-counting group
                            "                               ||  |  |    |   | |     |      | | |     | || | -> a comma and whitespace
                            "                               ||  |  |    |   | |     |      | | |     | || | |      -> at most once
                            "                               ||  |  |    |   | |     |      | | |     | || | |      | -> close the non-counting group
                            "                               ||  |  |    |   | |     |      | | |     | || | |      | | -> at least one of those non-counting groups, as many as possible
                            "                               ||  |  |    |   | | --------   | | |     | || | |      | | | -> type constraint closing bracket
                            "                               ||  |  |    |   | ||        |  | | |     | || | |      | | | |
                            syn match goTypeParams        /\[\%(\w\+\s\+\%(\~\?\%(\[]\)\?\w\%(\w\||\)\)*\%(,\s*\)\?\)\+\]/ nextgroup=goSimpleParams,goDeclType contained
                            
                            " Functions;
                            if s:HighlightFunctions() || s:HighlightFunctionParameters()
                              syn match goDeclaration       /\<func\>/ nextgroup=goReceiver,goFunction,goSimpleParams skipwhite skipnl
                              syn match goReceiverDecl      /(\s*\zs\%(\%(\w\+\s\+\)\?\*\?\w\+\%(\[\%(\%(\[\]\)\?\w\+\%(,\s*\)\?\)\+\]\)\?\)\ze\s*)/ contained contains=goReceiverVar,goReceiverType,goPointerOperator
                              syn match goReceiverVar       /\w\+\ze\s\+\%(\w\|\*\)/ nextgroup=goPointerOperator,goReceiverType skipwhite skipnl contained
                              syn match goPointerOperator   /\*/ nextgroup=goReceiverType contained skipwhite skipnl
                              syn match goFunction          /\w\+/ nextgroup=goSimpleParams,goTypeParams contained skipwhite skipnl
                              syn match goReceiverType      /\w\+\%(\[\%(\%(\[\]\)\?\w\+\%(,\s*\)\?\)\+\]\)\?\ze\s*)/ contained
                              if s:HighlightFunctionParameters()
                                syn match goSimpleParams      /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType nextgroup=goFunctionReturn skipwhite skipnl
                                syn match goFunctionReturn   /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType skipwhite skipnl
                                syn match goParamName        /\w\+\%(\s*,\s*\w\+\)*\ze\s\+\%(\w\|\.\|\*\|\[\)/ contained nextgroup=goParamType skipwhite skipnl
                                syn match goParamType        /\%([^,)]\|\_s\)\+,\?/ contained nextgroup=goParamName skipwhite skipnl
                                                      \ contains=goVarArgs,goType,goSignedInts,goUnsignedInts,goFloats,goComplexes,goDeclType,goBlock
                                hi def link   goReceiverVar    goParamName
                                hi def link   goParamName      Identifier
                              endif
                              syn match goReceiver          /(\s*\%(\w\+\s\+\)\?\*\?\s*\w\+\%(\[\%(\%(\[\]\)\?\w\+\%(,\s*\)\?\)\+\]\)\?\s*)\ze\s*\w/ contained nextgroup=goFunction contains=goReceiverDecl skipwhite skipnl
                            else
                              syn keyword goDeclaration func
                            endif
                            hi def link     goFunction          Function
                            
                            " Function calls;
                            if s:HighlightFunctionCalls()
                              syn match goFunctionCall      /\w\+\ze\%(\[\%(\%(\[]\)\?\w\+\(,\s*\)\?\)\+\]\)\?(/ contains=goBuiltins,goDeclaration
                            endif
                            hi def link     goFunctionCall      Type
                            
                            " Fields;
                            if s:HighlightFields()
                              " 1. Match a sequence of word characters coming after a '.'
                              " 2. Require the following but dont match it: ( \@= see :h E59)
                              "    - The symbols: / - + * %   OR
                              "    - The symbols: [] {} <> )  OR
                              "    - The symbols: \n \r space OR
                              "    - The symbols: , : .
                              " 3. Have the start of highlight (hs) be the start of matched
                              "    pattern (s) offsetted one to the right (+1) (see :h E401)
                              syn match       goField   /\.\w\+\
                                    \%(\%([\/\-\+*%]\)\|\
                                    \%([\[\]{}<\>\)]\)\|\
                                    \%([\!=\^|&]\)\|\
                                    \%([\n\r\ ]\)\|\
                                    \%([,\:.]\)\)\@=/hs=s+1
                            endif
                            hi def link    goField              Identifier
                            
                            " Structs & Interfaces;
                            if s:HighlightTypes()
                              syn match goTypeConstructor      /\<\w\+{\@=/
                              syn match goTypeDecl             /\<type\>/ nextgroup=goTypeName skipwhite skipnl
                              syn match goTypeName             /\w\+/ contained nextgroup=goDeclType,goTypeParams skipwhite skipnl
                              syn match goDeclType             /\<\%(interface\|struct\)\>/ skipwhite skipnl
                              hi def link     goReceiverType      Type
                            else
                              syn keyword goDeclType           struct interface
                              syn keyword goDeclaration        type
                            endif
                            hi def link     goTypeConstructor   Type
                            hi def link     goTypeName          Type
                            hi def link     goTypeDecl          Keyword
                            hi def link     goDeclType          Keyword
                            
                            " Variable Assignments
                            if s:HighlightVariableAssignments()
                              syn match goVarAssign /\v[_.[:alnum:]]+(,\s*[_.[:alnum:]]+)*\ze(\s*([-^+|^\/%&]|\*|\<\<|\>\>|\&\^)?\=[^=])/
                              hi def link   goVarAssign         Special
                            endif
                            
                            " Variable Declarations
                            if s:HighlightVariableDeclarations()
                              syn match goVarDefs /\v\w+(,\s*\w+)*\ze(\s*:\=)/
                              hi def link   goVarDefs           Special
                            endif
                            
                            " Build Constraints
                            if s:HighlightBuildConstraints()
                              syn match   goBuildKeyword      display contained "+build\|go:build"
                              " Highlight the known values of GOOS, GOARCH, and other +build options.
                              syn keyword goBuildDirectives   contained
                                    \ android darwin dragonfly freebsd linux nacl netbsd openbsd plan9
                                    \ solaris windows 386 amd64 amd64p32 arm armbe arm64 arm64be ppc64
                                    \ ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc
                                    \ s390 s390x sparc sparc64 cgo ignore race
                            
                              " Other words in the build directive are build tags not listed above, so
                              " avoid highlighting them as comments by using a matchgroup just for the
                              " start of the comment.
                              " The rs=s+2 option lets the \s*+build portion be part of the inner region
                              " instead of the matchgroup so it will be highlighted as a goBuildKeyword.
                              syn region  goBuildComment      matchgroup=goBuildCommentStart
                                    \ start="//\(\s*+build\s\|go:build\)"rs=s+2 end="$"
                                    \ contains=goBuildKeyword,goBuildDirectives
                              hi def link goBuildCommentStart Comment
                              hi def link goBuildDirectives   Type
                              hi def link goBuildKeyword      PreProc
                            endif
                            
                            if s:HighlightBuildConstraints() || s:FoldEnable('package_comment')
                              " One or more line comments that are followed immediately by a "package"
                              " declaration are treated like package documentation, so these must be
                              " matched as comments to avoid looking like working build constraints.
                              " The he, me, and re options let the "package" itself be highlighted by
                              " the usual rules.
                              exe 'syn region  goPackageComment    start=/\v(\/\/.*\n)+\s*package\s/'
                                    \ . ' end=/\v\n\s*package\s/he=e-8,me=e-8,re=e-8'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (s:FoldEnable('package_comment') ? ' fold' : '')
                              exe 'syn region  goPackageComment    start=/\v^\s*\/\*.*\n(.*\n)*\s*\*\/\npackage\s/'
                                    \ . ' end=/\v\*\/\n\s*package\s/he=e-8,me=e-8,re=e-8'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (s:FoldEnable('package_comment') ? ' fold' : '')
                              hi def link goPackageComment    Comment
                            endif
                            
                            " :GoCoverage commands
                            hi def link goCoverageNormalText Comment
                            
                            " Search backwards for a global declaration to start processing the syntax.
                            "syn sync match goSync grouphere NONE /^\(const\|var\|type\|func\)\>/
                            
                            " There's a bug in the implementation of grouphere. For now, use the
                            " following as a more expensive/less precise workaround.
                            syn sync minlines=500
                            
                            let b:current_syntax = "go"
                            
                            let &cpo = s:keepcpo
                            unlet s:keepcpo
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/ftplugin/vim.vim
Sourced 5 times
Total time:   0.001632000
 Self time:   0.001632000

count     total (s)      self (s)
                            " Vim filetype plugin
                            " Language:		Vim
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Last Change:		2024 Apr 13
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Only do this when not done yet for this buffer
    5              0.000030000 if exists("b:did_ftplugin")
                              finish
    5              0.000004000 endif
                            
                            " Don't load another plugin for this buffer
    5              0.000010000 let b:did_ftplugin = 1
                            
    5              0.000014000 let s:cpo_save = &cpo
    5              0.000026000 set cpo&vim
                            
    5              0.000015000 if !exists('*VimFtpluginUndo')
                              func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< include< define<
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! vunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! vunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! vunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! vunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! vunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! vunmap <buffer> ["
                                endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
    5              0.000006000 endif
                            
    5              0.000010000 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    5              0.000026000 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    5              0.000179000 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    5              0.000013000 setlocal keywordprg=:help
                            
                            " Comments starts with # in Vim9 script.  We have to guess which one to use.
    5              0.000067000 if "\n" .. getline(1, 32)->join("\n") =~# '\n\s*vim9\%[script]\>'
                              setlocal commentstring=#%s
    5              0.000004000 else
    5              0.000012000   setlocal commentstring=\"%s
    5              0.000002000 endif
                            
                            " Set 'comments' to format dashed lists in comments, both in Vim9 and legacy
                            " script.
    5              0.000026000 setlocal com=sO:#\ -,mO:#\ \ ,eO:##,:#\\\ ,:#,sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"\\\ ,:\"
                            
                            " set 'include' to recognize import commands
    5              0.000010000 setlocal include=\\v^\\s*import\\s*(autoload)?
                            
                            " set 'define' to recognize export commands
    5              0.000012000 setlocal define=\\v^\\s*export\\s*(def\|const\|var\|final)
                            
                            " Format comments to be up to 78 characters long
    5              0.000012000 if &tw == 0
    5              0.000021000   setlocal tw=78
    5              0.000005000 endif
                            
    5              0.000018000 if !exists("no_plugin_maps") && !exists("no_vim_maps")
    5              0.000009000   let b:did_add_maps = 1
                            
                              " Move around functions.
    5              0.000076000   nnoremap <silent><buffer> [[ m':call search('^\s*\(fu\%[nction]\\|\(export\s\+\)\?def\)\>', "bW")<CR>
    5              0.000078000   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|\(export\s\+\)\?def\)\>', "bW")<CR>
    5              0.000058000   nnoremap <silent><buffer> ]] m':call search('^\s*\(fu\%[nction]\\|\(export\s\+\)\?def\)\>', "W")<CR>
    5              0.000071000   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|\(export\s\+\)\?def\)\>', "W")<CR>
    5              0.000060000   nnoremap <silent><buffer> [] m':call search('^\s*end\(f\%[unction]\\|\(export\s\+\)\?def\)\>', "bW")<CR>
    5              0.000071000   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|\(export\s\+\)\?def\)\>', "bW")<CR>
    5              0.000058000   nnoremap <silent><buffer> ][ m':call search('^\s*end\(f\%[unction]\\|\(export\s\+\)\?def\)\>', "W")<CR>
    5              0.000069000   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|\(export\s\+\)\?def\)\>', "W")<CR>
                            
                              " Move around comments
    5              0.000047000   nnoremap <silent><buffer> ]" :call search('\%(^\s*".*\n\)\@<!\%(^\s*"\)', "W")<CR>
    5              0.000057000   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\@<!\%(^\s*"\)', "W")<CR>
    5              0.000046000   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    5              0.000056000   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    5              0.000003000 endif
                            
                            " Let the matchit plugin know what items can be matched.
    5              0.000011000 if exists("loaded_matchit")
                              let b:match_ignorecase = 0
                              " "func" can also be used as a type:
                              "   var Ref: func
                              " or to list functions:
                              "   func name
                              " require a parenthesis following, then there can be an "endfunc".
                              let b:match_words =
                            	\ '\<\%(fu\%[nction]\|def\)!\=\s\+\S\+\s*(:\%(\%(^\||\)\s*\)\@<=\<retu\%[rn]\>:\%(\%(^\||\)\s*\)\@<=\<\%(endf\%[unction]\|enddef\)\>,' ..
                            	\ '\<\%(wh\%[ile]\|for\)\>:\%(\%(^\||\)\s*\)\@<=\<brea\%[k]\>:\%(\%(^\||\)\s*\)\@<=\<con\%[tinue]\>:\%(\%(^\||\)\s*\)\@<=\<end\%(w\%[hile]\|fo\%[r]\)\>,' ..
                            	\ '\<if\>:\%(\%(^\||\)\s*\)\@<=\<el\%[seif]\>:\%(\%(^\||\)\s*\)\@<=\<en\%[dif]\>,' ..
                            	\ '{:},' ..
                            	\ '\<try\>:\%(\%(^\||\)\s*\)\@<=\<cat\%[ch]\>:\%(\%(^\||\)\s*\)\@<=\<fina\%[lly]\>:\%(\%(^\||\)\s*\)\@<=\<endt\%[ry]\>,' ..
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' ..
                            	\ '\<class\>:\<endclass\>,' ..
                            	\ '\<inte\%[rface]\>:\<endinterface\>,' ..
                            	\ '\<enu\%[m]\>:\<endenum\>,'
                            
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
                              " Also ignore here-doc and dictionary keys (vimVar).
                              let b:match_skip = 'synIDattr(synID(line("."), col("."), 1), "name")
                            	\ =~? "comment\\|string\\|vimSynReg\\|vimSet\\|vimLetHereDoc\\|vimVar"'
    5              0.000005000 endif
                            
    5              0.000021000 let &cpo = s:cpo_save
    5              0.000008000 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/indent/vim.vim
Sourced 5 times
Total time:   0.000753000
 Self time:   0.000753000

count     total (s)      self (s)
    5              0.000438000 vim9script
                            
                            # Vim indent file
                            # Language:	Vim script
                            # Maintainer:	The Vim Project <https://github.com/vim/vim>
                            # Last Change:	2023 Aug 10
                            # Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            # Only load this indent file when no other was loaded.
    5              0.000021000 if exists('b:did_indent')
                                finish
    5              0.000005000 endif
                            
    5              0.000020000 b:did_indent = true
    5              0.000005000 b:undo_indent = 'setlocal indentkeys< indentexpr<'
                            
    5              0.000007000 import autoload '../autoload/dist/vimindent.vim'
                            
    5              0.000022000 setlocal indentexpr=vimindent.Expr()
    5              0.000029000 setlocal indentkeys+==endif,=enddef,=endfu,=endfor,=endwh,=endtry,=endclass,=endinterface,=endenum,=},=else,=cat,=finall,=END,0\\
    5              0.000044000 execute('setlocal indentkeys+=0=\"\\\ ,0=#\\\ ')
    5              0.000011000 setlocal indentkeys-=0#
    5              0.000017000 setlocal indentkeys-=:

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/vim.vim
Sourced 5 times
Total time:   0.118554000
 Self time:   0.118554000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:	   Vim script
                            " Maintainer:	   Hirohito Higashi <h.east.727 ATMARK gmail.com>
                            "	   Doug Kearns <dougkearns@gmail.com>
                            " URL:	   https://github.com/vim-jp/syntax-vim-ex
                            " Last Change:	   2024 Apr 13
                            " Former Maintainer: Charles E. Campbell
                            
                            " DO NOT CHANGE DIRECTLY.
                            " THIS FILE PARTLY GENERATED BY gen_syntax_vim.vim.
                            " (Search string "GEN_SYN_VIM:" in this file)
                            
                            " Automatically generated keyword lists: {{{1
                            
                            " Quit when a syntax file was already loaded {{{2
    5              0.000037000 if exists("b:current_syntax")
                              finish
    5              0.000005000 endif
    5              0.000024000 let s:keepcpo= &cpo
    5              0.000017000 set cpo&vim
                            
    5              0.000066000 let s:vim9script = "\n" .. getline(1, 32)->join("\n") =~# '\n\s*vim9\%[script]\>'
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    5              0.000050000 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    5              0.000045000 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " regular vim commands {{{2
                            " GEN_SYN_VIM: vimCommand normal, START_STR='syn keyword vimCommand contained', END_STR=''
    5              0.000329000 syn keyword vimCommand contained abo[veleft] abs[tract] al[l] ar[gs] arga[dd] argd[elete] argdo argded[upe] arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] b[uffer] bN[ext] ba[ll] bad[d] balt bd[elete] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] buffers bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] cabo[ve] cad[dbuffer] cadde[xpr] caddf[ile] caf[ter] cal[l] cat[ch] cb[uffer] cbe[fore] cbel[ow] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfir[st] cg[etfile] cgetb[uffer] cgete[xpr] chd[ir] changes che[ckpath] checkt[ime] chi[story] cl[ist] cla[st] class clo[se] cle[arjumps] cn[ext] cnew[er] cnf[ile] co[py] col[der] colo[rscheme] com[mand] comc[lear]
    5              0.000246000 syn keyword vimCommand contained comp[iler] con[tinue] conf[irm] cons[t] cope[n] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] defc[ompile] defe[r] delc[ommand] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] disa[ssemble] dj[ump] dli[st] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] el[se] elsei[f] em[enu] en[dif] endin[terface] endc[lass] ende[num] endfo[r] endt[ry] endw[hile] ene[w] enu[m] ev[al] ex exi[t] exp[ort] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[l] finall[y] fini[sh] fir[st] fix[del] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpf[ind]
    5              0.000339000 syn keyword vimCommand contained helpg[rep] helpt[ags] ha[rdcopy] hi[ghlight] hid[e] his[tory] ho[rizontal] if ij[ump] il[ist] imp[ort] int[ro] inte[rface] is[earch] isp[lit] j[oin] ju[mps] k kee[pmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lab[ove] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] laf[ter] lat[er] lb[uffer] lbe[fore] lbel[ow] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] leg[acy] lf[ile] lfd[o] lfir[st] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lmak[e] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow]
    5              0.000213000 syn keyword vimCommand contained ls m[ove] ma[rk] mak[e] marks mat[ch] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mod[e] mz[scheme] mzf[ile] n[ext] nb[key] nbc[lose] nbs[tart] noa[utocmd] noh[lsearch] nos[wapfile] nu[mber] o[pen] ol[dfiles] on[ly] opt[ions] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] ped[it] po[p] pp[op] pre[serve] prev[ious] pro[mptfind] promptr[epl] prof[ile] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pub[lic] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] python3 py3f[ile] pyx pyxd[o] pythonx pyxf[ile] q[uit] quita[ll] qa[ll] r[ead] rec[over] red[o] redi[r] redr[aw] redraws[tatus] redrawt[abline] reg[isters] res[ize]
    5              0.000216000 syn keyword vimCommand contained ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] ru[ntime] rub[y] rubyd[o] rubyf[ile] rund[o] rv[iminfo] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scriptv[ersion] scs[cope] setf[iletype] sf[ind] sfir[st] sh[ell] si[malt] sig[n] sil[ent] sl[eep] sla[st] sn[ext] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellra[re] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] stat[ic] stopi[nsert] stj[ump] sts[elect] sun[hide] sus[pend] sv[iew] sw[apname] synti[me] sync[bind] smi[le] t tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit]
    5              0.000183000 syn keyword vimCommand contained tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[d] tch[dir] tcl tcld[o] tclf[ile] te[aroff] ter[minal] tf[irst] th[row] thi[s] tj[ump] tl[ast] tn[ext] to[pleft] tp[revious] tr[ewind] try ts[elect] ty[pe] u[ndo] undoj[oin] undol[ist] unh[ide] unl[et] unlo[ckvar] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] vim9[cmd] viu[sage] vne[w] vs[plit] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] wu[ndo] wv[iminfo] x[it] xa[ll] xr[estore] y[ank] z dl dell delel deletl deletel dp dep delp delep deletp deletep a i
                            
    5              0.000026000 syn keyword vimCommand contained	2mat[ch] 3mat[ch]
                            
                            " Lower priority for _new_ to distinguish constructors from the command.
    5              0.000033000 syn match   vimCommand contained	"\<new\>(\@!"
    5              0.000033000 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    5              0.000052000 syn keyword vimStdPlugin contained	Arguments Asm Break Cfilter Clear Continue DiffOrig Evaluate Finish Gdb Lfilter Man Over Program Run S Source Step Stop Termdebug TermdebugCommand TOhtml Until Winbar XMLent XMLns
                            
                            " vimOptions are caught only when contained in a vimSet {{{2
                            " GEN_SYN_VIM: vimOption normal, START_STR='syn keyword vimOption contained', END_STR=''
    5              0.000152000 syn keyword vimOption contained al aleph ari allowrevins ambw ambiwidth arab arabic arshape arabicshape acd autochdir ai autoindent ar autoread asd autoshelldir aw autowrite awa autowriteall bg background bs backspace bk backup bkc backupcopy bdir backupdir bex backupext bsk backupskip bdlay balloondelay beval ballooneval bevalterm balloonevalterm bexpr balloonexpr bo belloff bin binary bomb brk breakat bri breakindent briopt breakindentopt bsdir browsedir bh bufhidden bl buflisted bt buftype cmp casemap cdh cdhome cd cdpath cedit ccv charconvert cin cindent cink cinkeys cino cinoptions cinsd cinscopedecls cinw cinwords cb clipboard ch cmdheight cwh cmdwinheight cc colorcolumn co columns com comments cms commentstring cp compatible cpt complete cfu completefunc
    5              0.000153000 syn keyword vimOption contained cot completeopt cpp completepopup csl completeslash cocu concealcursor cole conceallevel cf confirm ci copyindent cpo cpoptions cm cryptmethod cspc cscopepathcomp csprg cscopeprg csqf cscopequickfix csre cscoperelative cst cscopetag csto cscopetagorder csverb cscopeverbose crb cursorbind cuc cursorcolumn cul cursorline culopt cursorlineopt debug def define deco delcombine dict dictionary diff dex diffexpr dip diffopt dg digraph dir directory dy display ead eadirection ed edcompatible emo emoji enc encoding eof endoffile eol endofline ea equalalways ep equalprg eb errorbells ef errorfile efm errorformat ek esckeys ei eventignore et expandtab ex exrc fenc fileencoding fencs fileencodings ff fileformat ffs fileformats fic fileignorecase
    5              0.000127000 syn keyword vimOption contained ft filetype fcs fillchars fixeol fixendofline fcl foldclose fdc foldcolumn fen foldenable fde foldexpr fdi foldignore fdl foldlevel fdls foldlevelstart fmr foldmarker fdm foldmethod fml foldminlines fdn foldnestmax fdo foldopen fdt foldtext fex formatexpr flp formatlistpat fo formatoptions fp formatprg fs fsync gd gdefault gfm grepformat gp grepprg gcr guicursor gfn guifont gfs guifontset gfw guifontwide ghr guiheadroom gli guiligatures go guioptions guipty gtl guitablabel gtt guitabtooltip hf helpfile hh helpheight hlg helplang hid hidden hl highlight hi history hk hkmap hkp hkmapp hls hlsearch icon iconstring ic ignorecase imaf imactivatefunc imak imactivatekey imc imcmdline imd imdisable imi iminsert ims imsearch imsf imstatusfunc
    5              0.000127000 syn keyword vimOption contained imst imstyle inc include inex includeexpr is incsearch inde indentexpr indk indentkeys inf infercase im insertmode isf isfname isi isident isk iskeyword isp isprint js joinspaces jop jumpoptions key kmp keymap km keymodel kpc keyprotocol kp keywordprg lmap langmap lm langmenu lnr langnoremap lrm langremap ls laststatus lz lazyredraw lbr linebreak lines lsp linespace lisp lop lispoptions lw lispwords list lcs listchars lpl loadplugins luadll magic mef makeef menc makeencoding mp makeprg mps matchpairs mat matchtime mco maxcombine mfd maxfuncdepth mmd maxmapdepth mm maxmem mmp maxmempattern mmt maxmemtot mis menuitems msm mkspellmem ml modeline mle modelineexpr mls modelines ma modifiable mod modified more mouse mousef mousefocus
    5              0.000107000 syn keyword vimOption contained mh mousehide mousem mousemodel mousemev mousemoveevent mouses mouseshape mouset mousetime mzq mzquantum mzschemedll mzschemegcdll nf nrformats nu number nuw numberwidth ofu omnifunc odev opendevice opfunc operatorfunc pp packpath para paragraphs paste pt pastetoggle pex patchexpr pm patchmode pa path perldll pi preserveindent pvh previewheight pvp previewpopup pvw previewwindow pdev printdevice penc printencoding pexpr printexpr pfn printfont pheader printheader pmbcs printmbcharset pmbfn printmbfont popt printoptions prompt ph pumheight pw pumwidth pythondll pythonhome pythonthreedll pythonthreehome pyx pyxversion qftf quickfixtextfunc qe quoteescape ro readonly rdt redrawtime re regexpengine rnu relativenumber remap rop renderoptions
    5              0.000124000 syn keyword vimOption contained report rs restorescreen ri revins rl rightleft rlc rightleftcmd rubydll ru ruler ruf rulerformat rtp runtimepath scr scroll scb scrollbind scf scrollfocus sj scrolljump so scrolloff sbo scrollopt sect sections secure sel selection slm selectmode ssop sessionoptions sh shell shcf shellcmdflag sp shellpipe shq shellquote srr shellredir ssl shellslash stmp shelltemp st shelltype sxe shellxescape sxq shellxquote sr shiftround sw shiftwidth shm shortmess sn shortname sbr showbreak sc showcmd sloc showcmdloc sft showfulltag sm showmatch smd showmode stal showtabline ss sidescroll siso sidescrolloff scl signcolumn scs smartcase si smartindent sta smarttab sms smoothscroll sts softtabstop spell spc spellcapcheck spf spellfile spl spelllang
    5              0.000131000 syn keyword vimOption contained spo spelloptions sps spellsuggest sb splitbelow spk splitkeep spr splitright sol startofline stl statusline su suffixes sua suffixesadd swf swapfile sws swapsync swb switchbuf smc synmaxcol syn syntax tal tabline tpm tabpagemax ts tabstop tbs tagbsearch tc tagcase tfu tagfunc tl taglength tr tagrelative tag tags tgst tagstack tcldll term tbidi termbidi tenc termencoding tgc termguicolors twk termwinkey twsl termwinscroll tws termwinsize twt termwintype terse ta textauto tx textmode tw textwidth tsr thesaurus tsrfu thesaurusfunc top tildeop to timeout tm timeoutlen title titlelen titleold titlestring tb toolbar tbis toolbariconsize ttimeout ttm ttimeoutlen tbi ttybuiltin tf ttyfast ttym ttymouse tsl ttyscroll tty ttytype udir undodir
    5              0.000084000 syn keyword vimOption contained udf undofile ul undolevels ur undoreload uc updatecount ut updatetime vsts varsofttabstop vts vartabstop vbs verbose vfile verbosefile vdir viewdir vop viewoptions vi viminfo vif viminfofile ve virtualedit vb visualbell warn wiv weirdinvert ww whichwrap wc wildchar wcm wildcharm wig wildignore wic wildignorecase wmnu wildmenu wim wildmode wop wildoptions wak winaltkeys wcr wincolor wi window wfb winfixbuf wfh winfixheight wfw winfixwidth wh winheight wmh winminheight wmw winminwidth winptydll wiw winwidth wrap wm wrapmargin ws wrapscan write wa writeany wb writebackup wd writedelay xtermcodes
                            
                            " vimOptions: These are the turn-off setting variants {{{2
                            " GEN_SYN_VIM: vimOption turn-off, START_STR='syn keyword vimOption contained', END_STR=''
    5              0.000322000 syn keyword vimOption contained noari noallowrevins noarab noarabic noarshape noarabicshape noacd noautochdir noai noautoindent noar noautoread noasd noautoshelldir noaw noautowrite noawa noautowriteall nobk nobackup nobeval noballooneval nobevalterm noballoonevalterm nobin nobinary nobomb nobri nobreakindent nobl nobuflisted nocdh nocdhome nocin nocindent nocp nocompatible nocf noconfirm noci nocopyindent nocsre nocscoperelative nocst nocscopetag nocsverb nocscopeverbose nocrb nocursorbind nocuc nocursorcolumn nocul nocursorline nodeco nodelcombine nodiff nodg nodigraph noed noedcompatible noemo noemoji noeof noendoffile noeol noendofline noea noequalalways noeb noerrorbells noek noesckeys noet noexpandtab noex noexrc nofic nofileignorecase nofixeol nofixendofline
    5              0.000105000 syn keyword vimOption contained nofen nofoldenable nofs nofsync nogd nogdefault noguipty nohid nohidden nohk nohkmap nohkp nohkmapp nohls nohlsearch noicon noic noignorecase noimc noimcmdline noimd noimdisable nois noincsearch noinf noinfercase noim noinsertmode nojs nojoinspaces nolnr nolangnoremap nolrm nolangremap nolz nolazyredraw nolbr nolinebreak nolisp nolist nolpl noloadplugins nomagic noml nomodeline nomle nomodelineexpr noma nomodifiable nomod nomodified nomore nomousef nomousefocus nomh nomousehide nomousemev nomousemoveevent nonu nonumber noodev noopendevice nopaste nopi nopreserveindent nopvw nopreviewwindow noprompt noro noreadonly nornu norelativenumber noremap nors norestorescreen nori norevins norl norightleft noru noruler noscb noscrollbind noscf noscrollfocus
    5              0.000101000 syn keyword vimOption contained nosecure nossl noshellslash nostmp noshelltemp nosr noshiftround nosn noshortname nosc noshowcmd nosft noshowfulltag nosm noshowmatch nosmd noshowmode noscs nosmartcase nosi nosmartindent nosta nosmarttab nosms nosmoothscroll nospell nosb nosplitbelow nospr nosplitright nosol nostartofline noswf noswapfile notbs notagbsearch notr notagrelative notgst notagstack notbidi notermbidi notgc notermguicolors noterse nota notextauto notx notextmode notop notildeop noto notimeout notitle nottimeout notbi nottybuiltin notf nottyfast noudf noundofile novb novisualbell nowarn nowiv noweirdinvert nowic nowildignorecase nowmnu nowildmenu nowfb nowinfixbuf nowfh nowinfixheight nowfw nowinfixwidth nowrap nows nowrapscan nowrite nowa nowriteany
    5              0.000018000 syn keyword vimOption contained nowb nowritebackup noxtermcodes
                            
                            " vimOptions: These are the invertible variants {{{2
                            " GEN_SYN_VIM: vimOption invertible, START_STR='syn keyword vimOption contained', END_STR=''
    5              0.000107000 syn keyword vimOption contained invari invallowrevins invarab invarabic invarshape invarabicshape invacd invautochdir invai invautoindent invar invautoread invasd invautoshelldir invaw invautowrite invawa invautowriteall invbk invbackup invbeval invballooneval invbevalterm invballoonevalterm invbin invbinary invbomb invbri invbreakindent invbl invbuflisted invcdh invcdhome invcin invcindent invcp invcompatible invcf invconfirm invci invcopyindent invcsre invcscoperelative invcst invcscopetag invcsverb invcscopeverbose invcrb invcursorbind invcuc invcursorcolumn invcul invcursorline invdeco invdelcombine invdiff invdg invdigraph inved invedcompatible invemo invemoji inveof invendoffile inveol invendofline invea invequalalways inveb inverrorbells invek invesckeys
    5              0.000083000 syn keyword vimOption contained invet invexpandtab invex invexrc invfic invfileignorecase invfixeol invfixendofline invfen invfoldenable invfs invfsync invgd invgdefault invguipty invhid invhidden invhk invhkmap invhkp invhkmapp invhls invhlsearch invicon invic invignorecase invimc invimcmdline invimd invimdisable invis invincsearch invinf invinfercase invim invinsertmode invjs invjoinspaces invlnr invlangnoremap invlrm invlangremap invlz invlazyredraw invlbr invlinebreak invlisp invlist invlpl invloadplugins invmagic invml invmodeline invmle invmodelineexpr invma invmodifiable invmod invmodified invmore invmousef invmousefocus invmh invmousehide invmousemev invmousemoveevent invnu invnumber invodev invopendevice invpaste invpi invpreserveindent invpvw invpreviewwindow
    5              0.000090000 syn keyword vimOption contained invprompt invro invreadonly invrnu invrelativenumber invremap invrs invrestorescreen invri invrevins invrl invrightleft invru invruler invscb invscrollbind invscf invscrollfocus invsecure invssl invshellslash invstmp invshelltemp invsr invshiftround invsn invshortname invsc invshowcmd invsft invshowfulltag invsm invshowmatch invsmd invshowmode invscs invsmartcase invsi invsmartindent invsta invsmarttab invsms invsmoothscroll invspell invsb invsplitbelow invspr invsplitright invsol invstartofline invswf invswapfile invtbs invtagbsearch invtr invtagrelative invtgst invtagstack invtbidi invtermbidi invtgc invtermguicolors invterse invta invtextauto invtx invtextmode invtop invtildeop invto invtimeout invtitle invttimeout invtbi invttybuiltin
    5              0.000040000 syn keyword vimOption contained invtf invttyfast invudf invundofile invvb invvisualbell invwarn invwiv invweirdinvert invwic invwildignorecase invwmnu invwildmenu invwfb invwinfixbuf invwfh invwinfixheight invwfw invwinfixwidth invwrap invws invwrapscan invwrite invwa invwriteany invwb invwritebackup invxtermcodes
                            
                            " termcap codes (which can also be set) {{{2
                            " GEN_SYN_VIM: vimOption term output code, START_STR='syn keyword vimOption contained', END_STR=''
    5              0.000076000 syn keyword vimOption contained t_AB t_AF t_AU t_AL t_al t_bc t_BE t_BD t_cd t_ce t_Ce t_CF t_cl t_cm t_Co t_CS t_Cs t_cs t_CV t_da t_db t_DL t_dl t_ds t_Ds t_EC t_EI t_fs t_fd t_fe t_GP t_IE t_IS t_ke t_ks t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RF t_RB t_RC t_RI t_Ri t_RK t_RS t_RT t_RV t_Sb t_SC t_se t_Sf t_SH t_SI t_Si t_so t_SR t_sr t_ST t_Te t_te t_TE t_ti t_TI t_Ts t_ts t_u7 t_ue t_us t_Us t_ut t_vb t_ve t_vi t_VS t_vs t_WP t_WS t_XM t_xn t_xs t_ZH t_ZR t_8f t_8b t_8u
                            " term key codes
    5              0.000048000 syn keyword vimOption contained	t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ku
    5              0.000022000 syn match   vimOption contained	"t_%1"
    5              0.000020000 syn match   vimOption contained	"t_#2"
    5              0.000020000 syn match   vimOption contained	"t_#4"
    5              0.000018000 syn match   vimOption contained	"t_@7"
    5              0.000018000 syn match   vimOption contained	"t_*7"
    5              0.000020000 syn match   vimOption contained	"t_&8"
    5              0.000018000 syn match   vimOption contained	"t_%i"
    5              0.000019000 syn match   vimOption contained	"t_k;"
                            
                            " unsupported settings: some were supported by vi but don't do anything in vim {{{2
                            " GEN_SYN_VIM: Missing vimOption, START_STR='syn keyword vimErrSetting contained', END_STR=''
    5              0.000053000 syn keyword vimErrSetting contained akm altkeymap anti antialias ap autoprint bf beautify biosk bioskey consk conskey fk fkmap fl flash gr graphic ht hardtabs macatsui mesg novice open opt optimize oft osfiletype redraw slow slowopen sourceany w1200 w300 w9600
    5              0.000041000 syn keyword vimErrSetting contained noakm noaltkeymap noanti noantialias noap noautoprint nobf nobeautify nobiosk nobioskey noconsk noconskey nofk nofkmap nofl noflash nogr nographic nomacatsui nomesg nonovice noopen noopt nooptimize noredraw noslow noslowopen nosourceany
    5              0.000039000 syn keyword vimErrSetting contained invakm invaltkeymap invanti invantialias invap invautoprint invbf invbeautify invbiosk invbioskey invconsk invconskey invfk invfkmap invfl invflash invgr invgraphic invmacatsui invmesg invnovice invopen invopt invoptimize invredraw invslow invslowopen invsourceany
                            
                            " AutoCmd Events {{{2
    5              0.000005000 syn case ignore
                            " GEN_SYN_VIM: vimAutoEvent, START_STR='syn keyword vimAutoEvent contained', END_STR=''
    5              0.000148000 syn keyword vimAutoEvent contained BufAdd BufCreate BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufRead BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWrite BufWriteCmd BufWritePost BufWritePre CmdlineChanged CmdlineEnter CmdlineLeave CmdUndefined CmdwinEnter CmdwinLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CompleteDonePre CursorHold CursorHoldI CursorMoved CursorMovedI DiffUpdated DirChanged DirChangedPre EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileEncoding FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre
    5              0.000128000 syn keyword vimAutoEvent contained FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave InsertLeavePre MenuPopup ModeChanged OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SafeState SafeStateAgain SessionLoadPost SessionWritePost ShellCmdPost ShellFilterPost SigUSR1 SourceCmd SourcePost SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabClosed TabEnter TabLeave TabNew TermChanged TerminalOpen TerminalWinOpen TermResponse TermResponseAll TextChanged TextChangedI TextChangedP TextChangedT TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinClosed WinEnter WinLeave WinNew WinNewPre WinResized WinScrolled
                            
                            " Highlight commonly used Groupnames {{{2
    5              0.000076000 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo
                            
                            " Default highlighting groups {{{2
                            " GEN_SYN_VIM: vimHLGroup, START_STR='syn keyword vimHLGroup contained', END_STR=''
    5              0.000144000 syn keyword vimHLGroup contained ErrorMsg IncSearch ModeMsg NonText StatusLine StatusLineNC EndOfBuffer VertSplit VisualNOS DiffText PmenuSbar TabLineSel TabLineFill Cursor lCursor QuickFixLine CursorLineSign CursorLineFold CurSearch PmenuKind PmenuKindSel PmenuExtra PmenuExtraSel Normal Directory LineNr CursorLineNr MoreMsg Question Search SpellBad SpellCap SpellRare SpellLocal PmenuThumb Pmenu PmenuSel SpecialKey Title WarningMsg WildMenu Folded FoldColumn SignColumn Visual DiffAdd DiffChange DiffDelete TabLine CursorColumn CursorLine ColorColumn Conceal MatchParen StatusLineTerm StatusLineTermNC ToolbarLine ToolbarButton Menu Tooltip Scrollbar CursorIM LineNrAbove LineNrBelow
    5              0.000004000 syn case match
                            
                            " Function Names {{{2
                            " GEN_SYN_VIM: vimFuncName, START_STR='syn keyword vimFuncName contained', END_STR=''
    5              0.000088000 syn keyword vimFuncName contained abs acos add and append appendbufline argc argidx arglistid argv asin assert_beeps assert_equal assert_equalfile assert_exception assert_fails assert_false assert_inrange assert_match assert_nobeep assert_notequal assert_notmatch assert_report assert_true atan atan2 autocmd_add autocmd_delete autocmd_get balloon_gettext balloon_show balloon_split blob2list browse browsedir bufadd bufexists buflisted bufload bufloaded bufname bufnr bufwinid bufwinnr byte2line byteidx byteidxcomp call ceil ch_canread ch_close ch_close_in ch_evalexpr ch_evalraw ch_getbufnr ch_getjob ch_info ch_log ch_logfile ch_open ch_read ch_readblob ch_readraw ch_sendexpr ch_sendraw ch_setoptions ch_status changenr char2nr charclass charcol charidx chdir cindent
    5              0.000128000 syn keyword vimFuncName contained clearmatches col complete complete_add complete_check complete_info confirm copy cos cosh count cscope_connection cursor debugbreak deepcopy delete deletebufline did_filetype diff diff_filler diff_hlID digraph_get digraph_getlist digraph_set digraph_setlist echoraw empty environ err_teapot escape eval eventhandler executable execute exepath exists exists_compiled exp expand expandcmd extend extendnew feedkeys filereadable filewritable filter finddir findfile flatten flattennew float2nr floor fmod fnameescape fnamemodify foldclosed foldclosedend foldlevel foldtext foldtextresult foreach foreground fullcommand funcref function garbagecollect get getbufinfo getbufline getbufoneline getbufvar getcellwidths getchangelist getchar getcharmod
    5              0.000094000 syn keyword vimFuncName contained getcharpos getcharsearch getcharstr getcmdcompltype getcmdline getcmdpos getcmdscreenpos getcmdtype getcmdwintype getcompletion getcurpos getcursorcharpos getcwd getenv getfontname getfperm getfsize getftime getftype getimstatus getjumplist getline getloclist getmarklist getmatches getmousepos getmouseshape getpid getpos getqflist getreg getreginfo getregion getregtype getscriptinfo gettabinfo gettabvar gettabwinvar gettagstack gettext getwininfo getwinpos getwinposx getwinposy getwinvar glob glob2regpat globpath has has_key haslocaldir hasmapto histadd histdel histget histnr hlID hlexists hlget hlset hostname iconv indent index indexof input inputdialog inputlist inputrestore inputsave inputsecret insert instanceof interrupt
    5              0.000088000 syn keyword vimFuncName contained invert isabsolutepath isdirectory isinf islocked isnan items job_getchannel job_info job_setoptions job_start job_status job_stop join js_decode js_encode json_decode json_encode keys keytrans len libcall libcallnr line line2byte lispindent list2blob list2str listener_add listener_flush listener_remove localtime log log10 luaeval map maparg mapcheck maplist mapnew mapset match matchadd matchaddpos matcharg matchbufline matchdelete matchend matchfuzzy matchfuzzypos matchlist matchstr matchstrlist matchstrpos max menu_info min mkdir mode mzeval nextnonblank nr2char or pathshorten perleval popup_atcursor popup_beval popup_clear popup_close popup_create popup_dialog popup_filter_menu popup_filter_yesno popup_findecho popup_findinfo
    5              0.000090000 syn keyword vimFuncName contained popup_findpreview popup_getoptions popup_getpos popup_hide popup_list popup_locate popup_menu popup_move popup_notification popup_setoptions popup_settext popup_show pow prevnonblank printf prompt_getprompt prompt_setcallback prompt_setinterrupt prompt_setprompt prop_add prop_add_list prop_clear prop_find prop_list prop_remove prop_type_add prop_type_change prop_type_delete prop_type_get prop_type_list pum_getpos pumvisible py3eval pyeval pyxeval rand range readblob readdir readdirex readfile reduce reg_executing reg_recording reltime reltimefloat reltimestr remote_expr remote_foreground remote_peek remote_read remote_send remote_startserver remove rename repeat resolve reverse round rubyeval screenattr screenchar screenchars
    5              0.000101000 syn keyword vimFuncName contained screencol screenpos screenrow screenstring search searchcount searchdecl searchpair searchpairpos searchpos server2client serverlist setbufline setbufvar setcellwidths setcharpos setcharsearch setcmdline setcmdpos setcursorcharpos setenv setfperm setline setloclist setmatches setpos setqflist setreg settabvar settabwinvar settagstack setwinvar sha256 shellescape shiftwidth sign_define sign_getdefined sign_getplaced sign_jump sign_place sign_placelist sign_undefine sign_unplace sign_unplacelist simplify sin sinh slice sort sound_clear sound_playevent sound_playfile sound_stop soundfold spellbadword spellsuggest split sqrt srand state str2float str2list str2nr strcharlen strcharpart strchars strdisplaywidth strftime strgetchar stridx
    5              0.000099000 syn keyword vimFuncName contained string strlen strpart strptime strridx strtrans strutf16len strwidth submatch substitute swapfilelist swapinfo swapname synID synIDattr synIDtrans synconcealed synstack system systemlist tabpagebuflist tabpagenr tabpagewinnr tagfiles taglist tan tanh tempname term_dumpdiff term_dumpload term_dumpwrite term_getaltscreen term_getansicolors term_getattr term_getcursor term_getjob term_getline term_getscrolled term_getsize term_getstatus term_gettitle term_gettty term_list term_scrape term_sendkeys term_setansicolors term_setapi term_setkill term_setrestore term_setsize term_start term_wait terminalprops test_alloc_fail test_autochdir test_feedinput test_garbagecollect_now test_garbagecollect_soon test_getvalue test_gui_event test_ignore_error
    5              0.000080000 syn keyword vimFuncName contained test_mswin_event test_null_blob test_null_channel test_null_dict test_null_function test_null_job test_null_list test_null_partial test_null_string test_option_not_set test_override test_refcount test_setmouse test_settime test_srand_seed test_unknown test_void timer_info timer_pause timer_start timer_stop timer_stopall tolower toupper tr trim trunc type typename undofile undotree uniq utf16idx values virtcol virtcol2col visualmode wildmenumode win_execute win_findbuf win_getid win_gettype win_gotoid win_id2tabwin win_id2win win_move_separator win_move_statusline win_screenpos win_splitmove winbufnr wincol windowsversion winheight winlayout winline winnr winrestcmd winrestview winsaveview winwidth wordcount writefile xor
                            
                            "--- syntax here and above generated by mkvimvim ---
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands for this syntax highlighting file {{{2
    5              0.000017000 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[afhHlmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'h'
                              com! -nargs=* VimFoldh <args> fold
                             else
                              com! -nargs=* VimFoldh <args>
                             endif
                             if g:vimsyn_folding =~# 'H'
                              com! -nargs=* VimFoldH <args> fold
                             else
                              com! -nargs=* VimFoldH <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p'
                              com! -nargs=* VimFoldp <args> fold
                             else
                              com! -nargs=* VimFoldp <args>
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
    5              0.000006000 else
    5              0.000090000  com! -nargs=*	VimFolda	<args>
    5              0.000029000  com! -nargs=*	VimFoldf	<args>
    5              0.000031000  com! -nargs=*	VimFoldh	<args>
    5              0.000024000  com! -nargs=*	VimFoldH	<args>
    5              0.000024000  com! -nargs=*	VimFoldl	<args>
    5              0.000024000  com! -nargs=*	VimFoldm	<args>
    5              0.000027000  com! -nargs=*	VimFoldp	<args>
    5              0.000024000  com! -nargs=*	VimFoldP	<args>
    5              0.000025000  com! -nargs=*	VimFoldr	<args>
    5              0.000026000  com! -nargs=*	VimFoldt	<args>
    5              0.000003000 endif
                            
                            " Deprecated variable options {{{2
    5              0.000011000 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
    5              0.000002000 endif
    5              0.000009000 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
    5              0.000004000 endif
    5              0.000010000 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
    5              0.000002000 endif
                            
                            " Variable options {{{2
    5              0.000007000 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
    5              0.000003000 else
    5              0.000009000  let s:vimsyn_maxlines= 60
    5              0.000002000 endif
                            
                            " Numbers {{{2
                            " =======
    5              0.000004000 syn case ignore
    5              0.000118000 syn match	vimNumber	'\<\d\+\%(\.\d\+\%(e[+-]\=\d\+\)\=\)\='	skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    5              0.000097000 syn match	vimNumber	'\<0b[01]\+'			skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    5              0.000105000 syn match	vimNumber	'\<0o\=\o\+'			skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    5              0.000095000 syn match	vimNumber	'\<0x\x\+'			skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    5              0.000092000 syn match	vimNumber	'\<0z\>'			skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    5              0.000109000 syn match	vimNumber	'\<0z\%(\x\x\)\+\%(\.\%(\x\x\)\+\)*'	skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    5              0.000115000 syn match	vimNumber	'\%(^\|\A\)\zs#\x\{6}'		skipwhite nextgroup=vimGlobal,vimSubst1,vimCommand,@vimComment
    5              0.000004000 syn case match
                            
                            " All vimCommands are contained by vimIsCommand. {{{2
    5              0.000648000 syn cluster vimCmdList	contains=vimAbb,vimAddress,vimAutoCmd,vimAugroup,vimBehave,vimDef,@vimEcho,vimEnddef,vimEndfunction,vimExecute,vimIsCommand,vimExtCmd,vimFor,vimFunction,vimGlobal,vimHighlight,vimLet,vimMap,vimMark,vimNotFunc,vimNorm,vimSet,vimSyntax,vimUnlet,vimUnmap,vimUserCmd,vimMenu,vimMenutranslate
    5              0.000054000 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=@vimCmdList,vimSubst1
    5              0.000060000 syn match vimIsCommand	"\<\%(\h\w*\|[23]mat\%[ch]\)\>"	contains=vimCommand
    5              0.000028000 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"
    5              0.000034000 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    5              0.000028000 syn match vimVar	      	"\s\zs&\%([lg]:\)\=\a\+\>"
    5              0.000028000 syn match vimVar		"\s\zs&t_\S[a-zA-Z0-9]\>"
    5              0.000022000 syn match vimVar        	"\s\zs&t_k;"
    5              0.000028000 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    5              0.000022000 syn keyword vimCommand  contained	in
                            
    5              0.000228000 syn cluster vimExprList contains=vimEnvvar,vimFunc,vimFuncVar,vimNumber,vimOper,vimOperParen,vimLetRegister,vimString,vimVar
                            
                            " Insertions And Appends: insert append {{{2
                            "   (buftype != nofile test avoids having append, change, insert show up in the command window)
                            " =======================
    5              0.000010000 if &buftype != 'nofile'
    1              0.000016000  syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$" extend
    1              0.000013000  syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$" extend
    1              0.000013000  syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$" extend
    5              0.000002000 endif
                            
                            " Behave! {{{2
                            " =======
    5              0.000019000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    5              0.000026000  syn match   vimBehaveError contained	"[^ ]\+"
    5              0.000003000 endif
    5              0.000100000 syn match   vimBehave	"\<be\%[have]\>"	nextgroup=vimBehaveBang,vimBehaveModel,vimBehaveError skipwhite
    5              0.000049000 syn match   vimBehaveBang	contained	"\a\@1<=!" nextgroup=vimBehaveModel skipwhite
    5              0.000018000 syn keyword vimBehaveModel	contained	mswin	xterm
                            
                            " Filetypes {{{2
                            " =========
    5              0.000103000 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    5              0.000017000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    5              0.000020000  syn match   vimFTError  contained	"\I\i*"
    5              0.000005000 endif
    5              0.000021000 syn keyword vimFTCmd    contained	filet[ype]
    5              0.000021000 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    5              0.000414000 syn cluster vimAugroupList	contains=@vimCmdList,vimFilter,vimFunc,vimLineComment,vimSpecFile,vimOper,vimNumber,vimOperParen,@vimComment,vimString,vimSubst,vimRegister,vimCmplxRepeat,vimNotation,vimCtrlChar,vimFuncVar,vimContinue
    5              0.000125000 syn match   vimAugroup	"\<aug\%[roup]\>" contains=vimAugroupKey,vimAugroupBang skipwhite nextgroup=vimAugroupBang,vimAutoCmdGroup
    5              0.000013000 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                              syn region  vimAugroup  fold	start="\<aug\%[roup]\>\ze\s\+\%([eE][nN][dD]\)\@!\S\+" matchgroup=vimAugroupKey end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>" contains=vimAutoCmd,@vimAugroupList,vimAugroupkey skipwhite nextgroup=vimAugroupEnd
    5              0.000004000 else
    5              0.000136000   syn region  vimAugroup	start="\<aug\%[roup]\>\ze\s\+\%([eE][nN][dD]\)\@!\S\+" matchgroup=vimAugroupKey end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>" contains=vimAutoCmd,@vimAugroupList,vimAugroupkey skipwhite nextgroup=vimAugroupEnd
    5              0.000004000 endif
    5              0.000014000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    5              0.000027000   syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    5              0.000005000 endif
                            
    5              0.000020000 syn match   vimAutoCmdGroup	contained "\S\+"
    5              0.000022000 syn match   vimAugroupEnd	contained "\c\<END\>"
    5              0.000046000 syn match   vimAugroupBang	contained "\a\@1<=!" skipwhite nextgroup=vimAutoCmdGroup
    5              0.000095000 syn keyword vimAugroupKey	contained aug[roup]  skipwhite nextgroup=vimAugroupBang,vimAutoCmdGroup,vimAugroupEnd
                            
                            " Operators: {{{2
                            " =========
    5              0.000250000 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,@vimContinue,vim9Comment,vimVar
    5              0.000076000 syn match	vimOper	"||\|&&\|[-+*/%.!]"				skipwhite nextgroup=vimString,vimSpecFile
    5              0.000115000 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\|!\~#\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    5              0.000082000 syn match	vimOper	"\(\<is\|\<isnot\)[?#]\{0,2}\>"			skipwhite nextgroup=vimString,vimSpecFile
    5              0.000045000 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    5              0.000106000 syn region	vimOperParen	matchgroup=vimSep		start="#\={" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    5              0.000022000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    5              0.000019000  syn match	vimOperError	")"
    5              0.000004000 endif
                            
                            " Functions: Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    5              0.000178000 syn cluster	vimFuncList	contains=vimFuncBang,vimFunctionError,vimFuncKey,vimFuncSID,Tag
    5              0.000162000 syn cluster	vimDefList	contains=vimFuncBang,vimFunctionError,vimDefKey,vimFuncSID,Tag
                            
    5              0.000552000 syn cluster	vimFuncBodyCommon	contains=@vimCmdList,vimCmplxRepeat,vimContinue,vimCtrlChar,vimDef,vimEnvvar,vimFBVar,vimFunc,vimFunction,vimLetHereDoc,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegister,vimSearch,vimSpecFile,vimString,vimSubst,vimFuncFold
    5              0.000116000 syn cluster	vimFuncBodyList	contains=@vimFuncBodyCommon,vimComment,vimLineComment,vimFuncVar,vimInsert
    5              0.000057000 syn cluster	vimDefBodyList	contains=@vimFuncBodyCommon,vim9Comment,vim9LineComment
                            
    5              0.000054000 syn region	vimFuncPattern	contained		matchgroup=vimOper start="/" end="$" contains=@vimSubstList
    5              0.000124000 syn match	vimFunction	"\<fu\%[nction]\>"	skipwhite nextgroup=vimCmdSep,vimComment,vimFuncPattern contains=vimFuncKey
    5              0.000120000 syn match	vimDef	"\<def\>"		skipwhite nextgroup=vimCmdSep,vimComment,vimFuncPattern contains=vimDefKey
                            
    5              0.000082000 syn match	vimFunction	"\<fu\%[nction]\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)\+"	contains=@vimFuncList skipwhite nextgroup=vimFuncParams
    5              0.000060000 syn match	vimDef	"\<def\s\+new\%(\i\|{.\{-1,}}\)\+"				contains=@vimDefList            nextgroup=vimDefParams
    5              0.000092000 syn match	vimDef	"\<def\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)\+"		contains=@vimDefList,vimMethodName            nextgroup=vimDefParams
                            
    5              0.000071000 syn match	vimFuncComment	contained	+".*+ skipwhite skipnl nextgroup=vimFuncBody,vimEndfunction
    5              0.000070000 syn match	vimDefComment	contained	"#.*" skipwhite skipnl nextgroup=vimDefBody,vimEnddef
                            
    5              0.000018000 syn match	vimFuncBang	contained	"!"
    5              0.000033000 syn match	vimFuncSID	contained	"\c<sid>"
    5              0.000029000 syn match	vimFuncSID	contained	"\<[sg]:"
    5              0.000021000 syn keyword	vimFuncKey	contained	fu[nction]
    5              0.000016000 syn keyword	vimDefKey	contained	def
    5              0.000019000 syn keyword	vimMethodName	contained	empty len string
                            
    5              0.000164000 syn region	vimFuncParams	contained	matchgroup=Delimiter start="(" skip=+\n\s*\\\|\n\s*"\\ + end=")" skipwhite skipnl nextgroup=vimFuncBody,vimFuncComment,vimEndfunction,vimFuncMod contains=vimFuncParam,@vimContinue
    5              0.000167000 syn region	vimDefParams	contained	matchgroup=Delimiter start="("		   end=")" skipwhite skipnl nextgroup=vimDefBody,vimDefComment,vimEnddef,vimReturnType	 contains=vimDefParam,vim9Comment
    5              0.000044000 syn match	vimFuncParam	contained	"\<\h\w*\>\|\.\.\."	skipwhite nextgroup=vimFuncParamEquals
    5              0.000060000 syn match	vimDefParam	contained	"\<\h\w*\>"		skipwhite nextgroup=vimParamType,vimFuncParamEquals
                            
    5              0.000020000 syn match	vimFuncParamEquals contained	"="			skipwhite        nextgroup=@vimExprList
    5              0.000122000 syn match	vimFuncMod	 contained	"\<\%(abort\|closure\|dict\|range\)\>"	skipwhite skipnl nextgroup=vimFuncBody,vimFuncComment,vimEndfunction,vimFuncMod
                            
    5              0.000054000 syn region	vimFuncBody	contained	start="^"	matchgroup=vimCommand end="\<endfu\%[nction]\>"	contains=@vimFuncBodyList
    5              0.000040000 syn region	vimDefBody	contained	start="^"	matchgroup=vimCommand end="\<enddef\>"	contains=@vimDefBodyList
                            
    5              0.000024000 syn match	vimEndfunction	"\<endf\%[unction]\>"
    5              0.000020000 syn match	vimEnddef	"\<enddef\>"
                            
    5              0.000016000 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncFold	start="^\s*:\=\s*fu\%[nction]\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)\+\s*("	end="^\s*:\=\s*endf\%[unction]\>" contains=vimFunction fold keepend extend transparent
                             syn region	vimFuncFold	start="^\s*:\=\s*def\>!\=\s*\%(<[sS][iI][dD]>\|[sg]:\)\=\%(\i\|[#.]\)\+("		end="^\s*:\=\s*enddef\>"          contains=vimDef      fold keepend extend transparent
                             syn region	vimFuncFold	start="^\s*:\=\s*def\s\+new\i\+("					end="^\s*:\=\s*enddef\>"          contains=vimDef      fold keepend extend transparent
    5              0.000004000 endif
                            
    5              0.000025000 syn match	vimFuncVar   contained	"a:\%(\K\k*\|\d\+\)\>"
    5              0.000019000 syn match	vimFuncBlank contained	"\s\+"
                            
                            " Types: {{{2
                            " =====
                            " vimTypes : new for vim9
    5              0.000136000 syn region	vimReturnType	contained	start=":\s" end="$" matchgroup=vim9Comment end="\ze#" skipwhite skipnl nextgroup=vimDefBody,vimDefComment,vimEnddef contains=vimTypeSep transparent
    5              0.000065000 syn match	vimParamType	contained	":\s\+\a"			skipwhite skipnl nextgroup=vimFuncParamEquals   	        contains=vimTypeSep,@vimType
                            
    5              0.000020000 syn match	vimTypeSep	contained	":\s\@=" skipwhite nextgroup=@vimType
    5              0.000023000 syn keyword	vimType	contained	any blob bool channel float job number string void
    5              0.000017000 syn match	vimType	contained	"\<func\>"
    5              0.000070000 syn region	vimCompoundType	contained	matchgroup=vimType start="\<func("            end=")" nextgroup=vimTypeSep contains=@vimType oneline transparent
    5              0.000040000 syn region	vimCompoundType   contained         matchgroup=vimType start="\<\%(list\|dict\)<" end=">"                      contains=@vimType oneline transparent
    5              0.000018000 syn match	vimUserType	contained	"\<\u\w*\>"
                            
    5              0.000064000 syn cluster vimType contains=vimType,vimCompoundType,vimUserType
                            
                            " Keymaps: {{{2
                            " =======
                            
    5              0.000043000 syn match  vimKeymapStart	"^"	contained skipwhite nextgroup=vimKeymapLhs,@vimKeymapLineComment
    5              0.000086000 syn match  vimKeymapLhs	"\S\+"	contained skipwhite nextgroup=vimKeymapRhs contains=vimNotation
    5              0.000079000 syn match  vimKeymapRhs	"\S\+"	contained skipwhite nextgroup=vimKeymapTailComment contains=vimNotation
    5              0.000020000 syn match  vimKeymapTailComment	"\S.*"	contained
                            
                            " TODO: remove when :" comment is matched in parts as "ex-colon comment" --djk
    5              0.000008000 if s:vim9script
                              syn match  vim9KeymapLineComment	"#.*"	contained contains=@vimCommentGroup,vimCommentString,vim9CommentTitle
    5              0.000005000 else
    5              0.000080000   syn match  vimKeymapLineComment	+".*+	contained contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    5              0.000004000 endif
    5              0.002701000 syn cluster vimKeymapLineComment contains=vim9\=KeymapLineComment
                            
    5              0.000066000 syn region vimKeymap matchgroup=vimCommand start="\<loadk\%[eymap]\>" end="\%$" contains=vimKeymapStart
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    5              0.000069000 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst1
    5              0.000070000 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst1
    5              0.000066000 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst1
    5              0.000070000 syn match	vimSpecFile	"\s%$"ms=s+1		nextgroup=vimSpecFileMod,vimSubst1
    5              0.000061000 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst1
    5              0.000066000 syn match	vimSpecFile	"#\d\+\|[#%]<\>"		nextgroup=vimSpecFileMod,vimSubst1
    5              0.000025000 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    5              0.000305000 syn cluster	vimUserCmdList	contains=@vimCmdList,vimCmplxRepeat,@vimComment,vimCtrlChar,vimEscapeBrace,vimFunc,vimNotation,vimNumber,vimOper,vimRegister,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange
    5              0.000018000 syn keyword	vimUserCommand	contained	com[mand]
    5              0.000047000 syn match	vimUserCmdName	contained	"\<\u\w*\>" nextgroup=vimUserCmdBlock skipwhite
    5              0.000145000 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList,vimComFilter,vimCmdBlock,vimUserCmdName
    5              0.000019000 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    5              0.000062000 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    5              0.000110000 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    5              0.000088000 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    5              0.000089000 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    5              0.000059000 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    5              0.000066000 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    5              0.000060000 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    5              0.000062000 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    5              0.000021000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    5              0.000017000  syn match	vimUserCmdError	contained	"\S\+\>"
    5              0.000003000 endif
    5              0.000004000 syn case ignore
    5              0.000055000 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
                            " GEN_SYN_VIM: vimUserAttrbCmplt, START_STR='syn keyword vimUserAttrbCmplt contained', END_STR=''
    5              0.000074000 syn keyword vimUserAttrbCmplt contained arglist augroup behave buffer color command compiler cscope diff_buffer dir environment event expression file file_in_path filetype function help highlight history keymap locale mapclear mapping menu messages syntax syntime option packadd runtime shellcmd sign tag tag_listfiles user var breakpoint scriptnames
    5              0.000064000 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    5              0.000063000 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%([.#]\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    5              0.000003000 syn case match
    5              0.000020000 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
    5              0.000051000 syn region	vimUserCmdBlock	contained	matchgroup=vimSep start="{" end="}" contains=@vimDefBodyList
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    5              0.000024000 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e end='"'
                            
    5              0.000020000 if s:vim9script
                              syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString contained
                              syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString contained
                              syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString contained
                              " Vim9 comments - TODO: might be highlighted while they don't work
                              syn match	vim9Comment	excludenl +\s#[^{].*$+lc=1	contains=@vimCommentGroup,vimCommentString
                              syn match	vim9Comment	+\<endif\s\+#[^{].*$+lc=5	contains=@vimCommentGroup,vimCommentString
                              syn match	vim9Comment	+\<else\s\+#[^{].*$+lc=4	contains=@vimCommentGroup,vimCommentString
                              " Vim9 comment inside expression
                              " syn match	vim9Comment	+\s\zs#[^{].*$+ms=s+1	contains=@vimCommentGroup,vimCommentString
                              " syn match	vim9Comment	+^\s*#[^{].*$+		contains=@vimCommentGroup,vimCommentString
                              " syn match	vim9Comment	+^\s*#$+		contains=@vimCommentGroup,vimCommentString
                            
                              syn cluster vimComment contains=vim9Comment
    5              0.000006000 else
    5              0.000042000   syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    5              0.000041000   syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    5              0.000044000   syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
                              " Vim9 comments - TODO: might be highlighted while they don't work
    5              0.000043000   syn match	vim9Comment	excludenl +\s#[^{].*$+lc=1	contains=@vimCommentGroup,vimCommentString contained
    5              0.000044000   syn match	vim9Comment	+\<endif\s\+#[^{].*$+lc=5	contains=@vimCommentGroup,vimCommentString contained
    5              0.000042000   syn match	vim9Comment	+\<else\s\+#[^{].*$+lc=4	contains=@vimCommentGroup,vimCommentString contained
                              " Vim9 comment inside expression
    5              0.000041000   syn match	vim9Comment	+\s\zs#[^{].*$+ms=s+1	contains=@vimCommentGroup,vimCommentString contained
    5              0.000056000   syn match	vim9Comment	+^\s*#[^{].*$+		contains=@vimCommentGroup,vimCommentString contained
    5              0.000040000   syn match	vim9Comment	+^\s*#$+		contains=@vimCommentGroup,vimCommentString contained
                            
    5              0.000027000   syn cluster vimComment contains=vimComment
    5              0.000003000 endif
                            
                            " Environment Variables: {{{2
                            " =====================
    5              0.000022000 syn match	vimEnvvar	"\$\I\i*"
    5              0.000019000 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    5              0.000041000 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    5              0.000017000 syn match	vimPatSepErr	contained	"\\)"
    5              0.000016000 syn match	vimPatSep	contained	"\\|"
    5              0.000057000 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\\]['"]"	contains=@vimStringGroup
    5              0.000035000 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    5              0.000015000 syn match	vimNotPatSep	contained	"\\\\"
    5              0.000124000 syn cluster	vimStringGroup	contains=vimEscape,vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    5              0.000043000 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+	contains=@vimStringGroup
    5              0.000024000 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
                            "syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup  " see tst45.vim
    5              0.000039000 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    5              0.000021000 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
    5              0.000017000 syn match	vimEscape	contained	"\\."
                            " syn match	vimEscape	contained	+\\[befnrt\"]+
    5              0.000041000 syn match	vimEscape	contained	"\\\o\{1,3}\|\\[xX]\x\{1,2}\|\\u\x\{1,4}\|\\U\x\{1,8}"
    5              0.000060000 syn match	vimEscape	contained	"\\<" contains=vimNotation
    5              0.000020000 syn match	vimEscape	contained	"\\<\*[^>]*>\=>"
                            
    5              0.000083000 syn region	vimString	oneline start=+$'+ skip=+''+ end=+'+ contains=vimStringInterpolationBrace,vimStringInterpolationExpr
    5              0.000061000 syn region	vimString	oneline start=+$"+ end=+"+ contains=@vimStringGroup,vimStringInterpolationBrace,vimStringInterpolationExpr
    5              0.000041000 syn region	vimStringInterpolationExpr  oneline contained matchgroup=vimSep start=+{+ end=+}+ contains=@vimExprList
    5              0.000016000 syn match	vimStringInterpolationBrace contained "{{"
    5              0.000016000 syn match	vimStringInterpolationBrace contained "}}"
                            
                            " Substitutions: {{{2
                            " =============
    5              0.000131000 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    5              0.000079000 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    5              0.000031000 syn cluster	vimSubstList	add=vimCollection
    5              0.000055000 syn match	vimSubst	"^\s*\%(s\%[ubstitute]\|sm\%[agic]\|sno\%[magic]\)\>[\"#|]\@!"	nextgroup=vimSubstPat
    5              0.000052000 syn match	vimSubst	"^\s*\%(s\%[ubstitute]\|sm\%[agic]\|sno\%[magic]\)_\@="	nextgroup=vimSubstPat
    5              0.000054000 syn match	vimSubst	"^\s*\%(s\%[ubstitute]\|sm\%[agic]\>\|sno\%[magic]\)\ze#.\{-}#.\{-}#"	nextgroup=vimSubstPat
    5              0.000052000 syn match	vimSubst1	contained	"\%(s\%[ubstitute]\|sm\%[agic]\>\|sno\%[magic]\)\>[\"#|]\@!"		nextgroup=vimSubstPat
    5              0.000047000 syn match	vimSubst1	contained	"\%(s\%[ubstitute]\|sm\%[agic]\>\|sno\%[magic]\)_\@="			nextgroup=vimSubstPat
    5              0.000049000 syn match	vimSubst1	contained	"\%(s\%[ubstitute]\|sm\%[agic]\>\|sno\%[magic]\)\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
                            " TODO: Vim9 illegal separators for abbreviated :s form are [-.:], :su\%[...] required
                            "     : # is allowed but "not recommended" (see :h pattern-delimiter)
    5              0.000076000 syn region	vimSubstPat	contained	matchgroup=vimSubstDelim start="\z([!#$%&'()*+,-./:;<=>?@[\]^_`{}~]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    5              0.000084000 syn region	vimSubstRep4	contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>"	contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    5              0.000046000 syn region	vimCollection	contained 	transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    5              0.000018000 syn match	vimCollClassErr	contained	"\[:.\{-\}:\]"
    5              0.000074000 syn match	vimCollClass	contained 	transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|retu\%[rn]\|tab\|escape\|backspace\):\]"
    5              0.000016000 syn match	vimSubstSubstr	contained	"\\z\=\d"
    5              0.000016000 syn match	vimSubstTwoBS	contained	"\\\\"
    5              0.000045000 syn match	vimSubstFlagErr	contained	"[^< \t\r|]\+" contains=vimSubstFlags
    5              0.000020000 syn match	vimSubstFlags	contained	"[&cegiIlnpr#]\+"
                            
                            " 'String': {{{2
    5              0.000022000 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    5              0.000084000 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    5              0.000087000 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimFilter,vimMarkNumber,vimSubst1
    5              0.000081000 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimFilter,vimMarkNumber,vimSubst1
    5              0.000084000 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    5              0.000084000 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst1
    5              0.000068000 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst1
    5              0.000019000 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
    5              0.000070000 syn match	vimRange	"[`'][a-zA-Z0-9],[`'][a-zA-Z0-9]"	contains=vimMark	skipwhite nextgroup=vimFilter
                            
    5              0.000034000 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    5              0.000022000 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    5              0.000023000 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    5              0.000019000 syn match	vimRegister	'@"'
    5              0.000021000 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
    5              0.000026000 syn match	vimLetRegister	contained	'@["0-9\-a-zA-Z#=*+_/]'
                            
    5              0.000044000 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    5              0.000062000 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    5              0.000067000 syn match	vimFilter 		"^!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    5              0.000070000 syn match	vimFilter    contained	"!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    5              0.000062000 syn match	vimComFilter contained	"|!!\=[^"]\{-}\(|\|\ze\"\|$\)"      contains=vimOper,vimSpecFile
                            
                            " Complex Repeats: (:h complex-repeat) {{{2
                            " ===============
    5              0.000026000 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    5              0.000030000 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    5              0.000189000 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\.\n\@!" end="$" end="|" matchgroup=vimNotation end="<[cC][rR]>" keepend contains=vimSetEqual,vimOption,vimErrSetting,@vimComment,vimSetString,vimSetMod
    5              0.000157000 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]"me=e-1 end="$"	contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar
    5              0.000048000 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+		contains=vimCtrlChar
    5              0.000025000 syn match	vimSetSep	contained	"[,:]"
    5              0.000029000 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let And Var: {{{2
                            " ===========
    5              0.000117000 syn keyword	vimLet	let		skipwhite nextgroup=vimVar,vimFuncVar,vimLetHereDoc,vimLetRegister,vimVarList
    5              0.000070000 syn keyword	vimConst	cons[t]		skipwhite nextgroup=vimVar,vimLetHereDoc,vimVarList
    5              0.000077000 syn region	vimVarList	contained	start="\[" end="]" contains=vimVar,vimContinue
                            
    5              0.000048000 syn keyword	vimUnlet	unl[et]		skipwhite nextgroup=vimUnletBang,vimUnletVars
    5              0.000034000 syn match	vimUnletBang	contained	"!"	skipwhite nextgroup=vimUnletVars
    5              0.000155000 syn region	vimUnletVars	contained	start="$\I\|\h" skip="\n\s*\\" end="$" end="|" contains=vimVar,vimEnvvar,vimContinue,vimString,vimNumber
                            
    5              0.000084000 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='=<<\s*\%(trim\s\+\%(eval\s\+\)\=\|eval\s\+\%(trim\s\+\)\=\)\=\z(\L\S*\)' matchgroup=vimLetHereDocStop end='^\s*\z1\s*$' extend
    5              0.000077000 syn keyword	vimLet	var		skipwhite nextgroup=vimVar,vimFuncVar,vimLetHereDoc
                            
                            " For: {{{2
                            " ===
    5              0.000054000 syn keyword	vimFor	for	skipwhite nextgroup=vimVar,vimVarList
                            
                            " Abbreviations: {{{2
                            " =============
                            " GEN_SYN_VIM: vimCommand abbrev, START_STR='syn keyword vimAbb', END_STR='skipwhite nextgroup=vimMapMod,vimMapLhs'
    5              0.000104000 syn keyword vimAbb ab[breviate] ca[bbrev] cnorea[bbrev] cuna[bbrev] ia[bbrev] inorea[bbrev] iuna[bbrev] norea[bbrev] una[bbreviate] skipwhite nextgroup=vimMapMod,vimMapLhs
                            " GEN_SYN_VIM: vimCommand abclear, START_STR='syn keyword vimAbb', END_STR='skipwhite nextgroup=vimMapMod'
    5              0.000041000 syn keyword vimAbb abc[lear] cabc[lear] iabc[lear] skipwhite nextgroup=vimMapMod
                            
                            " Autocmd: {{{2
                            " =======
    5              0.000066000 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent nextgroup=vimAutoCmdSpace
    5              0.000031000 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    5              0.000047000 syn match	vimAutoCmdSfxList	contained	"\S*"	skipwhite nextgroup=vimAutoCmdMod,vimAutoCmdBlock
    5              0.000044000 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
    5              0.000038000 syn match	vimAutoCmdMod	"\(++\)\=\(once\|nested\)"	skipwhite nextgroup=vimAutoCmdBlock
    5              0.000039000 syn region	vimAutoCmdBlock	contained	matchgroup=vimSep start="{" end="}" contains=@vimDefBodyList
                            
                            " Echo And Execute: -- prefer strings! {{{2
                            " ================
                            " NOTE: No trailing comments
                            
    5              0.000117000 syn region	vimEcho
                                  \ matchgroup=vimCommand
                                  \ start="\<ec\%[ho]\>"
                                  \ start="\<echoe\%[rr]\>"
                                  \ start="\<echom\%[sg]\>"
                                  \ start="\<echoc\%[onsole]\>"
                                  \ start="\<echon\>"
                                  \ start="\<echow\%[indow]\>"
                                  \ skip=+\\|\|\n\s*\\\|\n\s*"\\ +
                                  \ matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimExprList transparent
                            
    5              0.000079000 syn match	vimEchohl	"\<echohl\=\>"	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchohlNone
    5              0.000003000 syn case ignore
    5              0.000014000 syn keyword	vimEchohlNone	contained none
    5              0.000004000 syn case match
                            
    5              0.000035000 syn cluster	vimEcho	contains=vimEcho,vimEchohl
                            
    5              0.000069000 syn region	vimExecute	matchgroup=vimCommand start="\<exe\%[cute]\>" skip=+\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimExprList transparent
                            
                            " Maps: {{{2
                            " ====
    5              0.000053000 syn match	vimMap		"\<map\>\ze\s*(\@!" 	    skipwhite nextgroup=vimMapMod,vimMapLhs
    5              0.000073000 syn match	vimMap		"\<map!"	  contains=vimMapBang skipwhite nextgroup=vimMapMod,vimMapLhs
                            " GEN_SYN_VIM: vimCommand map, START_STR='syn keyword vimMap', END_STR='skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs'
    5              0.000140000 syn keyword vimMap cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] tma[p] tno[remap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
                            " GEN_SYN_VIM: vimCommand mapclear, START_STR='syn keyword vimMap', END_STR='skipwhite nextgroup=vimMapMod'
    5              0.000068000 syn keyword vimMap cmapc[lear] imapc[lear] lmapc[lear] nmapc[lear] omapc[lear] smapc[lear] tmapc[lear] vmapc[lear] xmapc[lear] skipwhite nextgroup=vimMapMod
    5              0.000049000 syn keyword	vimMap mapc[lear]	skipwhite nextgroup=vimMapBang,vimMapMod
                            " GEN_SYN_VIM: vimCommand unmap, START_STR='syn keyword vimUnmap', END_STR='skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs'
    5              0.000092000 syn keyword vimUnmap cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] tunma[p] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    5              0.000098000 syn match	vimMapLhs	contained	"\%(.\|\S\)\+"		contains=vimCtrlChar,vimNotation skipwhite        nextgroup=vimMapRhs
    5              0.000100000 syn match	vimMapLhs	contained	"\%(.\|\S\)\+\ze\s*$"	contains=vimCtrlChar,vimNotation skipwhite skipnl nextgroup=vimMapRhsContinue
    5              0.000049000 syn match	vimMapBang	contained	"\a\@1<=!"		skipwhite nextgroup=vimMapMod,vimMapLhs
    5              0.000150000 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    5              0.000112000 syn region	vimMapRhs	contained	start="\S" 	        skip=+\\|\|\@1<=|\|\n\s*\\\|\n\s*"\\ + end="|" end="$" contains=@vimContinue,vimCtrlChar,vimNotation skipnl nextgroup=vimMapRhsContinue
                            " assume a continuation comment introduces the RHS
    5              0.000099000 syn region	vimMapRhsContinue	contained	start=+^\s*\%(\\\|"\\ \)+ skip=+\\|\|\@1<=|\|\n\s*\\\|\n\s*"\\ + end="|" end="$" contains=@vimContinue,vimCtrlChar,vimNotation
    5              0.000002000 syn case ignore
    5              0.000034000 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    5              0.000005000 syn case match
                            
                            " Menus: {{{2
                            " =====
                            " NOTE: tail comments disallowed
                            " GEN_SYN_VIM: vimCommand menu, START_STR='syn keyword vimMenu', END_STR='skipwhite nextgroup=vimMenuBang,vimMenuMod,vimMenuName,vimMenuPriority,vimMenuStatus'
    5              0.000204000 syn keyword vimMenu am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] sme[nu] snoreme[nu] sunme[nu] tlm[enu] tln[oremenu] tlu[nmenu] tm[enu] tu[nmenu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] xme[nu] xnoreme[nu] xunme[nu] skipwhite nextgroup=vimMenuBang,vimMenuMod,vimMenuName,vimMenuPriority,vimMenuStatus
    5              0.000048000 syn keyword vimMenu popu[p] skipwhite nextgroup=vimMenuBang,vimMenuName
    5              0.000094000 syn region	vimMenuRhs	 contained contains=@vimContinue,vimNotation start="|\@!\S"            skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + end="$" matchgroup=vimSep end="|"
    5              0.000094000 syn region	vimMenuRhsContinue contained contains=@vimContinue,vimNotation start=+^\s*\%(\\\|"\\ \)+ skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + end="$" matchgroup=vimSep end="|"
    5              0.000113000 syn match	vimMenuName	"\.\@!\%(\\\s\|\S\)\+"        contained contains=vimMenuNotation,vimNotation skipwhite        nextgroup=vimCmdSep,vimMenuRhs
    5              0.000113000 syn match	vimMenuName	"\.\@!\%(\\\s\|\S\)\+\ze\s*$" contained contains=vimMenuNotation,vimNotation skipwhite skipnl nextgroup=vimCmdSep,vimMenuRhsContinue
    5              0.000018000 syn match	vimMenuNotation	"&\a\|&&\|\\\s\|\\\." contained
    5              0.000035000 syn match	vimMenuPriority	"\<\d\+\%(\.\d\+\)*\>" contained skipwhite nextgroup=vimMenuName
    5              0.000126000 syn match	vimMenuMod	"\c<\%(script\|silent\|special\)>" contained skipwhite nextgroup=vimMenuName,vimMenuPriority,vimMenuMod contains=vimMapModKey,vimMapModErr
    5              0.000030000 syn keyword	vimMenuStatus	enable disable nextgroup=vimMenuName skipwhite
    5              0.000046000 syn match	vimMenuBang	"\a\@1<=!" contained skipwhite nextgroup=vimMenuName,vimMenuMod
                            
    5              0.000110000 syn region	vimMenutranslate
                                  \ matchgroup=vimCommand start="\<menut\%[ranslate]\>"
                                  \ skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ +
                                  \ end="$" matchgroup=vimCmdSep end="|" matchgroup=vimMenuClear end="\<clear\ze\s*\%(["#|]\|$\)"
                                  \ contains=@vimContinue,vimMenutranslateName keepend transparent
                            " oneline is sufficient to match the current formatting in runtime/lang/*.vim
    5              0.000071000 syn match	vimMenutranslateName "\%(\\\s\|\S\)\+" contained contains=vimMenuNotation,vimNotation
    5              0.000040000 syn match	vimMenutranslateComment +".*+ contained containedin=vimMenutranslate
                            
                            " Angle-Bracket Notation: (tnx to Michael Geddes) {{{2
                            " ======================
    5              0.000014000 syn case ignore
    5              0.000228000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd]-\)\{0,4}x\=\%(f\d\{1,2}\|[^ \t:]\|space\|bar\|bslash\|nl\|newline\|lf\|linefeed\|cr\|retu\%[rn]\|enter\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|csi\|right\|paste\%(start\|end\)\|left\|help\|undo\|k\=insert\|ins\|mouse\|[kz]\=home\|[kz]\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\%(page\)\=\%(\|down\|up\|k\d\>\)\)>" contains=vimBracket
                            
    5              0.000114000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}\%(net\|dec\|jsb\|pterm\|urxvt\|sgr\)mouse>"		contains=vimBracket
    5              0.000105000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}\%(left\|middle\|right\)\%(mouse\|drag\|release\)>"	contains=vimBracket
    5              0.000085000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}left\%(mouse\|release\)nm>"			contains=vimBracket
    5              0.000083000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}x[12]\%(mouse\|drag\|release\)>"		contains=vimBracket
    5              0.000081000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}sgrmouserelease>"			contains=vimBracket
    5              0.000080000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}mouse\%(up\|down\|move\)>"			contains=vimBracket
    5              0.000087000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd2-4]-\)\{0,4}scrollwheel\%(up\|down\|right\|left\)>"		contains=vimBracket
                            
    5              0.000076000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%(sid\|nop\|nul\|lt\|drop\)>"				contains=vimBracket
    5              0.000096000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%(snr\|plug\|cursorhold\|ignore\|cmd\|scriptcmd\|focus\%(gained\|lost\)\)>"	contains=vimBracket
    5              0.000081000 syn match	vimNotation	'\%(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    5              0.000099000 syn match	vimNotation	'\%#=1\%(\\\|<lt>\)\=<\%(q-\)\=\%(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    5              0.000102000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([cas]file\|abuf\|amatch\|cexpr\|cword\|cWORD\|client\|stack\|script\|sf\=lnum\)>"	contains=vimBracket
    5              0.000089000 syn match	vimNotation	"\%#=1\%(\\\|<lt>\)\=<\%([scamd]-\)\{0,4}char-\%(\d\+\|0\o\+\|0x\x\+\)>"		contains=vimBracket
                            
    5              0.000041000 syn match	vimBracket contained	"[\\<>]"
    5              0.000005000 syn case match
                            
                            " User Function Highlighting: {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    5              0.000121000 syn match	vimFunc              	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("                	contains=vimFuncEcho,vimFuncName,vimUserFunc,vimExecute
    5              0.000102000 syn match	vimUserFunc	contained        	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation,vimMethodName
    5              0.000030000 syn keyword	vimFuncEcho	contained      	ec ech echo
                            
                            " User Command Highlighting: {{{2
    5              0.000033000 syn match vimUsrCmd	'^\s*\zs\u\%(\w*\)\@>\%([(#[]\|\s\+\%([-+*/%]\=\|\.\.\)=\)\@!'
                            
                            " Errors And Warnings: {{{2
                            " ====================
    5              0.000023000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
                             " TODO: The new-prefix exception should only apply to constructor definitions.
                             " TODO: The |builtin-object-methods| exception should only apply to method
                             " definitions.
    5              0.000078000  syn match	vimFunctionError	"\s\zs\%(empty\|len\|new\|string\)\@![a-z0-9]\i\{-}\ze\s*("		contained contains=vimFuncKey,vimFuncBlank
    5              0.000066000  syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    5              0.000021000  syn match	vimElseIfErr	"\<else\s\+if\>"
    5              0.000022000  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    5              0.000005000 endif
                            
    5              0.000141000 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<retu\%[rn]\>\|\<while\>"	skipwhite nextgroup=vimOper,vimOperParen,vimVar,vimFunc,vimNotation
                            
                            " Norm: {{{2
                            " ====
    5              0.000037000 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    5              0.000015000 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax: {{{2
                            "=======
    5              0.000058000 syn match	vimGroupList	contained	"[^[:space:],]\+\%(\s*,\s*[^[:space:],]\+\)*" contains=vimGroupSpecial
    5              0.000082000 syn region	vimGroupList	contained	start=/^\s*["#]\\ \|^\s*\\\|[^[:space:],]\+\s*,/ skip=/\s*\n\s*\\\|\s*\n\s*["#]\\ \|^\s*\\\|^\s*["#]\\ / end=/[^[:space:],]\s*$\|[^[:space:],]\ze\s\+\w/ contains=@vimContinue,vimGroupSpecial
    5              0.000017000 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
                            
    5              0.000031000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    5              0.000016000  syn match	vimSynError	contained	"\i\+"
    5              0.000031000  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    5              0.000002000 endif
    5              0.000034000 syn match	vimSynContains	contained	"\<contain\%(s\|edin\)="	skipwhite skipnl nextgroup=vimGroupList
    5              0.000044000 syn match	vimSynKeyContainedin	contained	"\<containedin="	skipwhite skipnl nextgroup=vimGroupList
    5              0.000028000 syn match	vimSynNextgroup	contained	"\<nextgroup="		skipwhite skipnl nextgroup=vimGroupList
    5              0.000010000 if has("conceal")
                             " no whitespace allowed after '='
    5              0.000037000  syn match	vimSynCchar	contained	"\<cchar="	nextgroup=vimSynCcharValue
    5              0.000014000  syn match	vimSynCcharValue	contained	"\S"
    5              0.000003000 endif
                            
    5              0.000067000 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,@vimComment
    5              0.000027000 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    5              0.000038000 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    5              0.000014000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    5              0.000014000  syn match	vimSynCaseError	contained	"\i\+"
    5              0.000004000 endif
    5              0.000012000 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    5              0.000027000 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    5              0.000024000 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    5              0.000115000 syn region	vimClusterName	contained keepend	matchgroup=vimGroupName start="\h\w*\>" skip=+\\\\\|\\\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="$\||" contains=@vimContinue,vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    5              0.000029000 syn match	vimGroupAdd	contained keepend	"\<add="	skipwhite skipnl nextgroup=vimGroupList
    5              0.000027000 syn match	vimGroupRem	contained keepend	"\<remove="	skipwhite skipnl nextgroup=vimGroupList
                            
                            " Syntax: foldlevel {{{2
    5              0.000040000 syn keyword	vimSynType	contained	foldlevel	skipwhite nextgroup=vimSynFoldMethod,vimSynFoldMethodError
    5              0.000015000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynfoldmethoderror")
    5              0.000013000  syn match	vimSynFoldMethodError	contained	"\i\+"
    5              0.000001000 endif
    5              0.000017000 syn keyword	vimSynFoldMethod	contained	start	minimum
                            
                            " Syntax: iskeyword {{{2
    5              0.000027000 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    5              0.000025000 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    5              0.000013000 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    5              0.000035000 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: keyword {{{2
    5              0.000066000 syn cluster	vimSynKeyGroup	contains=@vimContinue,vimSynCchar,vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    5              0.000025000 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    5              0.000048000 syn region	vimSynKeyRegion	contained         keepend	matchgroup=vimGroupName start="\h\w*\>" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|\|$" contains=@vimSynKeyGroup
    5              0.000088000 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
                            
                            " Syntax: match {{{2
    5              0.000133000 syn cluster	vimSynMtchGroup	contains=@vimContinue,vimSynCchar,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation,vimMtchComment
    5              0.000026000 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    5              0.000049000 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*\>" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|\|$" contains=@vimSynMtchGroup
    5              0.000047000 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
                            
                            " Syntax: off and on {{{2
    5              0.000019000 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    5              0.000146000 syn cluster	vimSynRegPatGroup	contains=@vimContinue,vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    5              0.000083000 syn cluster	vimSynRegGroup	contains=@vimContinue,vimSynCchar,vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    5              0.000029000 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    5              0.000042000 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip=+\\\\\|\\\|\n\s*\\\|\n\s*"\\ + end="|\|$" contains=@vimSynRegGroup
    5              0.000051000 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    5              0.000048000 syn match	vimSynReg	contained	"\<\%(start\|skip\|end\)="	nextgroup=vimSynRegPat
    5              0.000058000 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup
    5              0.000068000 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip=/\\\\\|\\\z1\|\n\s*\\\|\n\s*"\\ /  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    5              0.000032000 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    5              0.000037000 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    5              0.000017000 syn match	vimSynPatMod	contained	"lc=\d\+"
    5              0.000027000 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    5              0.000021000 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    5              0.000026000 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    5              0.000024000 syn match	vimMtchComment	contained	'"[^"]\+$'
                            
                            " Syntax: sync {{{2
                            " ============
    5              0.000097000 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    5              0.000016000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    5              0.000012000  syn match	vimSyncError	contained	"\i\+"
    5              0.000003000 endif
    5              0.000014000 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    5              0.000027000 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    5              0.000024000 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    5              0.000035000 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    5              0.000027000 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    5              0.000059000 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    5              0.000026000 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    5              0.000029000 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    5              0.000039000 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    5              0.000010000 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand: here by reasons of precedence {{{2
                            " ====================
    5              0.000076000 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting: {{{2
                            " ============
    5              0.000044000 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,@vimComment
    5              0.000022000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    5              0.000012000  syn match	vimHiCtermError	contained	"\D\i*"
    5              0.000002000 endif
    5              0.000041000 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    5              0.000015000 syn match	vimHiBang	contained	"\a\@1<=!"	skipwhite nextgroup=@vimHighlightCluster
                            
    5              0.000029000 syn match	vimHiGroup	contained	"\i\+"
    5              0.000029000 syn case ignore
    5              0.000031000 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl underdashed underdotted underdouble
    5              0.000015000 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    5              0.000003000 syn case match
    5              0.000023000 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    5              0.000089000 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    5              0.000016000 syn case ignore
    5              0.000061000 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey grey40 grey50 grey90 lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred lightyellow magenta red seagreen white yellow
    5              0.000029000 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    5              0.000003000 syn case match
    5              0.000022000 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    5              0.000022000 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    5              0.000017000 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    5              0.000250000 syn cluster	vimHiCluster contains=vimGroup,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiCtermul,vimHiCtermfont,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation,vimComment,vim9comment
    5              0.000062000 syn region	vimHiKeyList	contained 	start="\i\+" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimHiCluster
    5              0.000026000 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    5              0.000015000  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    5              0.000004000 endif
    5              0.000058000 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    5              0.000052000 syn match	vimHiStartStop	contained	"\c\%(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    5              0.000028000 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    5              0.000065000 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    5              0.000063000 syn match	vimHiCtermul	contained	"\cctermul="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    5              0.000072000 syn match	vimHiCtermfont	contained	"\cctermfont="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    5              0.000028000 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    5              0.000023000 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    5              0.000088000 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    5              0.000046000 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    5              0.000012000 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    5              0.000043000 syn keyword	vimHiClear	contained	clear	skipwhite nextgroup=vimGroup,vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
                            " TODO: simplify and allow line continuations --djk
    5              0.000095000 syn region	vimHiLink	contained matchgroup=Type start="\%(\<hi\%[ghlight]!\=\s\+\)\@<=\%(\%(def\%[ault]\s\+\)\=link\>\|\<def\%[ault]\>\)" skip=+\\\\\|\\|\|\n\s*\\\|\n\s*"\\ + matchgroup=vimCmdSep end="|" excludenl end="$" contains=@vimContinue,@vimHiCluster
                            
                            " Control Characters: {{{2
                            " ==================
    5              0.000018000 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    5              0.000010000 if s:vim9script
                              syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle contained
                              syn match	vim9LineComment	+^[ \t:]*#.*$+	contains=@vimCommentGroup,vimCommentString,vim9CommentTitle
    5              0.000005000 else
    5              0.000071000   syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    5              0.000054000   syn match	vim9LineComment	+^[ \t:]*#.*$+	contains=@vimCommentGroup,vimCommentString,vim9CommentTitle contained
    5              0.000003000 endif
    5              0.000070000 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    5              0.000062000 syn match	vim9CommentTitle	'#\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vim9CommentTitleLeader,vimTodo,@vimCommentGroup
    5              0.000025000 syn match	vimContinue		"^\s*\zs\\"
    5              0.000016000 syn match         vimContinueComment	'^\s*\zs["#]\\ .*' contained
    5              0.000055000 syn cluster	vimContinue contains=vimContinue,vimContinueComment
    5              0.000068000 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    5              0.000012000 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
    5              0.000017000 syn match	vim9CommentTitleLeader	'#\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    5              0.000029000 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    5              0.000016000 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    5              0.000065000 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst1
    5              0.000079000 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst1
                            
                            " Vim9 Script Regions: {{{2
                            " ==================
                            
    5              0.000006000 if s:vim9script
                              syn cluster vimLegacyTop	contains=TOP,vim9LegacyHeader,vim9Comment,vim9LineComment
                              VimFoldH syn region vim9LegacyHeader start="\%^" end="^\ze\s*vim9s\%[cript]\>" contains=@vimLegacyTop,vimComment,vimLineComment
                            
                              syn keyword vim9Vim9ScriptArg	noclear contained
                              syn keyword vim9Vim9Script	vim9s[cript] nextgroup=vim9Vim9ScriptArg skipwhite
    5              0.000002000 endif
                            
                            " Embedded Scripts:  {{{2
                            " ================
                            "   perl,ruby     : Benoit Cerrina
                            "   python,tcl    : Johannes Zellner
                            "   mzscheme, lua : Charles Campbell
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua      (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'p' : embed perl     (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'P' : embed python   (but only if vim supports it)
                            "   g:vimsyn_embed =~# 'r' : embed ruby     (but only if vim supports it)
                            "   g:vimsyn_embed =~# 't' : embed tcl      (but only if vim supports it)
    5              0.000012000 if !exists("g:vimsyn_embed")
                             let g:vimsyn_embed= "lmpPr"
    5              0.000001000 endif
                            
                            " [-- lua --] {{{3
    5              0.000123000 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    5              0.000268000 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
    5              0.000002000 endif
    5              0.000123000 if (g:vimsyn_embed =~# 'l' && has("lua")) && filereadable(s:luapath)
    5              0.000009000  unlet! b:current_syntax
    5              0.000021000  syn cluster vimFuncBodyList	add=vimLuaRegion
    5              0.005134000  exe "syn include @vimLuaScript ".s:luapath
    5              0.000052000  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
    5              0.000040000  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+	contains=@vimLuaScript
    5              0.000015000  syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
                             syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    5              0.000005000 endif
    5              0.000004000 unlet s:luapath
                            
                            " [-- perl --] {{{3
    5              0.000067000 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    5              0.000146000 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
    5              0.000002000 endif
    5              0.000120000 if (g:vimsyn_embed =~# 'p' && has("perl")) && filereadable(s:perlpath)
    5              0.000007000  unlet! b:current_syntax
    5              0.000016000  syn cluster vimFuncBodyList	add=vimPerlRegion
    5              0.015469000  exe "syn include @vimPerlScript ".s:perlpath
    5              0.000059000  VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)\ze\(\s*["#].*\)\=$+ end=+^\z1\ze\(\s*[#"].*\)\=$+	contains=@vimPerlScript
    5              0.000036000  VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+			contains=@vimPerlScript
    5              0.000016000  syn cluster vimFuncBodyList	add=vimPerlRegion
                            else
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    5              0.000003000 endif
    5              0.000005000 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    5              0.000072000 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    5              0.000142000 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
    5              0.000004000 endif
    5              0.000107000 if (g:vimsyn_embed =~# 'r' && has("ruby")) && filereadable(s:rubypath)
    5              0.000016000  syn cluster vimFuncBodyList	add=vimRubyRegion
    5              0.000006000  unlet! b:current_syntax
    5              0.052311000  exe "syn include @vimRubyScript ".s:rubypath
    5              0.000049000  VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimRubyScript
    5              0.000025000  syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+			contains=@vimRubyScript
    5              0.000012000  syn cluster vimFuncBodyList	add=vimRubyRegion
                            else
                             syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    5              0.000003000 endif
    5              0.000006000 unlet s:rubypath
                            
                            " [-- python --] {{{3
    5              0.000079000 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    5              0.000145000 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
    5              0.000003000 endif
    5              0.000103000 if g:vimsyn_embed =~# 'P' && has("pythonx") && filereadable(s:pythonpath)
    5              0.000007000  unlet! b:current_syntax
    5              0.000011000  syn cluster vimFuncBodyList	add=vimPythonRegion
    5              0.003669000  exe "syn include @vimPythonScript ".s:pythonpath
    5              0.000143000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\%(trim\s*\)\=\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
    5              0.000039000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\%(trim\s*\)\=$+ end=+\.$+				contains=@vimPythonScript
    5              0.000037000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\%(trim\s*\)\=\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
    5              0.000031000  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*\%(trim\s*\)\=$+ end=+\.$+				contains=@vimPythonScript
    5              0.000010000  syn cluster vimFuncBodyList	add=vimPythonRegion
                            else
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    5              0.000003000 endif
    5              0.000006000 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    5              0.000029000 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
    5              0.000004000 else
    5              0.000009000  let s:trytcl= 1
    5              0.000004000 endif
    5              0.000004000 if s:trytcl
    5              0.000069000  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    5              0.000129000  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
    5              0.000002000  endif
    5              0.000019000  if (g:vimsyn_embed =~# 't' && has("tcl")) && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
    5              0.000002000  else
    5              0.000020000   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    5              0.000014000   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    5              0.000001000  endif
    5              0.000005000  unlet s:tclpath
                            else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    5              0.000003000 endif
    5              0.000002000 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    5              0.000061000 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    5              0.000107000 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
    5              0.000002000 endif
    5              0.000021000 if (g:vimsyn_embed =~# 'm' && has("mzscheme")) && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
    5              0.000004000 else
    5              0.000018000  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    5              0.000013000  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    5              0.000003000 endif
    5              0.000003000 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    5              0.000008000 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
    5              0.000002000 endif
    5              0.000019000 exe "syn sync maxlines=".s:vimsyn_maxlines
    5              0.000008000 syn sync linecont	"^\s\+\\"
    5              0.000004000 syn sync linebreaks=1
    5              0.000017000 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    5              0.000009000 if !exists("skip_vim_syntax_inits")
    5              0.000008000  if !exists("g:vimsyn_noerror")
    5              0.000015000   hi def link vimBehaveError	vimError
    5              0.000010000   hi def link vimCollClassErr	vimError
    5              0.000013000   hi def link vimErrSetting	vimError
    5              0.000006000   hi def link vimEmbedError	vimError
    5              0.000012000   hi def link vimFTError	vimError
    5              0.000012000   hi def link vimFunctionError	vimError
    5              0.000012000   hi def link vimFunc         	vimError
    5              0.000009000   hi def link vimHiAttribList	vimError
    5              0.000009000   hi def link vimHiCtermError	vimError
    5              0.000008000   hi def link vimHiKeyError	vimError
    5              0.000010000   hi def link vimMapModErr	vimError
    5              0.000011000   hi def link vimSubstFlagErr	vimError
    5              0.000010000   hi def link vimSynCaseError	vimError
    5              0.000010000   hi def link vimSynFoldMethodError	vimError
    5              0.000011000   hi def link vimBufnrWarn	vimWarn
    5              0.000000000  endif
                            
    5              0.000028000  hi def link vim9Vim9ScriptArg	Special
    5              0.000022000  hi def link vimAbb	vimCommand
    5              0.000020000  hi def link vimAddress	vimMark
    5              0.000013000  hi def link vimAugroupBang	vimBang
    5              0.000012000  hi def link vimAugroupError	vimError
    5              0.000019000  hi def link vimAugroupKey	vimCommand
    5              0.000021000  hi def link vimAutoCmd	vimCommand
    5              0.000025000  hi def link vimAutoEvent	Type
    5              0.000023000  hi def link vimAutoCmdMod	Special
    5              0.000013000  hi def link vimBang	vimOper
    5              0.000013000  hi def link vimBehaveBang	vimBang
    5              0.000023000  hi def link vimBehaveModel	vimBehave
    5              0.000022000  hi def link vimBehave	vimCommand
    5              0.000033000  hi def link vimBracket	Delimiter
    5              0.000025000  hi def link vimCmplxRepeat	SpecialChar
    5              0.000026000  hi def link vimCommand	Statement
    5              0.000026000  hi def link vimComment	Comment
    5              0.000026000  hi def link vim9Comment	Comment
    5              0.000020000  hi def link vimCommentString	vimString
    5              0.000033000  hi def link vimCommentTitle	PreProc
    5              0.000026000  hi def link vim9CommentTitle	PreProc
    5              0.000014000  hi def link vimCondHL	vimCommand
    5              0.000019000  hi def link vimConst	vimCommand
    5              0.000032000  hi def link vimContinue	Special
    5              0.000017000  hi def link vimContinueComment	vimComment
    5              0.000022000  hi def link vimCtrlChar	SpecialChar
    5              0.000020000  hi def link vimDefComment	vimComment
    5              0.000019000  hi def link vimDefKey	vimCommand
    5              0.000018000  hi def link vimDefParam vimVar
    5              0.000019000  hi def link vimEcho	vimCommand
    5              0.000017000  hi def link vimEchohlNone	vimGroup
    5              0.000017000  hi def link vimEchohl	vimCommand
    5              0.000022000  hi def link vimElseIfErr	Error
    5              0.000022000  hi def link vimEndfunction	vimCommand
    5              0.000020000  hi def link vimEnddef	vimCommand
    5              0.000026000  hi def link vimEnvvar	PreProc
    5              0.000019000  hi def link vimError	Error
    5              0.000023000  hi def link vimEscape	Special
    5              0.000021000  hi def link vimFBVar	vimVar
    5              0.000013000  hi def link vimFgBgAttrib	vimHiAttrib
    5              0.000017000  hi def link vimFuncEcho	vimCommand
    5              0.000019000  hi def link vimFor	vimCommand
    5              0.000020000  hi def link vimFTCmd	vimCommand
    5              0.000014000  hi def link vimFTOption	vimSynType
    5              0.000010000  hi def link vimFuncBang	vimBang
    5              0.000019000  hi def link vimFuncComment	vimComment
    5              0.000020000  hi def link vimFuncKey	vimCommand
    5              0.000023000  hi def link vimFuncName	Function
    5              0.000026000  hi def link vimFuncMod	Special
    5              0.000019000  hi def link vimFuncParam	vimVar
    5              0.000019000  hi def link vimFuncParamEquals	vimOper
    5              0.000030000  hi def link vimFuncSID	Special
    5              0.000025000  hi def link vimFuncVar	Identifier
    5              0.000010000  hi def link vimGroupAdd	vimSynOption
    5              0.000018000  hi def link vimGroupName	vimGroup
    5              0.000009000  hi def link vimGroupRem	vimSynOption
    5              0.000022000  hi def link vimGroupSpecial	Special
    5              0.000026000  hi def link vimGroup	Type
    5              0.000023000  hi def link vimHiAttrib	PreProc
    5              0.000010000  hi def link vimHiBang	vimBang
    5              0.000021000  hi def link vimHiClear	Type
    5              0.000023000  hi def link vimHiCtermColor	Constant
    5              0.000013000  hi def link vimHiCtermFgBg	vimHiTerm
    5              0.000011000  hi def link vimHiCtermfont	vimHiTerm
    5              0.000010000  hi def link vimHiCtermul	vimHiTerm
    5              0.000014000  hi def link vimHiCTerm	vimHiTerm
    5              0.000020000  hi def link vimHighlight	vimCommand
    5              0.000012000  hi def link vimHiGroup	vimGroupName
    5              0.000012000  hi def link vimHiGuiFgBg	vimHiTerm
    5              0.000011000  hi def link vimHiGuiFont	vimHiTerm
    5              0.000017000  hi def link vimHiGuiRgb	vimNumber
    5              0.000010000  hi def link vimHiGui	vimHiTerm
    5              0.000021000  hi def link vimHiNmbr	Number
    5              0.000012000  hi def link vimHiStartStop	vimHiTerm
    5              0.000020000  hi def link vimHiTerm	Type
    5              0.000023000  hi def link vimHLGroup	vimGroup
    5              0.000018000  hi def link vimInsert	vimString
    5              0.000020000  hi def link vimIskSep	Delimiter
    5              0.000014000  hi def link vim9KeymapLineComment	vimKeymapLineComment
    5              0.000017000  hi def link vimKeymapLineComment	vimComment
    5              0.000019000  hi def link vimKeymapTailComment	vimComment
    5              0.000021000  hi def link vimLet	vimCommand
    5              0.000018000  hi def link vimLetHereDoc	vimString
    5              0.000023000  hi def link vimLetHereDocStart	Special
    5              0.000025000  hi def link vimLetHereDocStop	Special
    5              0.000026000  hi def link vimLetRegister	Special
    5              0.000018000  hi def link vimLineComment	vimComment
    5              0.000018000  hi def link vim9LineComment	vimComment
    5              0.000009000  hi def link vimMapBang	vimBang
    5              0.000031000  hi def link vimMapModKey	vimFuncSID
    5              0.000024000  hi def link vimMapMod	vimBracket
    5              0.000021000  hi def link vimMap	vimCommand
    5              0.000024000  hi def link vimMark	Number
    5              0.000020000  hi def link vimMarkNumber	vimNumber
    5              0.000009000  hi def link vimMenuBang	vimBang
    5              0.000022000  hi def link vimMenuClear	Special
    5              0.000015000  hi def link vimMenuMod	vimMapMod
    5              0.000025000  hi def link vimMenuName	PreProc
    5              0.000021000  hi def link vimMenu	vimCommand
    5              0.000023000  hi def link vimMenuNotation	vimNotation
    5              0.000027000  hi def link vimMenuPriority	Number
    5              0.000023000  hi def link vimMenuStatus	Special
    5              0.000017000  hi def link vimMenutranslateComment	vimComment
    5              0.000020000  hi def link vimMethodName	vimFuncName
    5              0.000014000  hi def link vimMtchComment	vimComment
    5              0.000020000  hi def link vimNorm	vimCommand
    5              0.000032000  hi def link vimNotation	Special
    5              0.000021000  hi def link vimNotFunc	vimCommand
    5              0.000019000  hi def link vimNotPatSep	vimString
    5              0.000023000  hi def link vimNumber	Number
    5              0.000024000  hi def link vimOperError	Error
    5              0.000025000  hi def link vimOper	Operator
    5              0.000028000  hi def link vimOption	PreProc
    5              0.000024000  hi def link vimParenSep	Delimiter
    5              0.000011000  hi def link vimPatSepErr	vimError
    5              0.000018000  hi def link vimPatSepR	vimPatSep
    5              0.000022000  hi def link vimPatSep	SpecialChar
    5              0.000025000  hi def link vimPatSepZone	vimString
    5              0.000015000  hi def link vimPatSepZ	vimPatSep
    5              0.000016000  hi def link vimPattern	Type
    5              0.000019000  hi def link vimPlainMark	vimMark
    5              0.000016000  hi def link vimPlainRegister	vimRegister
    5              0.000025000  hi def link vimRegister	SpecialChar
    5              0.000023000  hi def link vimScriptDelim	Comment
    5              0.000021000  hi def link vimSearchDelim	Statement
    5              0.000019000  hi def link vimSearch	vimString
    5              0.000031000  hi def link vimSep	Delimiter
    5              0.000021000  hi def link vimSetMod	vimOption
    5              0.000036000  hi def link vimSetSep	Statement
    5              0.000019000  hi def link vimSetString	vimString
    5              0.000025000  hi def link vim9Vim9Script	vimCommand
    5              0.000021000  hi def link vimSpecFile	Identifier
    5              0.000020000  hi def link vimSpecFileMod	vimSpecFile
    5              0.000018000  hi def link vimSpecial	Type
    5              0.000019000  hi def link vimStringCont	vimString
    5              0.000025000  hi def link vimString	String
    5              0.000019000  hi def link vimStringEnd	vimString
    5              0.000016000  hi def link vimStringInterpolationBrace	vimEscape
    5              0.000020000  hi def link vimSubst1	vimSubst
    5              0.000022000  hi def link vimSubstDelim	Delimiter
    5              0.000024000  hi def link vimSubstFlags	Special
    5              0.000024000  hi def link vimSubstSubstr	SpecialChar
    5              0.000018000  hi def link vimSubstTwoBS	vimString
    5              0.000018000  hi def link vimSubst	vimCommand
    5              0.000022000  hi def link vimSynCaseError	Error
    5              0.000026000  hi def link vimSynCase	Type
    5              0.000022000  hi def link vimSyncC	Type
    5              0.000022000  hi def link vimSyncError	Error
    5              0.000015000  hi def link vimSyncGroupName	vimGroupName
    5              0.000012000  hi def link vimSyncGroup	vimGroupName
    5              0.000021000  hi def link vimSyncKey	Type
    5              0.000022000  hi def link vimSyncNone	Type
    5              0.000011000  hi def link vimSynContains	vimSynOption
    5              0.000022000  hi def link vimSynError	Error
    5              0.000023000  hi def link vimSynFoldMethodError	Error
    5              0.000022000  hi def link vimSynFoldMethod	Type
    5              0.000016000  hi def link vimSynKeyContainedin	vimSynContains
    5              0.000008000  hi def link vimSynKeyOpt	vimSynOption
    5              0.000010000  hi def link vimSynCchar	vimSynOption
    5              0.000023000  hi def link vimSynCcharValue	Character
    5              0.000011000  hi def link vimSynMtchGrp	vimSynOption
    5              0.000008000  hi def link vimSynMtchOpt	vimSynOption
    5              0.000009000  hi def link vimSynNextgroup	vimSynOption
    5              0.000012000  hi def link vimSynNotPatRange	vimSynRegPat
    5              0.000018000  hi def link vimSynOption	Special
    5              0.000017000  hi def link vimSynPatRange	vimString
    5              0.000010000  hi def link vimSynRegOpt	vimSynOption
    5              0.000015000  hi def link vimSynRegPat	vimString
    5              0.000026000  hi def link vimSynReg	Type
    5              0.000023000  hi def link vimSyntax	vimCommand
    5              0.000009000  hi def link vimSynType	vimSpecial
    5              0.000026000  hi def link vimTodo	Todo
    5              0.000024000  hi def link vimType	Type
    5              0.000021000  hi def link vimUnlet	vimCommand
    5              0.000010000  hi def link vimUnletBang	vimBang
    5              0.000020000  hi def link vimUnmap	vimMap
    5              0.000023000  hi def link vimUserAttrbCmpltFunc	Special
    5              0.000013000  hi def link vimUserAttrbCmplt	vimSpecial
    5              0.000019000  hi def link vimUserAttrbKey	vimOption
    5              0.000011000  hi def link vimUserAttrb	vimSpecial
    5              0.000024000  hi def link vimUserAttrbError	Error
    5              0.000022000  hi def link vimUserCmdError	Error
    5              0.000019000  hi def link vimUserCommand	vimCommand
    5              0.000021000  hi def link vimUserFunc	Normal
    5              0.000023000  hi def link vimVar	Identifier
    5              0.000021000  hi def link vimWarn	WarningMsg
    5              0.000003000 endif
                            
                            " Current Syntax Variable: {{{2
    5              0.000007000 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    5              0.000014000 delc VimFolda
    5              0.000008000 delc VimFoldf
    5              0.000005000 delc VimFoldh
    5              0.000006000 delc VimFoldH
    5              0.000005000 delc VimFoldl
    5              0.000005000 delc VimFoldm
    5              0.000006000 delc VimFoldp
    5              0.000006000 delc VimFoldP
    5              0.000005000 delc VimFoldr
    5              0.000005000 delc VimFoldt
    5              0.000012000 let &cpo = s:keepcpo
    5              0.000007000 unlet s:keepcpo s:vim9script
                            " vim:ts=18 fdm=marker ft=vim

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/lua.vim
Sourced 5 times
Total time:   0.004577000
 Self time:   0.004577000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
                            " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:  2022 Sep 07
                            " Options:      lua_version = 4 or 5
                            "               lua_subversion = 0 (for 4.0 or 5.0)
                            "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
                            "               the default is 5.3
                            
                            " quit when a syntax file was already loaded
    5              0.000021000 if exists("b:current_syntax")
                              finish
    5              0.000003000 endif
                            
    5              0.000016000 let s:cpo_save = &cpo
    5              0.000020000 set cpo&vim
                            
    5              0.000011000 if !exists("lua_version")
                              " Default is lua 5.3
                              let lua_version = 5
                              let lua_subversion = 3
    5              0.000008000 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    5              0.000005000 endif
                            
    5              0.000003000 syn case match
                            
                            " syncing method
    5              0.000006000 syn sync minlines=1000
                            
    5              0.000006000 if lua_version >= 5
    5              0.000018000   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
    5              0.000018000   syn keyword luaMetaMethod __eq __lt __le
    5              0.000011000   syn keyword luaMetaMethod __index __newindex __call
    5              0.000011000   syn keyword luaMetaMethod __metatable __mode __gc __tostring
    5              0.000003000 endif
                            
    5              0.000010000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
    5              0.000010000   syn keyword luaMetaMethod __mod __len
    5              0.000004000 endif
                            
    5              0.000009000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    5              0.000013000   syn keyword luaMetaMethod __pairs
    5              0.000004000 endif
                            
    5              0.000008000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
    5              0.000010000   syn keyword luaMetaMethod __idiv __name
    5              0.000013000   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
    5              0.000003000 endif
                            
    5              0.000008000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
                              syn keyword luaMetaMethod __close
    5              0.000002000 endif
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
                            
    5              0.000027000 syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
    5              0.000014000 syn match  luaParenError ")"
    5              0.000020000 syn match  luaError "}"
    5              0.000026000 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " Function declaration
    5              0.000035000 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
                            
                            " else
    5              0.000024000 syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
                            
                            " then ... end
    5              0.000022000 syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
                            
                            " elseif ... then
    5              0.000034000 syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
                            
                            " if ... then
    5              0.000032000 syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
                            
                            " do ... end
    5              0.000022000 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
                            " repeat ... until
    5              0.000024000 syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
                            
                            " while ... do
    5              0.000033000 syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    5              0.000028000 syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
    5              0.000017000 syn keyword luaFor contained containedin=luaFor in
                            
                            " other keywords
    5              0.000013000 syn keyword luaStatement return local break
    5              0.000008000 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    5              0.000011000   syn keyword luaStatement goto
    5              0.000013000   syn match luaLabel "::\I\i*::"
    5              0.000003000 endif
                            
                            " operators
    5              0.000011000 syn keyword luaOperator and or not
                            
    5              0.000007000 if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
    5              0.000018000   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
                            elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
                              syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
                            else
                              syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
    5              0.000000000 endif
                            
                            " comments
    5              0.000010000 syn keyword luaTodo            contained TODO FIXME XXX
    5              0.000027000 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    5              0.000016000 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    5              0.000008000 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    5              0.000037000   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    5              0.000002000 endif
                            
                            " first line may start with #!
    5              0.000011000 syn match luaComment "\%^#!.*"
                            
    5              0.000010000 syn keyword luaConstant nil
    5              0.000004000 if lua_version > 4
    5              0.000013000   syn keyword luaConstant true false
    5              0.000001000 endif
                            
                            " strings
    5              0.000024000 syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
    5              0.000005000 if lua_version == 5
    5              0.000006000   if lua_subversion == 0
                                syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    5              0.000003000   else
    5              0.000006000     if lua_subversion >= 2
    5              0.000022000       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
    5              0.000005000     endif
    5              0.000005000     if lua_subversion >= 3
    5              0.000014000       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
    5              0.000002000     endif
    5              0.000026000     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    5              0.000001000   endif
    5              0.000003000 endif
    5              0.000035000 syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    5              0.000042000 syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    5              0.000014000 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    5              0.000021000 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
                            " floating point number, starting with a dot, optional exponent
    5              0.000016000 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    5              0.000027000 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    5              0.000005000 if lua_version >= 5
    5              0.000006000   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    5              0.000006000   elseif lua_subversion >= 2
    5              0.000020000     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    5              0.000004000   endif
    5              0.000002000 endif
                            
                            " tables
    5              0.000039000 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
                            
                            " methods
    5              0.000018000 syntax match luaFunc ":\@<=\k\+"
                            
                            " built-in functions
    5              0.000016000 syn keyword luaFunc assert collectgarbage dofile error next
    5              0.000018000 syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
                            
    5              0.000004000 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    5              0.000005000 elseif lua_version == 5
    5              0.000014000   syn keyword luaFunc getmetatable setmetatable
    5              0.000010000   syn keyword luaFunc ipairs pairs
    5              0.000009000   syn keyword luaFunc pcall xpcall
    5              0.000012000   syn keyword luaFunc _G loadfile rawequal require
    5              0.000004000   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    5              0.000002000   else
    5              0.000010000     syn keyword luaFunc load select
    5              0.000014000     syn match   luaFunc /\<package\.cpath\>/
    5              0.000014000     syn match   luaFunc /\<package\.loaded\>/
    5              0.000014000     syn match   luaFunc /\<package\.loadlib\>/
    5              0.000013000     syn match   luaFunc /\<package\.path\>/
    5              0.000015000     syn match   luaFunc /\<package\.preload\>/
    5              0.000005000     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    5              0.000005000     elseif lua_subversion >= 2
    5              0.000012000       syn keyword luaFunc _ENV rawlen
    5              0.000012000       syn match   luaFunc /\<package\.config\>/
    5              0.000034000       syn match   luaFunc /\<package\.preload\>/
    5              0.000014000       syn match   luaFunc /\<package\.searchers\>/
    5              0.000015000       syn match   luaFunc /\<package\.searchpath\>/
    5              0.000003000     endif
                            
    5              0.000005000     if lua_subversion >= 3
    5              0.000016000       syn match luaFunc /\<coroutine\.isyieldable\>/
    5              0.000002000     endif
    5              0.000005000     if lua_subversion >= 4
                                  syn keyword luaFunc warn
                                  syn match luaFunc /\<coroutine\.close\>/
    5              0.000003000     endif
    5              0.000013000     syn match luaFunc /\<coroutine\.running\>/
    5              0.000002000   endif
    5              0.000015000   syn match   luaFunc /\<coroutine\.create\>/
    5              0.000027000   syn match   luaFunc /\<coroutine\.resume\>/
    5              0.000014000   syn match   luaFunc /\<coroutine\.status\>/
    5              0.000020000   syn match   luaFunc /\<coroutine\.wrap\>/
    5              0.000013000   syn match   luaFunc /\<coroutine\.yield\>/
                            
    5              0.000014000   syn match   luaFunc /\<string\.byte\>/
    5              0.000012000   syn match   luaFunc /\<string\.char\>/
    5              0.000016000   syn match   luaFunc /\<string\.dump\>/
    5              0.000014000   syn match   luaFunc /\<string\.find\>/
    5              0.000013000   syn match   luaFunc /\<string\.format\>/
    5              0.000014000   syn match   luaFunc /\<string\.gsub\>/
    5              0.000014000   syn match   luaFunc /\<string\.len\>/
    5              0.000013000   syn match   luaFunc /\<string\.lower\>/
    5              0.000016000   syn match   luaFunc /\<string\.rep\>/
    5              0.000013000   syn match   luaFunc /\<string\.sub\>/
    5              0.000013000   syn match   luaFunc /\<string\.upper\>/
    5              0.000004000   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    5              0.000003000   else
    5              0.000013000     syn match luaFunc /\<string\.gmatch\>/
    5              0.000014000     syn match luaFunc /\<string\.match\>/
    5              0.000013000     syn match luaFunc /\<string\.reverse\>/
    5              0.000003000   endif
    5              0.000005000   if lua_subversion >= 3
    5              0.000011000     syn match luaFunc /\<string\.pack\>/
    5              0.000021000     syn match luaFunc /\<string\.packsize\>/
    5              0.000014000     syn match luaFunc /\<string\.unpack\>/
    5              0.000013000     syn match luaFunc /\<utf8\.char\>/
    5              0.000016000     syn match luaFunc /\<utf8\.charpattern\>/
    5              0.000011000     syn match luaFunc /\<utf8\.codes\>/
    5              0.000014000     syn match luaFunc /\<utf8\.codepoint\>/
    5              0.000011000     syn match luaFunc /\<utf8\.len\>/
    5              0.000011000     syn match luaFunc /\<utf8\.offset\>/
    5              0.000003000   endif
                            
    5              0.000004000   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    5              0.000005000   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    5              0.000005000   elseif lua_subversion >= 2
    5              0.000039000     syn match luaFunc /\<table\.pack\>/
    5              0.000012000     syn match luaFunc /\<table\.unpack\>/
    5              0.000006000     if lua_subversion >= 3
    5              0.000011000       syn match luaFunc /\<table\.move\>/
    5              0.000002000     endif
    5              0.000002000   endif
    5              0.000013000   syn match   luaFunc /\<table\.concat\>/
    5              0.000013000   syn match   luaFunc /\<table\.insert\>/
    5              0.000014000   syn match   luaFunc /\<table\.sort\>/
    5              0.000013000   syn match   luaFunc /\<table\.remove\>/
                            
    5              0.000003000   if lua_subversion == 2
                                syn match   luaFunc /\<bit32\.arshift\>/
                                syn match   luaFunc /\<bit32\.band\>/
                                syn match   luaFunc /\<bit32\.bnot\>/
                                syn match   luaFunc /\<bit32\.bor\>/
                                syn match   luaFunc /\<bit32\.btest\>/
                                syn match   luaFunc /\<bit32\.bxor\>/
                                syn match   luaFunc /\<bit32\.extract\>/
                                syn match   luaFunc /\<bit32\.lrotate\>/
                                syn match   luaFunc /\<bit32\.lshift\>/
                                syn match   luaFunc /\<bit32\.replace\>/
                                syn match   luaFunc /\<bit32\.rrotate\>/
                                syn match   luaFunc /\<bit32\.rshift\>/
    5              0.000001000   endif
                            
    5              0.000015000   syn match   luaFunc /\<math\.abs\>/
    5              0.000013000   syn match   luaFunc /\<math\.acos\>/
    5              0.000011000   syn match   luaFunc /\<math\.asin\>/
    5              0.000014000   syn match   luaFunc /\<math\.atan\>/
    5              0.000005000   if lua_subversion < 3
                                syn match   luaFunc /\<math\.atan2\>/
    5              0.000002000   endif
    5              0.000011000   syn match   luaFunc /\<math\.ceil\>/
    5              0.000012000   syn match   luaFunc /\<math\.sin\>/
    5              0.000010000   syn match   luaFunc /\<math\.cos\>/
    5              0.000013000   syn match   luaFunc /\<math\.tan\>/
    5              0.000010000   syn match   luaFunc /\<math\.deg\>/
    5              0.000010000   syn match   luaFunc /\<math\.exp\>/
    5              0.000012000   syn match   luaFunc /\<math\.floor\>/
    5              0.000013000   syn match   luaFunc /\<math\.log\>/
    5              0.000012000   syn match   luaFunc /\<math\.max\>/
    5              0.000023000   syn match   luaFunc /\<math\.min\>/
    5              0.000004000   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    5              0.000004000   elseif lua_subversion == 1
                                syn match luaFunc /\<math\.log10\>/
    5              0.000003000   endif
    5              0.000003000   if lua_subversion >= 1
    5              0.000012000     syn match luaFunc /\<math\.huge\>/
    5              0.000013000     syn match luaFunc /\<math\.fmod\>/
    5              0.000010000     syn match luaFunc /\<math\.modf\>/
    5              0.000007000     if lua_subversion == 1 || lua_subversion == 2
                                  syn match luaFunc /\<math\.cosh\>/
                                  syn match luaFunc /\<math\.sinh\>/
                                  syn match luaFunc /\<math\.tanh\>/
    5              0.000003000     endif
    5              0.000002000   endif
    5              0.000010000   syn match   luaFunc /\<math\.rad\>/
    5              0.000011000   syn match   luaFunc /\<math\.sqrt\>/
    5              0.000005000   if lua_subversion < 3
                                syn match   luaFunc /\<math\.pow\>/
                                syn match   luaFunc /\<math\.frexp\>/
                                syn match   luaFunc /\<math\.ldexp\>/
    5              0.000004000   else
    5              0.000014000     syn match   luaFunc /\<math\.maxinteger\>/
    5              0.000016000     syn match   luaFunc /\<math\.mininteger\>/
    5              0.000022000     syn match   luaFunc /\<math\.tointeger\>/
    5              0.000011000     syn match   luaFunc /\<math\.type\>/
    5              0.000009000     syn match   luaFunc /\<math\.ult\>/
    5              0.000004000   endif
    5              0.000013000   syn match   luaFunc /\<math\.random\>/
    5              0.000014000   syn match   luaFunc /\<math\.randomseed\>/
    5              0.000014000   syn match   luaFunc /\<math\.pi\>/
                            
    5              0.000010000   syn match   luaFunc /\<io\.close\>/
    5              0.000009000   syn match   luaFunc /\<io\.flush\>/
    5              0.000014000   syn match   luaFunc /\<io\.input\>/
    5              0.000011000   syn match   luaFunc /\<io\.lines\>/
    5              0.000012000   syn match   luaFunc /\<io\.open\>/
    5              0.000011000   syn match   luaFunc /\<io\.output\>/
    5              0.000009000   syn match   luaFunc /\<io\.popen\>/
    5              0.000011000   syn match   luaFunc /\<io\.read\>/
    5              0.000013000   syn match   luaFunc /\<io\.stderr\>/
    5              0.000012000   syn match   luaFunc /\<io\.stdin\>/
    5              0.000010000   syn match   luaFunc /\<io\.stdout\>/
    5              0.000011000   syn match   luaFunc /\<io\.tmpfile\>/
    5              0.000011000   syn match   luaFunc /\<io\.type\>/
    5              0.000011000   syn match   luaFunc /\<io\.write\>/
                            
    5              0.000012000   syn match   luaFunc /\<os\.clock\>/
    5              0.000010000   syn match   luaFunc /\<os\.date\>/
    5              0.000015000   syn match   luaFunc /\<os\.difftime\>/
    5              0.000011000   syn match   luaFunc /\<os\.execute\>/
    5              0.000012000   syn match   luaFunc /\<os\.exit\>/
    5              0.000010000   syn match   luaFunc /\<os\.getenv\>/
    5              0.000013000   syn match   luaFunc /\<os\.remove\>/
    5              0.000011000   syn match   luaFunc /\<os\.rename\>/
    5              0.000013000   syn match   luaFunc /\<os\.setlocale\>/
    5              0.000020000   syn match   luaFunc /\<os\.time\>/
    5              0.000012000   syn match   luaFunc /\<os\.tmpname\>/
                            
    5              0.000015000   syn match   luaFunc /\<debug\.debug\>/
    5              0.000013000   syn match   luaFunc /\<debug\.gethook\>/
    5              0.000014000   syn match   luaFunc /\<debug\.getinfo\>/
    5              0.000013000   syn match   luaFunc /\<debug\.getlocal\>/
    5              0.000018000   syn match   luaFunc /\<debug\.getupvalue\>/
    5              0.000013000   syn match   luaFunc /\<debug\.setlocal\>/
    5              0.000013000   syn match   luaFunc /\<debug\.setupvalue\>/
    5              0.000012000   syn match   luaFunc /\<debug\.sethook\>/
    5              0.000015000   syn match   luaFunc /\<debug\.traceback\>/
    5              0.000005000   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
    5              0.000003000   endif
    5              0.000004000   if lua_subversion >= 1
    5              0.000022000     syn match luaFunc /\<debug\.getmetatable\>/
    5              0.000014000     syn match luaFunc /\<debug\.setmetatable\>/
    5              0.000026000     syn match luaFunc /\<debug\.getregistry\>/
    5              0.000005000     if lua_subversion >= 2
    5              0.000017000       syn match luaFunc /\<debug\.getuservalue\>/
    5              0.000014000       syn match luaFunc /\<debug\.setuservalue\>/
    5              0.000015000       syn match luaFunc /\<debug\.upvalueid\>/
    5              0.000014000       syn match luaFunc /\<debug\.upvaluejoin\>/
    5              0.000004000     endif
    5              0.000004000     if lua_subversion >= 4
                                  syn match luaFunc /\<debug.setcstacklimit\>/
    5              0.000001000     endif
    5              0.000003000   endif
    5              0.000003000 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    5              0.000029000 hi def link luaStatement        Statement
    5              0.000026000 hi def link luaRepeat           Repeat
    5              0.000023000 hi def link luaFor              Repeat
    5              0.000024000 hi def link luaString           String
    5              0.000024000 hi def link luaString2          String
    5              0.000012000 hi def link luaStringDelimiter  luaString
    5              0.000022000 hi def link luaNumber           Number
    5              0.000023000 hi def link luaOperator         Operator
    5              0.000021000 hi def link luaSymbolOperator   luaOperator
    5              0.000023000 hi def link luaConstant         Constant
    5              0.000024000 hi def link luaCond             Conditional
    5              0.000026000 hi def link luaCondElse         Conditional
    5              0.000029000 hi def link luaFunction         Function
    5              0.000024000 hi def link luaMetaMethod       Function
    5              0.000024000 hi def link luaComment          Comment
    5              0.000024000 hi def link luaCommentDelimiter luaComment
    5              0.000022000 hi def link luaTodo             Todo
    5              0.000030000 hi def link luaTable            Structure
    5              0.000025000 hi def link luaError            Error
    5              0.000031000 hi def link luaParenError       Error
    5              0.000023000 hi def link luaSpecial          SpecialChar
    5              0.000023000 hi def link luaFunc             Identifier
    5              0.000023000 hi def link luaLabel            Label
                            
                            
    5              0.000009000 let b:current_syntax = "lua"
                            
    5              0.000017000 let &cpo = s:cpo_save
    5              0.000005000 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/perl.vim
Sourced 5 times
Total time:   0.015002000
 Self time:   0.015002000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:      Perl
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Homepage:      https://github.com/vim-perl/vim-perl
                            " Bugs/requests: https://github.com/vim-perl/vim-perl/issues
                            " License:       Vim License (see :help license)
                            " Last Change:   2022 Jun 13
                            " Contributors:  Andy Lester <andy@petdance.com>
                            "                Hinrik Örn Sigurðsson <hinrik.sig@gmail.com>
                            "                Lukas Mai <l.mai.web.de>
                            "                Nick Hibma <nick@van-laarhoven.org>
                            "                Sonia Heimann <niania@netsurf.org>
                            "                Rob Hoelz <rob@hoelz.ro>
                            "                Doug Kearns <dougkearns@gmail.com>
                            "                and many others.
                            "
                            " Please download the most recent version first, before mailing
                            " any comments.
                            "
                            " The following parameters are available for tuning the
                            " perl syntax highlighting, with defaults given:
                            "
                            " let perl_include_pod = 1
                            " unlet perl_no_scope_in_variables
                            " unlet perl_no_extended_vars
                            " unlet perl_string_as_statement
                            " unlet perl_no_sync_on_sub
                            " unlet perl_no_sync_on_global_var
                            " let perl_sync_dist = 100
                            " unlet perl_fold
                            " unlet perl_fold_blocks
                            " unlet perl_nofold_packages
                            " unlet perl_nofold_subs
                            " unlet perl_fold_anonymous_subs
                            " unlet perl_no_subprototype_error
                            
    5              0.000017000 if exists("b:current_syntax")
                              finish
    5              0.000002000 endif
                            
    5              0.000009000 let s:cpo_save = &cpo
    5              0.000012000 set cpo&vim
                            
                            " POD starts with ^=<word> and ends with ^=cut
                            
    5              0.000013000 if get(g:, 'perl_include_pod', 1)
                              " Include a while extra syntax file
    5              0.004055000   syn include @Pod syntax/pod.vim
    5              0.000006000   unlet b:current_syntax
    5              0.000011000   if get(g:, 'perl_fold', 1)
    5              0.000036000     syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend fold extend
    5              0.000030000     syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend fold extend
                              else
                                syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend
                                syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend
    5              0.000001000   endif
                            else
                              " Use only the bare minimum of rules
                              if get(g:, 'perl_fold', 1)
                                syn region perlPOD start="^=[a-z]" end="^=cut" fold
                              else
                                syn region perlPOD start="^=[a-z]" end="^=cut"
                              endif
    5              0.000002000 endif
                            
                            
    5              0.000006000 syn cluster perlTop		contains=TOP
                            
    5              0.000014000 syn region perlBraces start="{" end="}" transparent extend
                            
                            " All keywords
                            "
    5              0.000026000 syn match perlConditional		"\<\%(if\|elsif\|unless\|given\|when\|default\)\>"
    5              0.000031000 syn match perlConditional		"\<else\%(\%(\_s\*if\>\)\|\>\)" contains=perlElseIfError skipwhite skipnl skipempty
    5              0.000025000 syn match perlRepeat			"\<\%(while\|for\%(each\)\=\|do\|until\|continue\)\>"
    5              0.000030000 syn match perlOperator			"\<\%(defined\|undef\|eq\|ne\|[gl][et]\|cmp\|not\|and\|or\|xor\|not\|bless\|ref\|do\)\>"
                            " for some reason, adding this as the nextgroup for perlControl fixes BEGIN
                            " folding issues...
    5              0.000011000 syn match perlFakeGroup 		"" contained
    5              0.000032000 syn match perlControl			"\<\%(BEGIN\|CHECK\|INIT\|END\|UNITCHECK\)\>\_s*" nextgroup=perlFakeGroup
                            
    5              0.000018000 syn match perlStatementStorage		"\<\%(my\|our\|local\|state\)\>"
    5              0.000020000 syn match perlStatementControl		"\<\%(return\|last\|next\|redo\|goto\|break\)\>"
    5              0.000036000 syn match perlStatementScalar		"\<\%(chom\=p\|chr\|crypt\|r\=index\|lc\%(first\)\=\|length\|ord\|pack\|sprintf\|substr\|fc\|uc\%(first\)\=\)\>"
    5              0.000017000 syn match perlStatementRegexp		"\<\%(pos\|quotemeta\|split\|study\)\>"
    5              0.000026000 syn match perlStatementNumeric		"\<\%(abs\|atan2\|cos\|exp\|hex\|int\|log\|oct\|rand\|sin\|sqrt\|srand\)\>"
    5              0.000027000 syn match perlStatementList		"\<\%(splice\|unshift\|shift\|push\|pop\|join\|reverse\|grep\|map\|sort\|unpack\)\>"
    5              0.000019000 syn match perlStatementHash		"\<\%(delete\|each\|exists\|keys\|values\)\>"
    5              0.000018000 syn match perlStatementIOfunc		"\<\%(syscall\|dbmopen\|dbmclose\)\>"
    5              0.000057000 syn match perlStatementFiledesc		"\<\%(binmode\|close\%(dir\)\=\|eof\|fileno\|getc\|lstat\|printf\=\|read\%(dir\|line\|pipe\)\|rewinddir\|say\|select\|stat\|tell\%(dir\)\=\|write\)\>" nextgroup=perlFiledescStatementNocomma skipwhite
    5              0.000044000 syn match perlStatementFiledesc		"\<\%(fcntl\|flock\|ioctl\|open\%(dir\)\=\|read\|seek\%(dir\)\=\|sys\%(open\|read\|seek\|write\)\|truncate\)\>" nextgroup=perlFiledescStatementComma skipwhite
    5              0.000020000 syn match perlStatementVector		"\<vec\>"
    5              0.000033000 syn match perlStatementFiles		"\<\%(ch\%(dir\|mod\|own\|root\)\|glob\|link\|mkdir\|readlink\|rename\|rmdir\|symlink\|umask\|unlink\|utime\)\>"
    5              0.000019000 syn match perlStatementFiles		"-[rwxoRWXOezsfdlpSbctugkTBMAC]\>"
    5              0.000024000 syn match perlStatementFlow		"\<\%(caller\|die\|dump\|eval\|exit\|wantarray\|evalbytes\)\>"
    5              0.000019000 syn match perlStatementInclude		"\<\%(require\|import\|unimport\)\>"
    5              0.000108000 syn match perlStatementInclude		"\<\%(use\|no\)\s\+\%(\%(attributes\|attrs\|autodie\%(::\%(exception\%(::system\)\=\|hints\|skip\)\)\=\|autouse\|parent\|base\|big\%(int\|num\|rat\)\|blib\|bytes\|charnames\|constant\|deprecate\|diagnostics\|encoding\%(::warnings\)\=\|experimental\|feature\|fields\|filetest\|if\|integer\|less\|lib\|locale\|mro\|ok\|open\|ops\|overload\|overloading\|re\|sigtrap\|sort\|strict\|subs\|threads\%(::shared\)\=\|utf8\|vars\|version\|vmsish\|warnings\%(::register\)\=\)\>\)\="
    5              0.000042000 syn match perlStatementProc		"\<\%(alarm\|exec\|fork\|get\%(pgrp\|ppid\|priority\)\|kill\|pipe\|set\%(pgrp\|priority\)\|sleep\|system\|times\|wait\%(pid\)\=\)\>"
    5              0.000035000 syn match perlStatementSocket		"\<\%(accept\|bind\|connect\|get\%(peername\|sock\%(name\|opt\)\)\|listen\|recv\|send\|setsockopt\|shutdown\|socket\%(pair\)\=\)\>"
    5              0.000032000 syn match perlStatementIPC		"\<\%(msg\%(ctl\|get\|rcv\|snd\)\|sem\%(ctl\|get\|op\)\|shm\%(ctl\|get\|read\|write\)\)\>"
    5              0.000040000 syn match perlStatementNetwork		"\<\%(\%(end\|[gs]et\)\%(host\|net\|proto\|serv\)ent\|get\%(\%(host\|net\)by\%(addr\|name\)\|protoby\%(name\|number\)\|servby\%(name\|port\)\)\)\>"
    5              0.000035000 syn match perlStatementPword		"\<\%(get\%(pw\%(uid\|nam\)\|gr\%(gid\|nam\)\|login\)\)\|\%(end\|[gs]et\)\%(pw\|gr\)ent\>"
    5              0.000017000 syn match perlStatementTime		"\<\%(gmtime\|localtime\|time\)\>"
                            
    5              0.000029000 syn match perlStatementMisc		"\<\%(warn\|format\|formline\|reset\|scalar\|prototype\|lock\|tied\=\|untie\)\>"
                            
    5              0.000017000 syn keyword perlTodo			TODO TODO: TBD TBD: FIXME FIXME: XXX XXX: NOTE NOTE: contained
                            
    5              0.000040000 syn region perlStatementIndirObjWrap   matchgroup=perlStatementIndirObj start="\%(\<\%(map\|grep\|sort\|printf\=\|say\|system\|exec\)\>\s*\)\@<={" end="}" transparent extend
                            
    5              0.000027000 syn match perlLabel      "^\s*\h\w*\s*::\@!\%(\<v\d\+\s*:\)\@<!"
                            
                            " Perl Identifiers.
                            "
                            " Should be cleaned up to better handle identifiers in particular situations
                            " (in hash keys for example)
                            "
                            " Plain identifiers: $foo, @foo, $#foo, %foo, &foo and dereferences $$foo, @$foo, etc.
                            " We do not process complex things such as @{${"foo"}}. Too complicated, and
                            " too slow. And what is after the -> is *not* considered as part of the
                            " variable - there again, too complicated and too slow.
                            
                            " Special variables first ($^A, ...) and ($|, $', ...)
    5              0.000016000 syn match  perlVarPlain		 "$^[ACDEFHILMNOPRSTVWX]\="
    5              0.000024000 syn match  perlVarPlain		 "$[\\\"\[\]'&`+*.,;=%~!?@#$<>(-]"
    5              0.000013000 syn match  perlVarPlain		 "@[-+]"
    5              0.000015000 syn match  perlVarPlain		 "$\%(0\|[1-9]\d*\)"
                            " Same as above, but avoids confusion in $::foo (equivalent to $main::foo)
    5              0.000012000 syn match  perlVarPlain		 "$::\@!"
                            " These variables are not recognized within matches.
    5              0.000014000 syn match  perlVarNotInMatches	 "$[|)]"
                            " This variable is not recognized within matches delimited by m//.
    5              0.000012000 syn match  perlVarSlash		 "$/"
                            
                            " And plain identifiers
    5              0.000026000 syn match  perlPackageRef	 "[$@#%*&]\%(\%(::\|'\)\=\I\i*\%(\%(::\|'\)\I\i*\)*\)\=\%(::\|'\)\I"ms=s+1,me=e-1 contained
                            
                            " To not highlight packages in variables as a scope reference - i.e. in
                            " $pack::var, pack:: is a scope, just set "perl_no_scope_in_variables"
                            " If you don't want complex things like @{${"foo"}} to be processed,
                            " just set the variable "perl_no_extended_vars"...
                            
    5              0.000010000 if !get(g:, 'perl_no_scope_in_variables', 0)
    5              0.000065000   syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
    5              0.000060000   syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
    5              0.000058000   syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
                            else
                              syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
                              syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
                              syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref
    5              0.000004000 endif
                            
    5              0.000013000 syn match  perlVarPlain2	 "%[-+]"
                            
    5              0.000014000 if !get(g:, 'perl_no_extended_vars', 0)
    5              0.000258000   syn cluster perlExpr		contains=perlStatementIndirObjWrap,perlStatementScalar,perlStatementRegexp,perlStatementNumeric,perlStatementList,perlStatementHash,perlStatementFiles,perlStatementTime,perlStatementMisc,perlVarPlain,perlVarPlain2,perlVarNotInMatches,perlVarSlash,perlVarBlock,perlVarBlock2,perlShellCommand,perlFloat,perlNumber,perlStringUnexpanded,perlString,perlQ,perlQQ,perlQW,perlQR,perlArrow,perlBraces
    5              0.000050000   syn region perlArrow		matchgroup=perlArrow start="->\s*(" end=")" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contained
    5              0.000050000   syn region perlArrow		matchgroup=perlArrow start="->\s*\[" end="\]" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contained
    5              0.000048000   syn region perlArrow		matchgroup=perlArrow start="->\s*{" end="}" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contained
    5              0.000053000   syn match  perlArrow		"->\s*{\s*\I\i*\s*}" contains=perlVarSimpleMemberName nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contained
    5              0.000065000   syn region perlVarBlock	matchgroup=perlVarPlain start="\%($#\|[$@]\)\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    5              0.000064000   syn region perlVarBlock2	matchgroup=perlVarPlain start="[%&*]\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    5              0.000044000   syn match  perlVarPlain2	"[%&*]\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    5              0.000048000   syn match  perlVarPlain	"\%(\$#\|[@$]\)\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    5              0.000058000   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\={" skip="\\}" end="}" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    5              0.000054000   syn match  perlVarSimpleMember	"\%(->\)\={\s*\I\i*\s*}" nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref contains=perlVarSimpleMemberName contained extend
    5              0.000012000   syn match  perlVarSimpleMemberName	"\I\i*" contained
    5              0.000054000   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\=\[" skip="\\]" end="]" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlPostDeref extend
    5              0.000023000   syn match perlPackageConst	"__PACKAGE__" nextgroup=perlPostDeref
    5              0.000044000   syn match  perlPostDeref	"->\%($#\|[$@%&*]\)\*" contained nextgroup=perlVarSimpleMember,perlVarMember,perlPostDeref
    5              0.000063000   syn region  perlPostDeref	start="->\%($#\|[$@%&*]\)\[" skip="\\]" end="]" contained contains=@perlExpr nextgroup=perlVarSimpleMember,perlVarMember,perlPostDeref
    5              0.000058000   syn region  perlPostDeref	matchgroup=perlPostDeref start="->\%($#\|[$@%&*]\){" skip="\\}" end="}" keepend extend contained contains=@perlExpr nextgroup=perlVarSimpleMember,perlVarMember,perlPostDeref
    5              0.000001000 endif
                            
                            " File Descriptors
    5              0.000015000 syn match  perlFiledescRead	"<\h\w*>"
                            
    5              0.000027000 syn match  perlFiledescStatementComma	"(\=\s*\<\u\w*\>\s*,"me=e-1 transparent contained contains=perlFiledescStatement
    5              0.000030000 syn match  perlFiledescStatementNocomma "(\=\s*\<\u\w*\>\s*[^, \t]"me=e-1 transparent contained contains=perlFiledescStatement
                            
    5              0.000012000 syn match  perlFiledescStatement	"\<\u\w*\>" contained
                            
                            " Special characters in strings and matches
    5              0.000027000 syn match  perlSpecialString	"\\\%(\o\{1,3}\|x\%({\x\+}\|\x\{1,2}\)\|c.\|[^cx]\)" contained extend
    5              0.000032000 syn match  perlSpecialStringU2	"\\." extend contained contains=NONE
    5              0.000011000 syn match  perlSpecialStringU	"\\\\" contained
    5              0.000011000 syn match  perlSpecialMatch	"\\[1-9]" contained extend
    5              0.000027000 syn match  perlSpecialMatch	"\\g\%(\d\+\|{\%(-\=\d\+\|\h\w*\)}\)" contained
    5              0.000018000 syn match  perlSpecialMatch	"\\k\%(<\h\w*>\|'\h\w*'\)" contained
    5              0.000017000 syn match  perlSpecialMatch	"{\d\+\%(,\%(\d\+\)\=\)\=}" contained
    5              0.000016000 syn match  perlSpecialMatch	"\[[]-]\=[^\[\]]*[]-]\=\]" contained extend
    5              0.000012000 syn match  perlSpecialMatch	"[+*()?.]" contained
    5              0.000012000 syn match  perlSpecialMatch	"(?[#:=!]" contained
    5              0.000016000 syn match  perlSpecialMatch	"(?[impsx]*\%(-[imsx]\+\)\=)" contained
    5              0.000016000 syn match  perlSpecialMatch	"(?\%([-+]\=\d\+\|R\))" contained
    5              0.000013000 syn match  perlSpecialMatch	"(?\%(&\|P[>=]\)\h\w*)" contained
    5              0.000033000 syn match  perlSpecialMatch	"(\*\%(\%(PRUNE\|SKIP\|THEN\)\%(:[^)]*\)\=\|\%(MARK\|\):[^)]*\|COMMIT\|F\%(AIL\)\=\|ACCEPT\))" contained
                            
                            " Possible errors
                            "
                            " Highlight lines with only whitespace (only in blank delimited here documents) as errors
    5              0.000012000 syn match  perlNotEmptyLine	"^\s\+$" contained
                            " Highlight "} else if (...) {", it should be "} else { if (...) { " or "} elsif (...) {"
    5              0.000027000 syn match perlElseIfError	"else\_s*if" containedin=perlConditional
    5              0.000030000 syn keyword perlElseIfError	elseif containedin=perlConditional
                            
                            " Variable interpolation
                            "
                            " These items are interpolated inside "" strings and similar constructs.
    5              0.000055000 syn cluster perlInterpDQ	contains=perlSpecialString,perlVarPlain,perlVarNotInMatches,perlVarSlash,perlVarBlock
                            " These items are interpolated inside '' strings and similar constructs.
    5              0.000024000 syn cluster perlInterpSQ	contains=perlSpecialStringU,perlSpecialStringU2
                            " These items are interpolated inside m// matches and s/// substitutions.
    5              0.000042000 syn cluster perlInterpSlash	contains=perlSpecialString,perlSpecialMatch,perlVarPlain,perlVarBlock
                            " These items are interpolated inside m## matches and s### substitutions.
    5              0.000018000 syn cluster perlInterpMatch	contains=@perlInterpSlash,perlVarSlash
                            
                            " Shell commands
    5              0.000026000 syn region  perlShellCommand	matchgroup=perlMatchStartEnd start="`" end="`" contains=@perlInterpDQ keepend
                            
                            " Constants
                            "
                            " Numbers
    5              0.000004000 syn case   ignore
    5              0.000022000 syn match  perlNumber	"\<\%(0\|[1-9]\%(_\=\d\)*\)\>"
    5              0.000025000 syn match  perlNumber	"\<0\%(x\x\%(_\=\x\)*\|b[01]\%(_\=[01]\)*\|o\=\%(_\=\o\)*\)\>"
    5              0.000018000 syn match  perlFloat	"\<\d\%(_\=\d\)*e[-+]\=\d\%(_\=\d\)*"
    5              0.000021000 syn match  perlFloat	"\<\d\%(_\=\d\)*\.\%(\d\%(_\=\d\)*\)\=\%(e[-+]\=\d\%(_\=\d\)*\)\="
    5              0.000024000 syn match  perlFloat    "\.\d\%(_\=\d\)*\%(e[-+]\=\d\%(_\=\d\)*\)\="
    5              0.000022000 syn match  perlFloat	"\<0x\x\%(_\=\x\)*p[-+]\=\d\%(_\=\d\)*"
    5              0.000021000 syn match  perlFloat	"\<0x\x\%(_\=\x\)*\.\%(\x\%(_\=\x\)*\)\=\%(p[-+]\=\d\%(_\=\d\)*\)\="
    5              0.000017000 syn match  perlFloat    "\<0x\.\x\%(_\=\x\)*\%(p[-+]\=\d\%(_\=\d\)*\)\="
    5              0.000003000 syn case   match
                            
    5              0.000038000 syn match  perlString	"\<\%(v\d\+\%(\.\d\+\)*\|\d\+\%(\.\d\+\)\{2,}\)\>" contains=perlVStringV
    5              0.000011000 syn match  perlVStringV	"\<v" contained
                            
                            
    5              0.000026000 syn region perlParensSQ		start=+(+ end=+)+ extend contained contains=perlParensSQ,@perlInterpSQ keepend
    5              0.000024000 syn region perlBracketsSQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsSQ,@perlInterpSQ keepend
    5              0.000024000 syn region perlBracesSQ		start=+{+ end=+}+ extend contained contains=perlBracesSQ,@perlInterpSQ keepend
    5              0.000023000 syn region perlAnglesSQ		start=+<+ end=+>+ extend contained contains=perlAnglesSQ,@perlInterpSQ keepend
                            
    5              0.000045000 syn region perlParensDQ		start=+(+ end=+)+ extend contained contains=perlParensDQ,@perlInterpDQ keepend
    5              0.000026000 syn region perlBracketsDQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsDQ,@perlInterpDQ keepend
    5              0.000022000 syn region perlBracesDQ		start=+{+ end=+}+ extend contained contains=perlBracesDQ,@perlInterpDQ keepend
    5              0.000023000 syn region perlAnglesDQ		start=+<+ end=+>+ extend contained contains=perlAnglesDQ,@perlInterpDQ keepend
                            
                            
                            " Simple version of searches and matches
    5              0.000018000 syn match  perlMatchModifiers "[msixpadluncgo]\+" contained
    5              0.000045000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1+ contains=@perlInterpMatch keepend extend nextgroup=perlMatchModifiers
    5              0.000036000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m#+ end=+#+ contains=@perlInterpMatch keepend extend nextgroup=perlMatchModifiers
    5              0.000045000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*'+ end=+'+ contains=@perlInterpSQ keepend extend nextgroup=perlMatchModifiers
    5              0.000032000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*/+ end=+/+ contains=@perlInterpSlash keepend extend nextgroup=perlMatchModifiers
    5              0.000040000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*(+ end=+)+ contains=@perlInterpMatch,perlParensDQ keepend extend nextgroup=perlMatchModifiers
    5              0.000042000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*{+ end=+}+ contains=@perlInterpMatch,perlBracesDQ extend nextgroup=perlMatchModifiers
    5              0.000039000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*<+ end=+>+ contains=@perlInterpMatch,perlAnglesDQ keepend extend nextgroup=perlMatchModifiers
    5              0.000040000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*\[+ end=+\]+ contains=@perlInterpMatch,perlBracketsDQ keepend extend nextgroup=perlMatchModifiers
                            
                            " Below some hacks to recognise the // variant. This is virtually impossible to catch in all
                            " cases as the / is used in so many other ways, but these should be the most obvious ones.
    5              0.000105000 syn region perlMatch	matchgroup=perlMatchStartEnd start="\%([$@%&*]\@<!\%(\<split\|\<while\|\<if\|\<unless\|\.\.\|[-+*!~(\[{=]\)\s*\)\@<=/\%(/=\)\@!" start=+^/\%(/=\)\@!+ start=+\s\@<=/\%(/=\)\@![^[:space:][:digit:]$@%=]\@=\%(/\_s*\%([([{$@%&*[:digit:]"'`]\|\_s\w\|[[:upper:]_abd-fhjklnqrt-wyz]\)\)\@!+ skip=+\\/+ end=+/+ contains=@perlInterpSlash extend nextgroup=perlMatchModifiers
                            
                            
                            " Substitutions
                            " perlMatch is the first part, perlSubstitution* is the substitution part
    5              0.000016000 syn match  perlSubstitutionModifiers "[msixpadluncgero]\+" contained
    5              0.000040000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    5              0.000034000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*'+  end=+'+me=e-1 contains=@perlInterpSQ nextgroup=perlSubstitutionSQ keepend extend
    5              0.000035000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*/+  end=+/+me=e-1 contains=@perlInterpSlash nextgroup=perlSubstitutionGQQ keepend extend
    5              0.000033000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s#+  end=+#+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    5              0.000040000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*(+ end=+)+ contains=@perlInterpMatch,perlParensDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    5              0.000040000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*<+ end=+>+ contains=@perlInterpMatch,perlAnglesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    5              0.000045000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*\[+ end=+\]+ contains=@perlInterpMatch,perlBracketsDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    5              0.000043000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*{+ end=+}+ contains=@perlInterpMatch,perlBracesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    5              0.000035000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]'([{<]\)+ end=+\z1+ keepend contained contains=@perlInterpDQ extend nextgroup=perlSubstitutionModifiers
    5              0.000037000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+(+ end=+)+ contained contains=@perlInterpDQ,perlParensDQ keepend extend nextgroup=perlSubstitutionModifiers
    5              0.000035000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\]+ contained contains=@perlInterpDQ,perlBracketsDQ keepend extend nextgroup=perlSubstitutionModifiers
    5              0.000049000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+{+ end=+}+ contained contains=@perlInterpDQ,perlBracesDQ keepend extend extend nextgroup=perlSubstitutionModifiers
    5              0.000036000 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+<+ end=+>+ contained contains=@perlInterpDQ,perlAnglesDQ keepend extend nextgroup=perlSubstitutionModifiers
    5              0.000027000 syn region perlSubstitutionSQ		matchgroup=perlMatchStartEnd start=+'+  end=+'+ contained contains=@perlInterpSQ keepend extend nextgroup=perlSubstitutionModifiers
                            
                            " Translations
                            " perlMatch is the first part, perlTranslation* is the second, translator part.
    5              0.000014000 syn match  perlTranslationModifiers "[cdsr]\+" contained
    5              0.000040000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\>\s*\z([^[:space:]([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    5              0.000041000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)#+ end=+#+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    5              0.000045000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    5              0.000044000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    5              0.000041000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    5              0.000045000 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    5              0.000029000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]([{<]\)+ end=+\z1+ contained nextgroup=perlTranslationModifiers
    5              0.000034000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+(+ end=+)+ contains=perlParensSQ contained nextgroup=perlTranslationModifiers
    5              0.000039000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\]+ contains=perlBracketsSQ contained nextgroup=perlTranslationModifiers
    5              0.000034000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+{+ end=+}+ contains=perlBracesSQ contained nextgroup=perlTranslationModifiers
    5              0.000031000 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+<+ end=+>+ contains=perlAnglesSQ contained nextgroup=perlTranslationModifiers
                            
                            
                            " Strings and q, qq, qw and qr expressions
                            
    5              0.000020000 syn region perlStringUnexpanded	matchgroup=perlStringStartEnd start="'" end="'" contains=@perlInterpSQ keepend extend
    5              0.000019000 syn region perlString		matchgroup=perlStringStartEnd start=+"+  end=+"+ contains=@perlInterpDQ keepend extend
    5              0.000029000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpSQ keepend extend
    5              0.000024000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q#+ end=+#+ contains=@perlInterpSQ keepend extend
    5              0.000033000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    5              0.000031000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    5              0.000034000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    5              0.000032000 syn region perlQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    5              0.000030000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpDQ keepend extend
    5              0.000026000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]#+ end=+#+ contains=@perlInterpDQ keepend extend
    5              0.000035000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*(+ end=+)+ contains=@perlInterpDQ,perlParensDQ keepend extend
    5              0.000036000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*\[+ end=+\]+ contains=@perlInterpDQ,perlBracketsDQ keepend extend
    5              0.000033000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*{+ end=+}+ contains=@perlInterpDQ,perlBracesDQ keepend extend
    5              0.000031000 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*<+ end=+>+ contains=@perlInterpDQ,perlAnglesDQ keepend extend
                            
    5              0.000036000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\z([^[:space:]#([{<]\)+  end=+\z1+ contains=@perlInterpSQ keepend extend
    5              0.000028000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw#+  end=+#+ contains=@perlInterpSQ keepend extend
    5              0.000034000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*(+  end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    5              0.000036000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\[+  end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    5              0.000035000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*{+  end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    5              0.000042000 syn region perlQW		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*<+  end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    5              0.000015000 syn match  perlQRModifiers "[msixpadluno]\+" contained
    5              0.000046000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\>\s*\z([^[:space:]#([{<'/]\)+  end=+\z1+ contains=@perlInterpMatch keepend extend nextgroup=perlQRModifiers
    5              0.000035000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*/+  end=+/+ contains=@perlInterpSlash keepend extend nextgroup=perlQRModifiers
    5              0.000037000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr#+  end=+#+ contains=@perlInterpMatch keepend extend nextgroup=perlQRModifiers
    5              0.000039000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*'+  end=+'+ contains=@perlInterpSQ keepend extend nextgroup=perlQRModifiers
    5              0.000047000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*(+  end=+)+ contains=@perlInterpMatch,perlParensDQ keepend extend nextgroup=perlQRModifiers
                            
                            " A special case for qr{}, qr<> and qr[] which allows for comments and extra whitespace in the pattern
    5              0.000054000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*{+  end=+}+ contains=@perlInterpMatch,perlBracesDQ,perlComment keepend extend nextgroup=perlQRModifiers
    5              0.000059000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*<+  end=+>+ contains=@perlInterpMatch,perlAnglesDQ,perlComment keepend extend nextgroup=perlQRModifiers
    5              0.000053000 syn region perlQR		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*\[+  end=+\]+ contains=@perlInterpMatch,perlBracketsDQ,perlComment keepend extend nextgroup=perlQRModifiers
                            
                            " Constructs such as print <<EOF [...] EOF, 'here' documents
                            "
                            " XXX Any statements after the identifier are in perlString colour (i.e.
                            " 'if $a' in 'print <<EOF if $a'). This is almost impossible to get right it
                            " seems due to the 'auto-extending nature' of regions.
                            " XXX Indented heredocs are not perfect - they sometimes seem to take a moment
                            "     to update if switched from double to single quotes and vice versa.
                            "
                            " Note: bare delimiters such as << to mean <<"" are not supported. These are a
                            "       fatal error since 5.28 and, apparently, a rarely used feature.
                            
    5              0.000032000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\I\i*+                         end=+$+     contains=@perlTop oneline
    5              0.000025000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\\\I\i*+                       end=+$+     contains=@perlTop oneline
    5              0.000032000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*"[^\\"]*\%(\\.[^\\"]*\)*"+  end=+$+     contains=@perlTop oneline
    5              0.000028000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*'[^\\']*\%(\\.[^\\']*\)*'+  end=+$+     contains=@perlTop oneline
    5              0.000027000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*`[^\\`]*\%(\\.[^\\`]*\)*`+  end=+$+     contains=@perlTop oneline
    5              0.000023000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*""+                         end=+$+     contains=@perlTop oneline
    5              0.000022000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*''+                         end=+$+     contains=@perlTop oneline
    5              0.000026000 syn region perlHereDocStart	matchgroup=perlStringStartEnd start=+<<\~\=\s*``+                         end=+$+     contains=@perlTop oneline
                            
    5              0.000020000 if get(g:, 'perl_fold', 0)
                              syn region perlHereDoc	start=+<<\z(\I\i*\)+                        matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\\\z(\I\i*\)+                      matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ fold extend
                              syn region perlHereDoc	start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ fold extend
                              syn region perlHereDoc	start=+<<\s*`\z([^\\`]*\%(\\.[^\\`]*\)*\)`+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ fold extend
                              syn region perlHereDoc	start=+<<\s*""+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
                              syn region perlHereDoc	start=+<<\s*''+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine fold extend
                              syn region perlHereDoc	start=+<<\s*``+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
    5              0.000003000 else
    5              0.000033000   syn region perlHereDoc	start=+<<\z(\I\i*\)+                        matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    5              0.000040000   syn region perlHereDoc	start=+<<\\\z(\I\i*\)+                      matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ
    5              0.000037000   syn region perlHereDoc	start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    5              0.000038000   syn region perlHereDoc	start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpSQ
    5              0.000037000   syn region perlHereDoc	start=+<<\s*`\z([^\\`]*\%(\\.[^\\`]*\)*\)`+ matchgroup=perlStringStartEnd end=+^\z1$+ contains=perlHereDocStart,@perlInterpDQ
    5              0.000043000   syn region perlHereDoc	start=+<<\s*""+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    5              0.000045000   syn region perlHereDoc	start=+<<\s*''+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine
    5              0.000039000   syn region perlHereDoc	start=+<<\s*``+                             matchgroup=perlStringStartEnd end=+^$+    contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    5              0.000004000 endif
                            
    5              0.000009000 if get(g:, 'perl_fold', 0)
                              syn region perlIndentedHereDoc	start=+<<\~\z(\I\i*\)+                        matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpDQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\\\z(\I\i*\)+                      matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpSQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpDQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpSQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*`\z([^\\`]*\%(\\.[^\\`]*\)*\)`+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlIndentedHereDocStart,@perlInterpDQ fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*""+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlIndentedHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*''+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlIndentedHereDocStart,@perlInterpSQ,perlNotEmptyLine fold extend
                              syn region perlIndentedHereDoc	start=+<<\~\s*``+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlIndentedHereDocStart,@perlInterpDQ,perlNotEmptyLine fold extend
    5              0.000015000 else
    5              0.000035000   syn region perlIndentedHereDoc	start=+<<\~\z(\I\i*\)+                        matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpDQ
    5              0.000039000   syn region perlIndentedHereDoc	start=+<<\~\\\z(\I\i*\)+                      matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpSQ
    5              0.000040000   syn region perlIndentedHereDoc	start=+<<\~\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpDQ
    5              0.000036000   syn region perlIndentedHereDoc	start=+<<\~\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpSQ
    5              0.000040000   syn region perlIndentedHereDoc	start=+<<\~\s*`\z([^\\`]*\%(\\.[^\\`]*\)*\)`+ matchgroup=perlStringStartEnd end=+^\s*\z1$+ contains=perlHereDocStart,@perlInterpDQ
    5              0.000040000   syn region perlIndentedHereDoc	start=+<<\~\s*""+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    5              0.000044000   syn region perlIndentedHereDoc	start=+<<\~\s*''+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlHereDocStart,@perlInterpSQ,perlNotEmptyLine
    5              0.000041000   syn region perlIndentedHereDoc	start=+<<\~\s*``+                             matchgroup=perlStringStartEnd end=+^$+       contains=perlHereDocStart,@perlInterpDQ,perlNotEmptyLine
    5              0.000003000 endif
                            
                            
                            " Class declarations
                            "
    5              0.000034000 syn match   perlPackageDecl		"\<package\s\+\%(\h\|::\)\%(\w\|::\)*" contains=perlStatementPackage
    5              0.000020000 syn keyword perlStatementPackage	package contained
                            
                            " Functions
    5              0.000009000 if get(g:, "perl_sub_signatures", 0)
                                syn match perlSubSignature "\s*([^)]*)" contained extend
    5              0.000001000 else
    5              0.000019000     syn match perlSubPrototype "\s*([\\$@%&*\[\];]*)" contained extend
    5              0.000002000 endif
    5              0.000019000 syn match perlSubAttribute "\s*:\s*\h\w*\%(([^)]*)\|\)" contained extend
    5              0.000019000 syn match perlSubName "\%(\h\|::\|'\w\)\%(\w\|::\|'\w\)*\s*" contained extend
    5              0.000060000 syn region perlSubDeclaration start="" end="[;{]" contains=perlSubName,perlSubPrototype,perlSubAttribute,perlSubSignature,perlComment contained transparent
    5              0.000022000 syn match perlFunction "\<sub\>\_s*" nextgroup=perlSubDeclaration
                            
                            " The => operator forces a bareword to the left of it to be interpreted as
                            " a string
    5              0.000024000 syn match  perlString "\I\@<!-\?\I\i*\%(\s*=>\)\@="
                            
                            " All other # are comments, except ^#!
    5              0.000030000 syn match  perlComment		"#.*" contains=perlTodo,@Spell extend
    5              0.000013000 syn match  perlSharpBang	"^#!.*"
                            
                            " Formats
    5              0.000074000 syn region perlFormat		matchgroup=perlStatementIOFunc start="^\s*\<format\s\+\k\+\s*=\s*$"rs=s+6 end="^\s*\.\s*$" contains=perlFormatName,perlFormatField,perlVarPlain,perlVarPlain2
    5              0.000015000 syn match  perlFormatName	"format\s\+\k\+\s*="lc=7,me=e-1 contained
    5              0.000024000 syn match  perlFormatField	"[@^][|<>~]\+\%(\.\.\.\)\=" contained
    5              0.000012000 syn match  perlFormatField	"[@^]#[#.]*" contained
    5              0.000013000 syn match  perlFormatField	"@\*" contained
    5              0.000018000 syn match  perlFormatField	"@[^A-Za-z_|<>~#*]"me=e-1 contained
    5              0.000014000 syn match  perlFormatField	"@$" contained
                            
                            " __END__ and __DATA__ clauses
                            
                            " Vim excludes empty syn-region end lines from the fold region.  This is
                            " probably a bug and means a DATA section ending with an empty line does not
                            " have that final line included in the fold.
                            "
                            " As a workaround we exploit an unterminated syntax region here with an end
                            " pattern that will (probably) never match.  This forces all lines to be
                            " included in the fold region.  Of course, if it does match then there's
                            " nothing to work around as it is a non-empty line.
                            "
                            " This problem also exists with empty string delimited heredocs but there's no
                            " known workaround for that case.
    5              0.000009000 if get(g:, 'perl_fold', 0)
                              syntax region perlDATA matchgroup=perlDATAStart start="^__DATA__$" end="VIM_PERL_EOF\%$" contains=@perlDATA fold
                              syntax region perlEND  matchgroup=perlENDStart  start="^__END__$"  end="VIM_PERL_EOF\%$" contains=@perlDATA fold
    5              0.000002000 else
    5              0.000025000   syntax region perlDATA matchgroup=perlDATAStart start="^__DATA__$" end="\%$" contains=@perlDATA
    5              0.000023000   syntax region perlEND  matchgroup=perlENDStart  start="^__END__$"  end="\%$" contains=@perlDATA
    5              0.000003000 endif
                            
                            " TODO: generalise this to allow other filetypes
    5              0.000010000 if get(g:, 'perl_highlight_data', 0)
                              syn cluster perlDATA add=perlPOD
    5              0.000009000 else
    5              0.000017000   syn cluster perlDATA remove=perlPOD
    5              0.000004000 endif
                            
                            "
                            " Folding
    5              0.000007000 if get(g:, 'perl_fold', 0)
                              " Note: this bit must come before the actual highlighting of the "package"
                              " keyword, otherwise this will screw up Pod lines that match /^package/
                              if !get(g:, 'perl_nofold_packages', 0)
                                syn region perlPackageFold start="^package \S\+;\s*\%(#.*\)\=$" end="^1;\=\s*\%(#.*\)\=$" end="\n\+package"me=s-1 transparent fold keepend
                                syn region perlPackageFold start="^\z(\s*\)package\s*\S\+\s*{" end="^\z1}" transparent fold keepend
                              endif
                              if !get(g:, 'perl_nofold_subs', 0)
                                if get(g:, "perl_fold_anonymous_subs", 0)
                                  " EXPLANATION:
                                  " \<sub\>                  - "sub" keyword
                                  " \_[^;{]*                 - any characters, including new line, but not ";" or "{", zero or more times
                                  " \%(([\\$@%&*\[\];]*)\)\= - prototype definition, \$@%&*[]; characters between (), zero or 1 times
                                  " \_[^;]*                  - any characters, including new line, but not ";" or "{", zero or more times
                                  " {                        - start subroutine block
                                  syn region perlSubFold start="\<sub\>\_[^;{]*\%(([\\$@%&*\[\];]*)\)\=\_[^;{]*{" end="}" transparent fold keepend extend
                                else
                                  " EXPLANATION:
                                  " same, as above, but first non-space character after "sub" keyword must
                                  " be [A-Za-z_] 
                                  syn region perlSubFold start="\<sub\>\s*\h\_[^;{]*\%(([\\$@%&*\[\];]*)\)\=\_[^;]*{" end="}" transparent fold keepend extend
                                endif
                            
                                syn region perlSubFold start="\<\%(BEGIN\|END\|CHECK\|INIT\|UNITCHECK\)\>\_s*{" end="}" transparent fold keepend
                              endif
                            
                              if get(g:, 'perl_fold_blocks', 0)
                                syn region perlBlockFold start="^\z(\s*\)\%(if\|elsif\|unless\|for\|while\|until\|given\)\s*(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" start="^\z(\s*\)for\%(each\)\=\s*\%(\%(my\|our\)\=\s*\S\+\s*\)\=(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                            
                                " TODO this is works incorrectly
                                syn region perlBlockFold start="^\z(\s*\)\%(do\|else\)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*while" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                              else
                                if get(g:, 'perl_fold_do_blocks', 0)
                                  syn region perlDoBlockDeclaration start="" end="{" contains=perlComment contained transparent
                                  syn match perlOperator "\<do\>\_s*" nextgroup=perlDoBlockDeclaration
                            
                                  syn region perlDoBlockFold start="\<do\>\_[^{]*{" end="}" transparent fold keepend extend
                                endif
                              endif
                            
                              syn sync fromstart
    5              0.000005000 else
                              " fromstart above seems to set minlines even if perl_fold is not set.
    5              0.000006000   syn sync minlines=0
    5              0.000002000 endif
                            
                            " NOTE: If you're linking new highlight groups to perlString, please also put
                            "       them into b:match_skip in ftplugin/perl.vim.
                            
                            " The default highlighting.
    5              0.000029000 hi def link perlSharpBang		PreProc
    5              0.000031000 hi def link perlControl			PreProc
    5              0.000022000 hi def link perlInclude			Include
    5              0.000025000 hi def link perlSpecial			Special
    5              0.000025000 hi def link perlString			String
    5              0.000027000 hi def link perlCharacter		Character
    5              0.000024000 hi def link perlNumber			Number
    5              0.000026000 hi def link perlFloat			Float
    5              0.000024000 hi def link perlType			Type
    5              0.000024000 hi def link perlIdentifier		Identifier
    5              0.000023000 hi def link perlLabel			Label
    5              0.000026000 hi def link perlStatement		Statement
    5              0.000027000 hi def link perlConditional		Conditional
    5              0.000025000 hi def link perlRepeat			Repeat
    5              0.000024000 hi def link perlOperator		Operator
    5              0.000024000 hi def link perlFunction		Keyword
    5              0.000023000 hi def link perlSubName			Function
    5              0.000025000 hi def link perlSubPrototype		Type
    5              0.000023000 hi def link perlSubSignature		Type
    5              0.000026000 hi def link perlSubAttribute		PreProc
    5              0.000026000 hi def link perlComment			Comment
    5              0.000025000 hi def link perlTodo			Todo
    5              0.000010000 if get(g:, 'perl_string_as_statement', 0)
                              hi def link perlStringStartEnd	perlStatement
    5              0.000003000 else
    5              0.000013000   hi def link perlStringStartEnd	perlString
    5              0.000004000 endif
    5              0.000010000 hi def link perlVStringV		perlStringStartEnd
    5              0.000009000 hi def link perlList			perlStatement
    5              0.000010000 hi def link perlMisc			perlStatement
    5              0.000010000 hi def link perlVarPlain		perlIdentifier
    5              0.000013000 hi def link perlVarPlain2		perlIdentifier
    5              0.000011000 hi def link perlArrow			perlIdentifier
    5              0.000011000 hi def link perlFiledescRead		perlIdentifier
    5              0.000012000 hi def link perlFiledescStatement	perlIdentifier
    5              0.000013000 hi def link perlVarSimpleMember		perlIdentifier
    5              0.000011000 hi def link perlVarSimpleMemberName	perlString
    5              0.000020000 hi def link perlVarNotInMatches		perlIdentifier
    5              0.000011000 hi def link perlVarSlash		perlIdentifier
    5              0.000012000 hi def link perlQ			perlString
    5              0.000013000 hi def link perlQQ			perlString
    5              0.000011000 hi def link perlQW			perlString
    5              0.000012000 hi def link perlQR			perlString
    5              0.000012000 hi def link perlMatchModifiers          perlMatchStartEnd
    5              0.000012000 hi def link perlSubstitutionModifiers   perlMatchStartEnd
    5              0.000013000 hi def link perlTranslationModifiers    perlMatchStartEnd
    5              0.000012000 hi def link perlQRModifiers             perlStringStartEnd
    5              0.000011000 hi def link perlHereDoc			perlString
    5              0.000011000 hi def link perlIndentedHereDoc		perlString
    5              0.000012000 hi def link perlStringUnexpanded	perlString
    5              0.000014000 hi def link perlSubstitutionSQ		perlString
    5              0.000009000 hi def link perlSubstitutionGQQ		perlString
    5              0.000012000 hi def link perlTranslationGQ		perlString
    5              0.000011000 hi def link perlMatch			perlString
    5              0.000012000 hi def link perlMatchStartEnd		perlStatement
    5              0.000010000 hi def link perlFormatName		perlIdentifier
    5              0.000011000 hi def link perlFormatField		perlString
    5              0.000011000 hi def link perlPackageDecl		perlType
    5              0.000009000 hi def link perlStorageClass		perlType
    5              0.000011000 hi def link perlPackageRef		perlType
    5              0.000009000 hi def link perlStatementPackage	perlStatement
    5              0.000012000 hi def link perlStatementStorage	perlStatement
    5              0.000014000 hi def link perlStatementControl	perlStatement
    5              0.000010000 hi def link perlStatementScalar		perlStatement
    5              0.000012000 hi def link perlStatementRegexp		perlStatement
    5              0.000011000 hi def link perlStatementNumeric	perlStatement
    5              0.000013000 hi def link perlStatementList		perlStatement
    5              0.000011000 hi def link perlStatementHash		perlStatement
    5              0.000012000 hi def link perlStatementIOfunc		perlStatement
    5              0.000012000 hi def link perlStatementFiledesc	perlStatement
    5              0.000011000 hi def link perlStatementVector		perlStatement
    5              0.000012000 hi def link perlStatementFiles		perlStatement
    5              0.000013000 hi def link perlStatementFlow		perlStatement
    5              0.000010000 hi def link perlStatementInclude	perlStatement
    5              0.000012000 hi def link perlStatementProc		perlStatement
    5              0.000010000 hi def link perlStatementSocket		perlStatement
    5              0.000012000 hi def link perlStatementIPC		perlStatement
    5              0.000011000 hi def link perlStatementNetwork	perlStatement
    5              0.000012000 hi def link perlStatementPword		perlStatement
    5              0.000010000 hi def link perlStatementTime		perlStatement
    5              0.000012000 hi def link perlStatementMisc		perlStatement
    5              0.000011000 hi def link perlStatementIndirObj	perlStatement
    5              0.000011000 hi def link perlFunctionName		perlIdentifier
    5              0.000011000 hi def link perlMethod			perlIdentifier
    5              0.000010000 hi def link perlPostDeref		perlIdentifier
    5              0.000010000 hi def link perlFunctionPRef		perlType
                            
    5              0.000008000 if !get(g:, 'perl_include_pod', 1)
                              hi def link perlPOD		perlComment
    5              0.000002000 endif
    5              0.000014000 hi def link perlShellCommand		perlString
    5              0.000010000 hi def link perlSpecialAscii		perlSpecial
    5              0.000011000 hi def link perlSpecialDollar		perlSpecial
    5              0.000010000 hi def link perlSpecialString		perlSpecial
    5              0.000011000 hi def link perlSpecialStringU		perlSpecial
    5              0.000011000 hi def link perlSpecialMatch		perlSpecial
    5              0.000010000 hi def link perlEND			perlComment
    5              0.000010000 hi def link perlENDStart		perlEND
    5              0.000010000 hi def link perlDATA			perlComment
    5              0.000011000 hi def link perlDATAStart		perlDATA
                            
                            " NOTE: Due to a bug in Vim (or more likely, a misunderstanding on my part),
                            "	I had to remove the transparent property from the following regions
                            "	in order to get them to highlight correctly.  Feel free to remove
                            "	these and reinstate the transparent property if you know how.
    5              0.000012000 hi def link perlParensSQ		perlString
    5              0.000011000 hi def link perlBracketsSQ		perlString
    5              0.000012000 hi def link perlBracesSQ		perlString
    5              0.000010000 hi def link perlAnglesSQ		perlString
                            
    5              0.000011000 hi def link perlParensDQ		perlString
    5              0.000014000 hi def link perlBracketsDQ		perlString
    5              0.000010000 hi def link perlBracesDQ		perlString
    5              0.000010000 hi def link perlAnglesDQ		perlString
                            
    5              0.000013000 hi def link perlSpecialStringU2	perlString
                            
                            " Possible errors
    5              0.000031000 hi def link perlNotEmptyLine		Error
    5              0.000025000 hi def link perlElseIfError		Error
                            
                            " Syncing to speed up processing
                            "
    5              0.000009000 if !get(g:, 'perl_no_sync_on_sub', 0)
    5              0.000020000   syn sync match perlSync	grouphere NONE "^\s*\<package\s"
    5              0.000017000   syn sync match perlSync	grouphere NONE "^\s*\<sub\>"
    5              0.000013000   syn sync match perlSync	grouphere NONE "^}"
    5              0.000003000 endif
                            
    5              0.000009000 if !get(g:, 'perl_no_sync_on_global_var', 0)
    5              0.000020000   syn sync match perlSync	grouphere NONE "^$\I[[:alnum:]_:]+\s*=\s*{"
    5              0.000021000   syn sync match perlSync	grouphere NONE "^[@%]\I[[:alnum:]_:]+\s*=\s*("
    5              0.000003000 endif
                            
    5              0.000009000 if get(g:, 'perl_sync_dist', 0)
                              execute "syn sync maxlines=" . perl_sync_dist
    5              0.000004000 else
    5              0.000005000   syn sync maxlines=100
    5              0.000001000 endif
                            
    5              0.000024000 syn sync match perlSyncPOD	grouphere perlPOD "^=pod"
    5              0.000021000 syn sync match perlSyncPOD	grouphere perlPOD "^=head"
    5              0.000022000 syn sync match perlSyncPOD	grouphere perlPOD "^=item"
    5              0.000014000 syn sync match perlSyncPOD	grouphere NONE "^=cut"
                            
    5              0.000008000 let b:current_syntax = "perl"
                            
    5              0.000018000 let &cpo = s:cpo_save
    5              0.000004000 unlet s:cpo_save
                            
                            " XXX Change to sts=4:sw=4
                            " vim:ts=8:sts=2:sw=2:expandtab:ft=vim

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/pod.vim
Sourced 5 times
Total time:   0.002676000
 Self time:   0.002676000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:      Perl POD format
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Previously:    Scott Bigham <dsb@killerbunnies.org>
                            " Homepage:      https://github.com/vim-perl/vim-perl
                            " Bugs/requests: https://github.com/vim-perl/vim-perl/issues
                            " License:       Vim License (see :help license)
                            " Last Change:   2022 Jun 13
                            
                            " To add embedded POD documentation highlighting to your syntax file, add
                            " the commands:
                            "
                            "   syn include @Pod <sfile>:p:h/pod.vim
                            "   syn region myPOD start="^=pod" start="^=head" end="^=cut" keepend contained contains=@Pod
                            "
                            " and add myPod to the contains= list of some existing region, probably a
                            " comment.  The "keepend" flag is needed because "=cut" is matched as a
                            " pattern in its own right.
                            
                            
                            " Remove any old syntax stuff hanging around (this is suppressed
                            " automatically by ":syn include" if necessary).
                            " quit when a syntax file was already loaded
    5              0.000013000 if exists("b:current_syntax")
                              finish
    5              0.000001000 endif
                            
    5              0.000015000 let s:cpo_save = &cpo
    5              0.000009000 set cpo&vim
                            
                            " TODO: add supported encodings when we can utilize better performing Vim 8 features
    5              0.000027000 syn match podEncoding	"[0-9A-Za-z_-]\+" contained contains=@NoSpell
                            
                            " Text of a =head1, =head2 or =item command
    5              0.000040000 syn region podCmdText	start="\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contained contains=podFormat,@NoSpell
                            
                            " Indent amount of =over command
    5              0.000023000 syn match podOverIndent	"\d*\.\=\d\+\>" contained contains=@NoSpell
                            
                            " Formatter identifier keyword for =for, =begin and =end commands
    5              0.000014000 syn match podForKeywd	"\S\+" contained contains=@NoSpell
                            
                            " An indented line, to be displayed verbatim
    5              0.000025000 syn region podVerbatim	start="^\s\+\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contains=@NoSpell
                            
    5              0.000049000 syn region podOrdinary	start="^\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contains=podFormat,podSpecial,@Spell
                            
                            " Inline textual items handled specially by POD
    5              0.000024000 syn match podSpecial	"\(\<\|&\)\I\i*\(::\I\i*\)*([^)]*)" contains=@NoSpell
    5              0.000018000 syn match podSpecial	"[$@%]\I\i*\(::\I\i*\)*\>" contains=@NoSpell
                            
                            " Special formatting sequences
                            
    5              0.000033000 syn cluster podFormat contains=podFormat,podFormatError
                            
    5              0.000016000 syn match  podFormatError "[ADGHJKM-RT-WY]<"
                            
    5              0.000030000 syn region podFormat	matchgroup=podFormatDelimiter start="[IBSCLFX]<"              end=">"              contains=@podFormat,@NoSpell
    5              0.000035000 syn region podFormat	matchgroup=podFormatDelimiter start="[IBSCLFX]<<\%(\s\+\|$\)" end="\%(\s\+\|^\)>>" contains=@podFormat,@NoSpell
                            
    5              0.000013000 syn match  podFormat	"Z<>"
                            
    5              0.000046000 syn region podFormat	matchgroup=podFormatDelimiter start="E<" end=">" oneline contains=podEscape,podEscape2,@NoSpell
                            
                            " HTML entities {{{1
                            " Source: Pod/Escapes.pm
    5              0.000251000 syn keyword podEscape contained lt gt quot amp apos sol verbar lchevron rchevron nbsp iexcl cent pound curren yen brvbar sect uml copy ordf laquo not shy reg macr deg plusmn sup2 sup3 acute micro para middot cedil sup1 ordm raquo frac14 frac12 frac34 iquest Agrave Aacute Acirc Atilde Auml Aring AElig Ccedil Egrave Eacute Ecirc Euml Igrave Iacute Icirc Iuml ETH Ntilde Ograve Oacute Ocirc Otilde Ouml times Oslash Ugrave Uacute Ucirc Uuml Yacute THORN szlig agrave aacute acirc atilde auml aring aelig ccedil egrave eacute ecirc euml igrave iacute icirc iuml eth ntilde ograve oacute ocirc otilde ouml divide oslash ugrave uacute ucirc uuml yacute thorn yuml fnof Alpha Beta Gamma Delta Epsilon Zeta Eta Theta Iota Kappa Lambda Mu Nu Xi Omicron Pi Rho Sigma Tau Upsilon Phi Chi Psi Omega alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho sigmaf sigma tau upsilon phi chi psi omega thetasym upsih piv bull hellip prime Prime oline frasl weierp image real trade alefsym larr uarr rarr d
                            " }}}
                            
    5              0.000017000 syn match  podEscape2	"\d\+"     contained contains=@NoSpell
    5              0.000016000 syn match  podEscape2	"0\=x\x\+" contained contains=@NoSpell
    5              0.000015000 syn match  podEscape2	"0\o\+"    contained contains=@NoSpell
                            
                            
                            " POD commands
    5              0.000030000 syn match podCommand    "^=encoding\>"   nextgroup=podEncoding skipwhite contains=@NoSpell
    5              0.000030000 syn match podCommand    "^=head[1234]\>" nextgroup=podCmdText skipwhite skipnl contains=@NoSpell
    5              0.000028000 syn match podCommand    "^=item\>"       nextgroup=podCmdText skipwhite skipnl contains=@NoSpell
    5              0.000029000 syn match podCommand    "^=over\>"       nextgroup=podOverIndent skipwhite contains=@NoSpell
    5              0.000015000 syn match podCommand    "^=back"         contains=@NoSpell
    5              0.000015000 syn match podCommand    "^=cut"          contains=@NoSpell
    5              0.000013000 syn match podCommand    "^=pod"          contains=@NoSpell
    5              0.000027000 syn match podCommand    "^=for"          nextgroup=podForKeywd skipwhite contains=@NoSpell
    5              0.000027000 syn match podCommand    "^=begin"        nextgroup=podForKeywd skipwhite contains=@NoSpell
    5              0.000027000 syn match podCommand    "^=end"          nextgroup=podForKeywd skipwhite contains=@NoSpell
                            
                            " Comments
                            
    5              0.000026000 syn keyword podForKeywd comment contained nextgroup=podForComment skipwhite skipnl
                            
    5              0.000012000 if exists("perl_pod_no_comment_fold")
                              syn region podBeginComment start="^=begin\s\+comment\s*$" end="^=end\s\+comment\ze\s*$" keepend extend contains=podCommand
                              syn region podForComment start="\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contained contains=@Spell,podTodo
    5              0.000003000 else
    5              0.000049000   syn region podBeginComment start="^=begin\s\+comment\s*$" end="^=end\s\+comment\ze\s*$" keepend extend contains=podCommand,podTodo fold
    5              0.000036000   syn region podForComment start="\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contained contains=@Spell,podTodo fold
    5              0.000003000 endif
                            
    5              0.000011000 syn keyword podTodo contained TODO FIXME XXX
                            
                            " Plain Pod files
    5              0.000031000 syn region podNonPod			   start="\%^\%(=\w\+\>\)\@!" end="^\ze=\a\w*\>"
    5              0.000024000 syn region podNonPod matchgroup=podCommand start="^=cut\>"	      end="\%$"
    5              0.000024000 syn region podNonPod matchgroup=podCommand start="^=cut\>"	      end="^\ze=\a\w*\>"
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    5              0.000030000 hi def link podCommand		Statement
    5              0.000026000 hi def link podBeginComment	Comment
    5              0.000027000 hi def link podForComment	Comment
    5              0.000023000 hi def link podNonPod		Comment
    5              0.000025000 hi def link podTodo		Todo
    5              0.000023000 hi def link podCmdText		String
    5              0.000025000 hi def link podEncoding		Constant
    5              0.000023000 hi def link podOverIndent	Number
    5              0.000023000 hi def link podForKeywd		Identifier
    5              0.000026000 hi def link podVerbatim		PreProc
    5              0.000024000 hi def link podFormat		Identifier
    5              0.000015000 hi def link podFormatDelimiter	podFormat
    5              0.000023000 hi def link podFormatError	Error
    5              0.000025000 hi def link podSpecial		Identifier
    5              0.000024000 hi def link podEscape		Constant
    5              0.000026000 hi def link podEscape2		Number
                            
    5              0.000008000 if exists("perl_pod_spellcheck_headings")
                              " Spell-check headings
                              syn clear podCmdText
                              syn region podCmdText start="\S.*$" end="^\s*$" end="^\ze=cut\>" contained contains=podFormat
    5              0.000003000 endif
                            
    5              0.000009000 if exists("perl_pod_formatting")
                              " By default, escapes like C<> are not checked for spelling. Remove B<>
                              " and I<> from the list of escapes.
                              syn clear podFormat
                              syn region podFormat start="[CLF]<[^<]"me=e-1 end=">" contains=@podFormat,@NoSpell
                              syn region podFormat start="[CLF]<<\%(\s\+\|$\)" end="\%(\s\+\|^\)>>" contains=@podFormat,@NoSpell
                            
                              " Don't spell-check inside E<>, but ensure that the E< itself isn't
                              " marked as a spelling mistake.
                              syn region podFormat	start="E<" end=">" oneline contains=podEscape,podEscape2,@NoSpell
                            
                              " Z<> is a mock formatting code. Ensure Z<> on its own isn't marked as a
                              " spelling mistake.
                              syn match podFormat   "Z<>" contains=podEscape,podEscape2,@NoSpell
                            
                              " These are required so that whatever is *within* B<...>, I<...>, etc. is
                              " spell-checked, but not the B, I, ... itself.
                              syn match podBoldOpen    "B<" contains=@NoSpell
                              syn match podItalicOpen  "I<" contains=@NoSpell
                              syn match podNoSpaceOpen "S<" contains=@NoSpell
                              syn match podIndexOpen   "X<" contains=@NoSpell
                            
                              " Same as above but for the << >> syntax.
                              syn match podBoldAlternativeDelimOpen    "B<<\%(\s\+\|$\)" contains=@NoSpell
                              syn match podItalicAlternativeDelimOpen  "I<<\%(\s\+\|$\)" contains=@NoSpell
                              syn match podNoSpaceAlternativeDelimOpen "S<<\%(\s\+\|$\)" contains=@NoSpell
                              syn match podIndexAlternativeDelimOpen   "X<<\%(\s\+\|$\)" contains=@NoSpell
                            
                              " Add support for spell checking text inside B<>, I<>, S<> and X<>.
                              syn region podBold start="B<[^<]"me=e end=">" contains=podBoldItalic,podBoldOpen
                              syn region podBoldAlternativeDelim start="B<<\%(\s\+\|$\)" end="\%(\s\+\|^\)>>" contains=podBoldAlternativeDelimOpen
                            
                              syn region podItalic start="I<[^<]"me=e end=">" contains=podItalicBold,podItalicOpen
                              syn region podItalicAlternativeDelim start="I<<\%(\s\+\|$\)" end="\%(\s\+\|^\)>>" contains=podItalicAlternativeDelimOpen
                            
                              " Nested bold/italic and vice-versa
                              syn region podBoldItalic contained start="I<[^<]"me=e end=">"
                              syn region podItalicBold contained start="B<[^<]"me=e end=">"
                            
                              syn region podNoSpace start="S<[^<]"ms=s-2 end=">"me=e contains=podNoSpaceOpen
                              syn region podNoSpaceAlternativeDelim start="S<<\%(\s\+\|$\)"ms=s-2 end="\%(\s\+\|^\)>>"me=e contains=podNoSpaceAlternativeDelimOpen
                            
                              syn region podIndex start="X<[^<]"ms=s-2 end=">"me=e contains=podIndexOpen
                              syn region podIndexAlternativeDelim start="X<<\%(\s\+\|$\)"ms=s-2 end="\%(\s\+\|^\)>>"me=e contains=podIndexAlternativeDelimOpen
                            
                              " Restore this (otherwise B<> is shown as bold inside verbatim)
                              syn region podVerbatim start="^\s\+\S.*$" end="^\ze\s*$" end="^\ze=cut\>" contains=@NoSpell
                            
                              " Ensure formatted text can be displayed in headings and items
                              syn clear podCmdText
                            
                              if exists("perl_pod_spellcheck_headings")
                                syn match podCmdText ".*$" contained contains=@podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \podBoldOpen,podItalicOpen,podBoldAlternativeDelimOpen,
                                      \podItalicAlternativeDelimOpen,podNoSpaceOpen
                              else
                                syn match podCmdText ".*$" contained contains=@podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \@NoSpell
                              endif
                            
                              " Specify how to display these
                              hi def podBold term=bold cterm=bold gui=bold
                            
                              hi link podBoldAlternativeDelim podBold
                              hi link podBoldAlternativeDelimOpen podBold
                              hi link podBoldOpen podBold
                            
                              hi link podNoSpace                 Identifier
                              hi link podNoSpaceAlternativeDelim Identifier
                            
                              hi link podIndex                   Identifier
                              hi link podIndexAlternativeDelim   Identifier
                            
                              hi def podItalic term=italic cterm=italic gui=italic
                            
                              hi link podItalicAlternativeDelim podItalic
                              hi link podItalicAlternativeDelimOpen podItalic
                              hi link podItalicOpen podItalic
                            
                              hi def podBoldItalic term=italic,bold cterm=italic,bold gui=italic,bold
                              hi def podItalicBold term=italic,bold cterm=italic,bold gui=italic,bold
    5              0.000005000 endif
                            
    5              0.000008000 let b:current_syntax = "pod"
                            
    5              0.000019000 let &cpo = s:cpo_save
    5              0.000005000 unlet s:cpo_save
                            
                            " vim: ts=8 fdm=marker:

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/ruby.vim
Sourced 5 times
Total time:   0.051838000
 Self time:   0.043446000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:		2023 Mar 16
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
                            " Prelude {{{1
    5              0.000018000 if exists("b:current_syntax")
                              finish
    5              0.000005000 endif
                            
                            " this file uses line continuations
    5              0.000011000 let s:cpo_sav = &cpo
    5              0.000012000 set cpo&vim
                            
                            " eRuby Config {{{1
    5              0.000012000 if exists('main_syntax') && main_syntax == 'eruby'
                              let b:ruby_no_expensive = 1
    5              0.000004000 endif
                            
                            " Folding Config {{{1
    5              0.000016000 if has("folding") && exists("ruby_fold")
                              setlocal foldmethod=syntax
    5              0.000000000 endif
                            
    5              0.000057000 let s:foldable_groups = split(
                                  \	  get(
                                  \	    b:,
                                  \	    'ruby_foldable_groups',
                                  \	    get(g:, 'ruby_foldable_groups', 'ALL')
                                  \	  )
                                  \	)
                            
    5              0.000014000 function! s:foldable(...) abort
                              if index(s:foldable_groups, 'NONE') > -1
                                return 0
                              endif
                            
                              if index(s:foldable_groups, 'ALL') > -1
                                return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
    5              0.000010000 function! s:run_syntax_fold(args) abort
                              let [_0, _1, groups, cmd; _] = matchlist(a:args, '\(["'']\)\(.\{-}\)\1\s\+\(.*\)')
                              if call('s:foldable', split(groups))
                                let cmd .= ' fold'
                              endif
                              exe cmd
                            endfunction
                            
    5              0.000048000 com! -nargs=* SynFold call s:run_syntax_fold(<q-args>)
                            
                            " Not-Top Cluster {{{1
    5              0.000105000 syn cluster rubyNotTop contains=@rubyCommentNotTop,@rubyStringNotTop,@rubyRegexpSpecial,@rubyDeclaration,@rubyExceptionHandler,@rubyClassOperator,rubyConditional,rubyModuleName,rubyClassName,rubySymbolDelimiter,rubyDoubleQuoteSymbolDelimiter,rubySingleQuoteSymbolDelimiter,rubyParentheses,@Spell
                            
                            " Whitespace Errors {{{1
    5              0.000010000 if exists("ruby_space_errors")
                              if !exists("ruby_no_trail_space_error")
                                syn match rubySpaceError display excludenl "\s\+$"
                              endif
                              if !exists("ruby_no_tab_space_error")
                                syn match rubySpaceError display " \+\t"me=e-1
                              endif
    5              0.000004000 endif
                            
                            " Operators {{{1
                            
    5              0.000016000 syn match rubyEnglishBooleanOperator "\<\%(and\|or\|not\)\>"
                            
    5              0.000014000 if exists("ruby_operators") || exists("ruby_pseudo_operators")
                              syn match rubyDotOperator	   "\.\|&\."
                            
                              syn match rubyTernaryOperator    "\%(\w\|[^\x00-\x7F]\)\@1<!?\|:"
                              syn match rubyArithmeticOperator "\*\*\|[*/%+]\|->\@!"
                              syn match rubyComparisonOperator "<=>\|<=\|<\|>=\|[-=]\@1<!>"
                              syn match rubyBitwiseOperator    "[~^|]\|&\.\@!\|<<\|>>"
                              syn match rubyBooleanOperator    "\%(\w\|[^\x00-\x7F]\)\@1<!!\|&&\|||"
                              syn match rubyRangeOperator	   "\.\.\.\="
                              syn match rubyAssignmentOperator "=>\@!\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|||=\||=\|%=\|+=\|>>=\|<<=\|\^="
                              syn match rubyAssignmentOperator "=>\@!" contained containedin=rubyBlockParameterList " TODO: this is inelegant
                              syn match rubyEqualityOperator   "===\|==\|!=\|!\~\|=\~"
                            
                              syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\%(\w\|[^\x00-\x7F]\)[?!]\=\|[]})]\)\@2<=\[" end="]" contains=ALLBUT,@rubyNotTop
                            
                              syn match rubyScopeOperator	    "::"
                              syn match rubySuperClassOperator  "<"	 contained
                              syn match rubyEigenClassOperator  "<<" contained
                              syn match rubyLambdaOperator	    "->"
                              syn match rubySplatOperator	    "\%([[{(|,=]\_s*\)\@<=\*"
                              syn match rubySplatOperator	    "\%(^\|\s\)\@1<=\*\%(\h\|[^\x00-\x7F]\|[:$@[]\)\@="
                              syn match rubyDoubleSplatOperator "\%([{(|,]\_s*\)\@<=\*\*"
                              syn match rubyDoubleSplatOperator "\s\@1<=\*\*\%(\h\|[^\x00-\x7F]\|[:$@{]\)\@="
                              syn match rubyProcOperator	    "\%([[(|,]\_s*\)\@<=&"
                              syn match rubyProcOperator	    "\s\@1<=&\%(\h\|[^\x00-\x7F]\|[:$@]\|->\)\@="
                            
                              syn cluster rubyProperOperator contains=rubyTernaryOperator,rubyArithmeticOperator,rubyComparisonOperator,rubyBitwiseOperator,rubyBooleanOperator,rubyRangeOperator,rubyAssignmentOperator,rubyEqualityOperator,rubyDefinedOperator,rubyEnglishBooleanOperator
                              syn cluster rubyClassOperator  contains=rubyEigenClassOperator,rubySuperClassOperator
                              syn cluster rubyPseudoOperator contains=rubyDotOperator,rubyScopeOperator,rubyEigenClassOperator,rubySuperClassOperator,rubyLambdaOperator,rubySplatOperator,rubyDoubleSplatOperator,rubyProcOperator
                              syn cluster rubyOperator	 contains=ruby.*Operator
    5              0.000003000 endif
                            
                            " String Interpolation and Backslash Notation {{{1
    5              0.000033000 syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
    5              0.000056000 syn match  rubyInterpolation	      "#\$\%(-\w\|[!$&"'*+,./0:;<>?@\`~_]\|\w\+\)" display contained contains=rubyInterpolationDelimiter,@rubyGlobalVariable
    5              0.000059000 syn match  rubyInterpolation	      "#@@\=\w\+"				   display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable
    5              0.000021000 syn match  rubyInterpolationDelimiter "#\ze[$@]"				   display contained
                            
    5              0.000012000 syn match rubyStringEscape "\\\_."											   contained display
    5              0.000019000 syn match rubyStringEscape "\\\o\{1,3}\|\\x\x\{1,2}"									   contained display
    5              0.000027000 syn match rubyStringEscape "\\u\%(\x\{4}\|{\x\{1,6}\%(\s\+\x\{1,6}\)*}\)"						   contained display
    5              0.000033000 syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=.\)" contained display
                            
    5              0.000011000 syn match rubyBackslashEscape "\\\\" contained display
    5              0.000015000 syn match rubyQuoteEscape     "\\'"  contained display
    5              0.000011000 syn match rubySpaceEscape     "\\ "  contained display
                            
    5              0.000014000 syn match rubyParenthesisEscape	  "\\[()]"  contained display
    5              0.000010000 syn match rubyCurlyBraceEscape	  "\\[{}]"  contained display
    5              0.000010000 syn match rubyAngleBracketEscape  "\\[<>]"  contained display
    5              0.000013000 syn match rubySquareBracketEscape "\\[[\]]" contained display
                            
    5              0.000021000 syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  end=")"	transparent contained
    5              0.000022000 syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  end="}"	transparent contained
    5              0.000019000 syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  end=">"	transparent contained
    5              0.000018000 syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" end="\]"	transparent contained
                            
    5              0.000073000 syn cluster rubySingleCharEscape contains=rubyBackslashEscape,rubyQuoteEscape,rubySpaceEscape,rubyParenthesisEscape,rubyCurlyBraceEscape,rubyAngleBracketEscape,rubySquareBracketEscape
    5              0.002518000 syn cluster rubyNestedBrackets	 contains=rubyNested.\+
    5              0.000024000 syn cluster rubyStringSpecial	 contains=rubyInterpolation,rubyStringEscape
    5              0.000014000 syn cluster rubyStringNotTop	 contains=@rubyStringSpecial,@rubyNestedBrackets,@rubySingleCharEscape
                            
                            " Regular Expression Metacharacters {{{1
    5              0.000027000 syn region rubyRegexpComment	  matchgroup=rubyRegexpSpecial	 start="(?#"								     skip="\\\\\|\\)"  end=")"	contained
    5              0.000050000 syn region rubyRegexpParens	  matchgroup=rubyRegexpSpecial	 start="(\%(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\\\\|\\)"  end=")"	contained transparent contains=@rubyRegexpSpecial
    5              0.000070000 syn region rubyRegexpBrackets	  matchgroup=rubyRegexpCharClass start="\[\^\="								     skip="\\\\\|\\\]" end="\]" contained transparent contains=rubyRegexpBrackets,rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass,rubyRegexpIntersection oneline
    5              0.000012000 syn match  rubyRegexpCharClass	  "\\[DdHhRSsWw]"	 contained display
    5              0.000033000 syn match  rubyRegexpCharClass	  "\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|word\|xdigit\):\]" contained
    5              0.000016000 syn match  rubyRegexpCharClass	  "\\[pP]{^\=.\{-}}"	 contained display
    5              0.000014000 syn match  rubyRegexpEscape	  "\\[].*?+^$|\\/(){}[]" contained " see commit e477f10
    5              0.000014000 syn match  rubyRegexpQuantifier	  "[*?+][?+]\="		 contained display
    5              0.000022000 syn match  rubyRegexpQuantifier	  "{\d\+\%(,\d*\)\=}?\=" contained display
    5              0.000015000 syn match  rubyRegexpAnchor	  "[$^]\|\\[ABbGZz]"	 contained display
    5              0.000010000 syn match  rubyRegexpDot	  "\.\|\\X"		 contained display
    5              0.000011000 syn match  rubyRegexpIntersection "&&"			 contained display
    5              0.000012000 syn match  rubyRegexpSpecial	  "\\K"			 contained display
    5              0.000009000 syn match  rubyRegexpSpecial	  "|"			 contained display
    5              0.000015000 syn match  rubyRegexpSpecial	  "\\[1-9]\d\=\d\@!"	 contained display
    5              0.000021000 syn match  rubyRegexpSpecial	  "\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
    5              0.000029000 syn match  rubyRegexpSpecial	  "\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
    5              0.000014000 syn match  rubyRegexpSpecial	  "\\g<\%([a-z_]\w*\|-\=\d\+\)>"		contained display
    5              0.000016000 syn match  rubyRegexpSpecial	  "\\g'\%([a-z_]\w*\|-\=\d\+\)'"		contained display
                            
    5              0.000092000 syn cluster rubyRegexpSpecial contains=@rubyStringSpecial,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment,rubyRegexpIntersection
                            
                            " Numbers {{{1
    5              0.000034000 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*r\=i\=\>"							       display
    5              0.000032000 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)r\=i\=\>"					       display
    5              0.000026000 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*r\=i\=\>"							       display
    5              0.000028000 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*r\=i\=\>"						       display
    5              0.000031000 syn match rubyFloat   "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*r\=i\=\>"				       display
    5              0.000049000 syn match rubyFloat   "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)i\=\>" display
                            
                            " Identifiers {{{1
    5              0.000028000 syn match rubyClassName	       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!" contained
    5              0.000023000 syn match rubyModuleName       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!" contained
    5              0.000021000 syn match rubyConstant	       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!"
    5              0.000029000 syn match rubyClassVariable    "@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
    5              0.000019000 syn match rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  display
    5              0.000020000 syn match rubyGlobalVariable   "$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
    5              0.000011000 syn match rubySymbolDelimiter  ":" contained
    5              0.000054000 syn match rubySymbol	       "[]})\"':]\@1<!:\%(\^\|\~@\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!@\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)" contains=rubySymbolDelimiter
    5              0.000032000 syn match rubySymbol	       "[]})\"':]\@1<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"			    contains=rubySymbolDelimiter
    5              0.000047000 syn match rubySymbol	       "[]})\"':]\@1<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  contains=rubySymbolDelimiter
    5              0.000033000 syn match rubySymbol	       "[]})\"':]\@1<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\=" contains=rubySymbolDelimiter
                            
    5   0.000366000   0.000283000 SynFold ':' syn region rubySymbol matchgroup=rubySymbolDelimiter start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape,rubyBackslashEscape
    5   0.000277000   0.000212000 SynFold ':' syn region rubySymbol matchgroup=rubySymbolDelimiter start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial
                            
    5              0.000023000 syn match rubyCapitalizedMethod "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@="
                            
    5              0.000029000 syn region rubyParentheses	  start="("				 end=")" contains=ALLBUT,@rubyNotTop contained containedin=rubyBlockParameterList
    5              0.000031000 syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\_s*\)\@32<=|" end="|" contains=ALLBUT,@rubyNotTop,@rubyProperOperator
                            
    5              0.000012000 if exists('ruby_global_variable_error')
                              syn match rubyGlobalVariableError "$[^A-Za-z_]"	display
                              syn match rubyGlobalVariableError "$-[^0FIKWadilpvw]" display
    5              0.000003000 endif
                            
    5              0.000030000 syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<>?@\`~]#
    5              0.000013000 syn match rubyPredefinedVariable "$\d\+"									    display
    5              0.000011000 syn match rubyPredefinedVariable "$_\>"										    display
    5              0.000018000 syn match rubyPredefinedVariable "$-[0FIWadilpvw]\>"								    display
    5              0.000018000 syn match rubyPredefinedVariable "$\%(stderr\|stdin\|stdout\)\>"						    display
    5              0.000026000 syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
    5              0.000042000 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(ARGF\|ARGV\|ENV\|DATA\|STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\)\>\%(\s*(\)\@!"
    5              0.000035000 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
                            
                            " Deprecated/removed in 1.9
    5              0.000010000 syn match rubyPredefinedVariable "$="
    5              0.000012000 syn match rubyPredefinedVariable "$-K\>"		  display
    5              0.000016000 syn match rubyPredefinedVariable "$\%(deferr\|defout\)\>" display
    5              0.000014000 syn match rubyPredefinedVariable "$KCODE\>"		  display
                            " Deprecated/removed in 2.4
    5              0.000022000 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(FALSE\|NIL\|TRUE\)\>\%(\s*(\)\@!"
                            
    5              0.000030000 syn cluster rubyGlobalVariable contains=rubyGlobalVariable,rubyPredefinedVariable,rubyGlobalVariableError
                            
                            " Normal Regular Expressions {{{1
    5   0.000366000   0.000282000 SynFold '/' syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
    5   0.000301000   0.000237000 SynFold '/' syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\s\+\)\@<=/\%(=\|\_s\)\@!"					   end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
                            
                            " Generalized Regular Expressions {{{1
    5   0.000267000   0.000207000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
    5   0.000211000   0.000165000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r{"				   end="}[iomxneus]*"	skip="\\\\\|\\}"   contains=@rubyRegexpSpecial
    5   0.000241000   0.000186000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r<"				   end=">[iomxneus]*"	skip="\\\\\|\\>"   contains=@rubyRegexpSpecial,rubyNestedAngleBrackets
    5   0.000212000   0.000164000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\["				   end="\][iomxneus]*"	skip="\\\\\|\\\]"  contains=@rubyRegexpSpecial
    5   0.000212000   0.000165000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r("				   end=")[iomxneus]*"	skip="\\\\\|\\)"   contains=@rubyRegexpSpecial
    5   0.000227000   0.000180000 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\z(\s\)"			   end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
                            
                            " Characters {{{1
    5              0.000049000 syn match rubyCharacter "\%(\w\|[^\x00-\x7F]\|[]})\"'/]\)\@1<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\[[:space:]]\|\\\=[^[:space:]]\)\)"
    5              0.000031000 syn match rubyCharacter "\%(\w\|[^\x00-\x7F]\|[]})\"'/]\)\@1<!?\\u\%(\x\{4}\|{\x\{1,6}}\)"
                            
                            " Normal Strings {{{1
    5              0.000022000 let s:spell_cluster = exists('ruby_spellcheck_strings') ? ',@Spell' : ''
    5   0.000044000   0.000038000 let s:fold_arg	    = s:foldable('string')		? ' fold'   : ''
    5              0.000054000 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\""  contains=@rubyStringSpecial'		       . s:spell_cluster . s:fold_arg
    5              0.000072000 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="''" end="''" skip="\\\\\|\\''"  contains=rubyQuoteEscape,rubyBackslashEscape' . s:spell_cluster . s:fold_arg
    5              0.000008000 unlet s:spell_cluster s:fold_arg
                            
                            " Shell Command Output {{{1
    5   0.000227000   0.000174000 SynFold 'string' syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial
                            
                            " Generalized Single Quoted Strings, Symbols, Array of Strings and Array of Symbols {{{1
                            
                            " Non-bracket punctuation delimiters {{{2
    5              0.000076000 let s:names = { '~': 'Tilde', '`': 'BackQuote', '!': 'Bang', '@': 'At', '#': 'Hash', '$': 'Dollar', '%': 'Percent', '^': 'Caret',
                                  \		'&': 'Ampersand', '*': 'Asterix', '_': 'Underscore', '-': 'Dash', '+': 'Plus', '=': 'Equals', '|': 'Bar',
                                  \		'\': 'Backslash', ':': 'Colon', ';': 'Semicolon', '"': 'DoubleQuote', "'": 'Quote', ',': 'Comma', '.': 'Period',
                                  \		'?': 'QuestionMark', '/': 'ForwardSlash' }
                            
  125              0.000126000 for s:delimiter in keys(s:names)
  120              0.000231000   let s:group = 'ruby' . s:names[s:delimiter] . 'Escape'
                            
  120              0.000223000   if s:delimiter =~ '[\"]'
   10              0.000015000     let s:delimiter = '\' . s:delimiter
  120              0.000050000   endif
                            
  120              0.000490000   exe 'syn match ' . s:group . ' "\V\\' . s:delimiter . '" contained display'
  120              0.000478000   exe 'syn cluster rubySingleCharEscape add=' . s:group
  120   0.006224000   0.004965000   exe 'SynFold ''%'' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\V%q' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,'		 . s:group . ' nextgroup=@rubyModifier skipwhite'
  120   0.006630000   0.005282000   exe 'SynFold ''%'' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\V%w' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,rubySpaceEscape,' . s:group . ' nextgroup=@rubyModifier skipwhite'
  120   0.006138000   0.004856000   exe 'SynFold ''%'' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="\V%s' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,'		 . s:group . ' nextgroup=@rubyModifier skipwhite'
  120   0.006516000   0.005185000   exe 'SynFold ''%'' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="\V%i' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,rubySpaceEscape,' . s:group . ' nextgroup=@rubyModifier skipwhite'
  120              0.000453000   exe 'hi def link ' . s:group . ' rubyStringEscape'
  125              0.000066000 endfor
                            
    5              0.000015000 unlet s:delimiter s:group s:names
                            " }}}2
                            
    5   0.000234000   0.000183000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    5   0.000223000   0.000176000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    5   0.000229000   0.000179000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    5   0.000223000   0.000172000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubyParenthesisEscape,rubyNestedParentheses
    5   0.000214000   0.000167000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q\z(\s\)" end="\z1" skip="\\\\\|\\\z1" contains=rubyBackslashEscape,rubySpaceEscape
                            
    5   0.000236000   0.000184000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubySpaceEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    5   0.000241000   0.000188000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubySpaceEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    5   0.000271000   0.000207000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySpaceEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    5   0.000259000   0.000190000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubySpaceEscape,rubyParenthesisEscape,rubyNestedParentheses
                            
    5   0.000225000   0.000177000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    5   0.000236000   0.000190000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    5   0.000236000   0.000188000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    5   0.000220000   0.000171000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubyParenthesisEscape,rubyNestedParentheses
    5   0.000215000   0.000172000 SynFold '%' syn region rubyString matchgroup=rubyPercentSymbolDelimiter start="%s\z(\s\)" end="\z1" skip="\\\\\|\\\z1" contains=rubyBackslashEscape,rubySpaceEscape
                            
    5   0.000257000   0.000205000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubySpaceEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    5   0.000233000   0.000184000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubySpaceEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    5   0.000260000   0.000208000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySpaceEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    5   0.000239000   0.000183000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubySpaceEscape,rubyParenthesisEscape,rubyNestedParentheses
                            
                            " Generalized Double Quoted Strings, Array of Strings, Array of Symbols and Shell Command Output {{{1
    5   0.000231000   0.000181000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\%(\%(\w\|[^\x00-\x7F]\|]\)\s*\)\@<!%=" end="="	 skip="\\\\\|\\="   contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    5   0.000265000   0.000211000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"       end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    5   0.000220000   0.000168000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    5   0.000217000   0.000172000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\={"			       end="}"	 skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces
    5   0.000203000   0.000160000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=<"			       end=">"	 skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets
    5   0.000225000   0.000171000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=\["			       end="\]"  skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets
    5   0.000209000   0.000165000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=("			       end=")"	 skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses
    5   0.000190000   0.000150000 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[Qx]\z(\s\)"			       end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                            
    5   0.000230000   0.000184000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    5   0.000211000   0.000169000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I{"				   end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces
    5   0.000206000   0.000162000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I<"				   end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets
    5   0.000203000   0.000161000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I\["				   end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets
    5   0.000197000   0.000153000 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I("				   end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses
                            
                            " Here Documents {{{1
    5              0.000049000 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    5              0.000036000 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs"\%([^"]*\)"+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
    5              0.000032000 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs'\%([^']*\)'+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
    5              0.000031000 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs`\%([^`]*\)`+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    5   0.000315000   0.000247000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2  matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
    5   0.000272000   0.000219000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
    5   0.000253000   0.000200000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart		     keepend
    5   0.000259000   0.000206000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
                            
    5   0.000286000   0.000226000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3 matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
    5   0.000251000   0.000199000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
    5   0.000245000   0.000194000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		     keepend
    5   0.000267000   0.000211000 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                            
                            " Module, Class, Method and Alias Declarations {{{1
    5              0.000040000 syn match rubyAliasDeclaration	"[^[:space:];#.()]\+" contained contains=rubySymbol,@rubyGlobalVariable nextgroup=rubyAliasDeclaration2 skipwhite
    5              0.000023000 syn match rubyAliasDeclaration2 "[^[:space:];#.()]\+" contained contains=rubySymbol,@rubyGlobalVariable
    5              0.000057000 syn match rubyMethodDeclaration "[^[:space:];#(]\+"   contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
    5              0.000032000 syn match rubyClassDeclaration	"[^[:space:];#<]\+"   contained contains=rubyClassName,rubyScopeOperator nextgroup=rubySuperClassOperator skipwhite
    5              0.000024000 syn match rubyModuleDeclaration "[^[:space:];#<]\+"   contained contains=rubyModuleName,rubyScopeOperator
                            
    5              0.000035000 syn match rubyMethodName "\<\%([_[:alpha:]]\|[^\x00-\x7F]\)\%([_[:alnum:]]\|[^\x00-\x7F]\)*[?!=]\=\%([[:alnum:]_.:?!=]\|[^\x00-\x7F]\)\@!"			      contained containedin=rubyMethodDeclaration
    5              0.000038000 syn match rubyMethodName "\%(\s\|^\)\@1<=\%([_[:alpha:]]\|[^\x00-\x7F]\)\%([_[:alnum:]]\|[^\x00-\x7F]\)*[?!=]\=\%(\s\|$\)\@="					      contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
    5              0.000056000 syn match rubyMethodName "\%([[:space:].]\|^\)\@1<=\%(\[\]=\=\|\*\*\|[-+!~]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
                            
    5              0.000048000 syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyMethodName
                            
                            " Keywords {{{1
                            " TODO: reorganise
    5              0.000030000 syn match rubyControl	     "\%#=1\<\%(break\|in\|next\|redo\|retry\|return\)\>"
    5              0.000015000 syn match rubyKeyword	     "\%#=1\<\%(super\|yield\)\>"
    5              0.000018000 syn match rubyBoolean	     "\%#=1\<\%(true\|false\)\>[?!]\@!"
    5              0.000013000 syn match rubyPseudoVariable "\%#=1\<\%(self\|nil\)\>[?!]\@!"
    5              0.000030000 syn match rubyPseudoVariable "\%#=1\<__\%(ENCODING\|dir\|FILE\|LINE\|callee\|method\)__\>"
    5              0.000013000 syn match rubyBeginEnd	     "\%#=1\<\%(BEGIN\|END\)\>"
                            
                            " Expensive Mode {{{1
                            " Match 'end' with the appropriate opening keyword for syntax based folding
                            " and special highlighting of module/class/method definitions
    5              0.000027000 if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
    5              0.000021000   syn match rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration			  skipwhite skipnl
    5              0.000018000   syn match rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration			  skipwhite skipnl
    5              0.000016000   syn match rubyDefine "\<undef\>"  nextgroup=rubyMethodName				  skipwhite skipnl
    5              0.000022000   syn match rubyClass  "\<class\>"  nextgroup=rubyClassDeclaration,rubyEigenClassOperator skipwhite skipnl
    5              0.000016000   syn match rubyModule "\<module\>" nextgroup=rubyModuleDeclaration			  skipwhite skipnl
                            
    5   0.000247000   0.000195000   SynFold 'def'    syn region rubyMethodBlock start="\<def\>"	 matchgroup=rubyDefine skip="\<end:\|\%(\<def\_s\+\)\@<=end\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
    5   0.000203000   0.000160000   SynFold 'class'  syn region rubyClassBlock  start="\<class\>"  matchgroup=rubyClass  skip="\<end:"			       end="\<end\>" contains=ALLBUT,@rubyNotTop
    5   0.000201000   0.000154000   SynFold 'module' syn region rubyModuleBlock start="\<module\>" matchgroup=rubyModule skip="\<end:"			       end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
                              " endless def
    5              0.000040000   syn match rubyDefine "\<def\s\+\ze[^[:space:];#(]\+\%(\s\+\|\s*(.*)\s*\)=" nextgroup=rubyMethodDeclaration skipwhite
                            
                              " modifiers
    5              0.000012000   syn match rubyLineContinuation    "\\$" nextgroup=@rubyModifier skipwhite skipnl
    5              0.000015000   syn match rubyConditionalModifier "\<\%(if\|unless\)\>"
    5              0.000014000   syn match rubyRepeatModifier	    "\<\%(while\|until\)\>"
    5              0.000009000   syn match rubyRescueModifier	    "\<rescue\>"
                            
    5              0.000022000   syn cluster rubyModifier contains=rubyConditionalModifier,rubyRepeatModifier,rubyRescueModifier
                            
    5   0.000188000   0.000144000   SynFold 'do' syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
                              " curly bracket block or hash literal
    5   0.000164000   0.000127000   SynFold '{' syn region rubyCurlyBlock   matchgroup=rubyCurlyBlockDelimiter start="{"						    end="}" contains=ALLBUT,@rubyNotTop
    5   0.000203000   0.000160000   SynFold '[' syn region rubyArrayLiteral matchgroup=rubyArrayDelimiter      start="\%(\%(\w\|[^\x00-\x7F]\)[?!]\=\|[]})]\)\@2<!\[" end="]" contains=ALLBUT,@rubyNotTop
                            
                              " statements without 'do'
    5   0.000176000   0.000137000   SynFold 'begin' syn region rubyBlockExpression matchgroup=rubyControl     start="\<begin\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
    5   0.000190000   0.000149000   SynFold 'case'  syn region rubyCaseExpression  matchgroup=rubyConditional start="\<case\>"  skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
    5   0.000299000   0.000216000   SynFold 'if' syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\<then\s\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
    5              0.000021000   syn match rubyConditional "\<\%(then\|else\|when\)\>"	 contained containedin=rubyCaseExpression
    5              0.000019000   syn match rubyConditional "\<\%(then\|else\|elsif\)\>" contained containedin=rubyConditionalExpression
                            
    5              0.000030000   syn match   rubyExceptionHandler  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>" contained containedin=rubyBlockExpression,rubyDoBlock
    5              0.000032000   syn match   rubyExceptionHandler2 "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>" contained containedin=rubyModuleBlock,rubyClassBlock,rubyMethodBlock
    5              0.000014000   syn cluster rubyExceptionHandler  contains=rubyExceptionHandler,rubyExceptionHandler2
                            
                              " statements with optional 'do'
    5              0.000054000   syn region rubyOptionalDoLine matchgroup=rubyRepeat start="\<for\>" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![!?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\<do\>" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
                            
    5   0.000305000   0.000240000   SynFold 'for' syn region rubyRepeatExpression start="\<for\>" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![!?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine
                            
                            else
                              syn match rubyControl "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
                              syn match rubyControl "\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
                              syn match rubyControl "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
                              syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|rescue\|ensure\|then\|when\|end\)\>"
                              syn match rubyKeyword "\<\%(alias\|undef\)\>"
    5              0.000003000 endif
                            
    5              0.000013000 if !exists("ruby_minlines")
                              let ruby_minlines = 500
    5              0.000001000 endif
    5              0.000016000 exe "syn sync minlines=" . ruby_minlines
                            
                            " Special Methods {{{1
    5              0.000009000 if !exists("ruby_no_special_methods")
    5              0.000015000   syn match rubyAccess	  "\<\%(public\|protected\|private\)\>" " use re=2
    5              0.000023000   syn match rubyAccess	  "\%#=1\<\%(public\|private\)_class_method\>"
    5              0.000017000   syn match rubyAccess	  "\%#=1\<\%(public\|private\)_constant\>"
    5              0.000012000   syn match rubyAccess	  "\%#=1\<module_function\>"
    5              0.000024000   syn match rubyAttribute "\%#=1\%(\%(^\|;\)\s*\)\@<=attr\>\%(\s*[.=]\)\@!" " attr is a common variable name
    5              0.000023000   syn match rubyAttribute "\%#=1\<attr_\%(accessor\|reader\|writer\)\>"
    5              0.000022000   syn match rubyControl   "\%#=1\<\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>"
    5              0.000010000   syn match rubyEval	  "\%#=1\<eval\>"
    5              0.000019000   syn match rubyEval	  "\%#=1\<\%(class\|instance\|module\)_eval\>"
    5              0.000017000   syn match rubyException "\%#=1\<\%(raise\|fail\|catch\|throw\)\>"
    5              0.000024000   syn match rubyInclude   "\%#=1\<\%(autoload\|gem\|load\|require\%(_relative\)\=\)\>"
    5              0.000019000   syn match rubyKeyword   "\%#=1\<\%(callcc\|caller\|lambda\|proc\)\>"
    5              0.000019000   syn match rubyMacro	  "\%#=1\<\%(extend\|include\|prepend\|refine\|using\)\>"
    5              0.000026000   syn match rubyMacro	  "\%#=1\<\%(alias\|define\|define_singleton\|remove\|undef\)_method\>"
    5              0.000003000 endif
                            
                            " Comments and Documentation {{{1
    5              0.000012000 syn match   rubySharpBang    "\%^#!.*" display
    5              0.000020000 syn keyword rubyTodo	     FIXME NOTE TODO OPTIMIZE HACK REVIEW XXX todo contained
    5              0.000011000 syn match   rubyEncoding     "[[:alnum:]-_]\+" contained display
    5              0.000023000 syn match   rubyMagicComment "\c\%<3l#\s*\zs\%(coding\|encoding\):"					contained nextgroup=rubyEncoding skipwhite
    5              0.000030000 syn match   rubyMagicComment "\c\%<10l#\s*\zs\%(frozen[-_]string[-_]literal\|warn[-_]indent\|warn[-_]past[-_]scope\):" contained nextgroup=rubyBoolean  skipwhite
    5              0.000023000 syn match   rubyMagicComment "\c\%<10l#\s*\zs\%(shareable[-_]constant[-_]value\):"				contained nextgroup=rubyEncoding  skipwhite
    5              0.000026000 syn match   rubyComment	     "#.*" contains=@rubyCommentSpecial,rubySpaceError,@Spell
                            
    5              0.000018000 syn cluster rubyCommentSpecial contains=rubySharpBang,rubyTodo,rubyMagicComment
    5              0.000013000 syn cluster rubyCommentNotTop  contains=@rubyCommentSpecial,rubyEncoding
                            
    5   0.000043000   0.000037000 if !exists("ruby_no_comment_fold") && s:foldable('#')
    5              0.000029000   syn region rubyMultilineComment start="^\s*#.*\n\%(^\s*#\)\@=" end="^\s*#.*\n\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
    5              0.000033000   syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$"      contains=rubySpaceError,rubyTodo,@Spell fold
                            else
                              syn region rubyDocumentation	  start="^=begin\s*$"		 end="^=end\s*$"              contains=rubySpaceError,rubyTodo,@Spell
    5              0.000002000 endif
                            
                            " {{{1 Useless Line Continuations
    5              0.000033000 syn match rubyUselessLineContinuation "\%([.:,;{([<>~\*%&^|+=-]\|%(\%(\w\|[^\x00-\x7F]\)\@1<![?!]\)\s*\zs\\$" nextgroup=rubyUselessLineContinuation skipwhite skipempty
    5              0.000013000 syn match rubyUselessLineContinuation "\\$"								      nextgroup=rubyUselessLineContinuation skipwhite skipempty contained
                            
                            " Keyword Nobbling {{{1
                            " prevent methods with keyword names being highlighted as keywords when called
    5              0.000037000 syn match rubyKeywordAsMethod "\%(\%(\.\@1<!\.\)\|&\.\|::\)\_s*\%([_[:lower:]][_[:alnum:]]*\|\%(BEGIN\|END\)\>\)" transparent contains=rubyDotOperator,rubyScopeOperator
                            
                            " Bang and Predicate Methods and Operators {{{1
    5              0.000018000 syn match rubyBangPredicateMethod "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[?!]"
                            
    5              0.000009000 if !exists("ruby_no_special_methods")
    5              0.000012000   syn match rubyControl "\%#=1\<exit!" display
    5              0.000004000 endif
    5              0.000016000 syn match rubyDefinedOperator "\%#=1\<defined?" display
                            
                            " 1.9-style Hash Keys and Keyword Parameters {{{1
    5              0.000031000 syn match rubySymbol "\%(\w\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[?!]\=::\@!"he=e-1 contained containedin=rubyBlockParameterList,rubyCurlyBlock
    5              0.000032000 syn match rubySymbol "[]})\"':]\@1<!\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],;]\@="he=e-1
    5              0.000022000 syn match rubySymbol "[[:space:],{(]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],;]\@="hs=s+1,he=e-1
    5              0.000010000 syn match rubySingleQuoteSymbolDelimiter "'" contained
    5              0.000049000 syn match rubySymbol "'\%(\\.\|[^']\)*'::\@!"he=e-1 contains=rubyQuoteEscape,rubyBackslashEscape,rubySingleQuoteSymbolDelimiter
    5              0.000010000 syn match rubyDoubleQuoteSymbolDelimiter "\"" contained
    5              0.000028000 syn match rubySymbol "\"\%(\\.\|[^\"]\)*\"::\@!"he=e-1 contains=@rubyStringSpecial,rubyDoubleQuoteSymbolDelimiter
                            
                            " __END__ Directive {{{1
    5   0.000170000   0.000129000 SynFold '__END__' syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$"
                            
                            " Default Highlighting {{{1
    5              0.000010000 hi def link rubyClass			rubyDefine
    5              0.000008000 hi def link rubyModule			rubyDefine
    5              0.000009000 hi def link rubyExceptionHandler2	rubyDefine
    5              0.000032000 hi def link rubyDefine			Define
    5              0.000008000 hi def link rubyAccess			rubyMacro
    5              0.000005000 hi def link rubyAttribute		rubyMacro
    5              0.000021000 hi def link rubyMacro			Macro
    5              0.000008000 hi def link rubyMethodName		rubyFunction
    5              0.000019000 hi def link rubyFunction		Function
    5              0.000021000 hi def link rubyConditional		Conditional
    5              0.000011000 hi def link rubyConditionalModifier	rubyConditional
    5              0.000009000 hi def link rubyExceptionHandler	rubyConditional
    5              0.000008000 hi def link rubyRescueModifier		rubyExceptionHandler
    5              0.000020000 hi def link rubyRepeat			Repeat
    5              0.000007000 hi def link rubyRepeatModifier		rubyRepeat
    5              0.000007000 hi def link rubyOptionalDo		rubyRepeat
    5              0.000019000 hi def link rubyControl			Statement
    5              0.000018000 hi def link rubyInclude			Include
    5              0.000021000 hi def link rubyInteger			Number
    5              0.000020000 hi def link rubyCharacter		Character
    5              0.000020000 hi def link rubyFloat			Float
    5              0.000019000 hi def link rubyBoolean			Boolean
    5              0.000019000 hi def link rubyException		Exception
    5              0.000009000 if !exists("ruby_no_identifiers")
    5              0.000019000   hi def link rubyIdentifier		Identifier
                            else
                              hi def link rubyIdentifier		NONE
    5              0.000002000 endif
    5              0.000009000 hi def link rubyClassVariable		rubyIdentifier
    5              0.000020000 hi def link rubyConstant		Type
    5              0.000010000 hi def link rubyClassName		rubyConstant
    5              0.000011000 hi def link rubyModuleName		rubyConstant
    5              0.000008000 hi def link rubyGlobalVariable		rubyIdentifier
    5              0.000007000 hi def link rubyInstanceVariable	rubyIdentifier
    5              0.000008000 hi def link rubyPredefinedIdentifier	rubyIdentifier
    5              0.000008000 hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
    5              0.000007000 hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
    5              0.000021000 hi def link rubySymbol			Constant
    5              0.000020000 hi def link rubyKeyword			Keyword
                            
    5              0.000018000 hi def link rubyOperator		Operator
    5              0.000006000 hi def link rubyDefinedOperator		rubyOperator
    5              0.000010000 hi def link rubyEnglishBooleanOperator	rubyOperator
    5              0.000008000 if exists("ruby_operators")
                              hi def link rubyTernaryOperator	rubyOperator
                              hi def link rubyArithmeticOperator	rubyOperator
                              hi def link rubyComparisonOperator	rubyOperator
                              hi def link rubyBitwiseOperator	rubyOperator
                              hi def link rubyBooleanOperator	rubyOperator
                              hi def link rubyRangeOperator		rubyOperator
                              hi def link rubyAssignmentOperator	rubyOperator
                              hi def link rubyEqualityOperator	rubyOperator
    5              0.000001000 endif
                            
    5              0.000006000 if exists("ruby_pseudo_operators")
                              hi def link rubyPseudoOperator	Special
                              hi def link rubyDotOperator		rubyPseudoOperator
                              hi def link rubyScopeOperator		rubyPseudoOperator
                              hi def link rubySuperClassOperator	rubyPseudoOperator
                              hi def link rubyEigenClassOperator	rubyPseudoOperator
                              hi def link rubyLambdaOperator	rubyPseudoOperator
                              hi def link rubyDoubleSplatOperator	rubyPseudoOperator
                              hi def link rubySplatOperator		rubyPseudoOperator
                              hi def link rubyProcOperator		rubyPseudoOperator
    5              0.000014000 endif
                            
    5              0.000023000 hi def link rubyBeginEnd		Statement
    5              0.000020000 hi def link rubyEval			Statement
    5              0.000023000 hi def link rubyPseudoVariable		Constant
    5              0.000020000 hi def link rubyCapitalizedMethod	NONE
                            
    5              0.000022000 hi def link rubyComment			Comment
    5              0.000020000 hi def link rubyEncoding		Constant
    5              0.000020000 hi def link rubyMagicComment		SpecialComment
    5              0.000019000 hi def link rubyData			Comment
    5              0.000020000 hi def link rubyDataDirective		Delimiter
    5              0.000020000 hi def link rubyDocumentation		Comment
    5              0.000018000 hi def link rubyTodo			Todo
                            
    5              0.000011000 hi def link rubyBackslashEscape		rubyStringEscape
    5              0.000010000 hi def link rubyQuoteEscape		rubyStringEscape
    5              0.000010000 hi def link rubySpaceEscape		rubyStringEscape
    5              0.000011000 hi def link rubyParenthesisEscape	rubyStringEscape
    5              0.000009000 hi def link rubyCurlyBraceEscape	rubyStringEscape
    5              0.000010000 hi def link rubyAngleBracketEscape	rubyStringEscape
    5              0.000010000 hi def link rubySquareBracketEscape	rubyStringEscape
    5              0.000024000 hi def link rubyStringEscape		Special
                            
    5              0.000030000 hi def link rubyInterpolationDelimiter	Delimiter
    5              0.000020000 hi def link rubySharpBang		PreProc
    5              0.000030000 hi def link rubyStringDelimiter		Delimiter
    5              0.000017000 hi def link rubyHeredocDelimiter	rubyStringDelimiter
    5              0.000014000 hi def link rubyPercentRegexpDelimiter	rubyRegexpDelimiter
    5              0.000016000 hi def link rubyPercentStringDelimiter	rubyStringDelimiter
    5              0.000010000 hi def link rubyPercentSymbolDelimiter	rubySymbolDelimiter
    5              0.000017000 hi def link rubyDoubleQuoteSymbolDelimiter rubySymbolDelimiter
    5              0.000011000 hi def link rubySingleQuoteSymbolDelimiter rubySymbolDelimiter
    5              0.000020000 hi def link rubyRegexpDelimiter		rubyStringDelimiter
    5              0.000010000 hi def link rubySymbolDelimiter		rubySymbol
    5              0.000020000 hi def link rubyString			String
    5              0.000011000 hi def link rubyRegexpEscape		rubyRegexpSpecial
    5              0.000009000 hi def link rubyRegexpQuantifier	rubyRegexpSpecial
    5              0.000010000 hi def link rubyRegexpAnchor		rubyRegexpSpecial
    5              0.000009000 hi def link rubyRegexpDot		rubyRegexpCharClass
    5              0.000010000 hi def link rubyRegexpCharClass		rubyRegexpSpecial
    5              0.000009000 hi def link rubyRegexpIntersection	rubyRegexpSpecial
    5              0.000023000 hi def link rubyRegexpSpecial		Special
    5              0.000022000 hi def link rubyRegexpComment		Comment
    5              0.000008000 hi def link rubyRegexp			rubyString
                            
    5              0.000018000 hi def link rubyError			Error
    5              0.000011000 if exists("ruby_line_continuation_error")
                              hi def link rubyUselessLineContinuation rubyError
    5              0.000004000 endif
    5              0.000008000 hi def link rubyGlobalVariableError	rubyError
    5              0.000006000 hi def link rubySpaceError		rubyError
                            
                            " Postscript {{{1
    5              0.000011000 let b:current_syntax = "ruby"
                            
    5              0.000016000 let &cpo = s:cpo_sav
    5              0.000004000 unlet! s:cpo_sav
                            
    5              0.000010000 delc SynFold
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/python.vim
Sourced 5 times
Total time:   0.003255000
 Self time:   0.003255000

count     total (s)      self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2023 Feb 28
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            " The use of Python 2 compatible syntax highlighting can be enforced.
                            " The straddling code (Python 2 and 3 compatible), up to Python 3.5,
                            " will be also supported.
                            "
                            "   let python_use_python2_syntax = 1
                            "
                            " This option will exclude all modern Python 3.6 or higher features.
                            "
                            
                            " quit when a syntax file was already loaded.
    5              0.000011000 if exists("b:current_syntax")
                              finish
    5              0.000002000 endif
                            
                            " Use of Python 2 and 3.5 or lower requested.
    5              0.000008000 if exists("python_use_python2_syntax")
                              runtime! syntax/python2.vim
                              finish
    5              0.000004000 endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    5              0.000009000 let s:cpo_save = &cpo
    5              0.000011000 set cpo&vim
                            
    5              0.000008000 if exists("python_no_doctest_highlight")
                              let python_no_doctest_code_highlight = 1
    5              0.000004000 endif
                            
    5              0.000010000 if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
    5              0.000002000 endif
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " The list can be checked using:
                            "
                            " python3 -c 'import keyword, pprint; pprint.pprint(keyword.kwlist + keyword.softkwlist, compact=True)'
                            "
    5              0.000017000 syn keyword pythonStatement	False None True
    5              0.000015000 syn keyword pythonStatement	as assert break continue del global
    5              0.000016000 syn keyword pythonStatement	lambda nonlocal pass return with yield
    5              0.000040000 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    5              0.000023000 syn keyword pythonConditional	elif else if
    5              0.000021000 syn keyword pythonRepeat	for while
    5              0.000024000 syn keyword pythonOperator	and in is not or
    5              0.000023000 syn keyword pythonException	except finally raise try
    5              0.000023000 syn keyword pythonInclude	from import
    5              0.000007000 syn keyword pythonAsync		async await
                            
                            " Soft keywords
                            " These keywords do not mean anything unless used in the right context.
                            " See https://docs.python.org/3/reference/lexical_analysis.html#soft-keywords
                            " for more on this.
    5              0.000030000 syn match   pythonConditional   "^\s*\zscase\%(\s\+.*:.*$\)\@="
    5              0.000029000 syn match   pythonConditional   "^\s*\zsmatch\%(\s\+.*:\s*\%(#.*\)\=$\)\@="
                            
                            " Decorators
                            " A dot must be allowed because of @MyClass.myfunc decorators.
    5              0.000019000 syn match   pythonDecorator	"@" display contained
    5              0.000042000 syn match   pythonDecoratorName	"@\s*\h\%(\w\|\.\)*" display contains=pythonDecorator
                            
                            " Python 3.5 introduced the use of the same symbol for matrix multiplication:
                            " https://www.python.org/dev/peps/pep-0465/.  We now have to exclude the
                            " symbol from highlighting when used in that context.
                            " Single line multiplication.
    5              0.000090000 syn match   pythonMatrixMultiply
                                  \ "\%(\w\|[])]\)\s*@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication continued on the next line after backslash.
    5              0.000087000 syn match   pythonMatrixMultiply
                                  \ "[^\\]\\\s*\n\%(\s*\.\.\.\s\)\=\s\+@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication in a parenthesized expression over multiple lines with @ at
                            " the start of each continued line; very similar to decorators and complex.
    5              0.000103000 syn match   pythonMatrixMultiply
                                  \ "^\s*\%(\%(>>>\|\.\.\.\)\s\+\)\=\zs\%(\h\|\%(\h\|[[(]\).\{-}\%(\w\|[])]\)\)\s*\n\%(\s*\.\.\.\s\)\=\s\+@\%(.\{-}\n\%(\s*\.\.\.\s\)\=\s\+@\)*"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            
    5              0.000022000 syn match   pythonFunction	"\h\w*" display contained
                            
    5              0.000017000 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    5              0.000017000 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    5              0.000033000 syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    5              0.000033000 syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    5              0.000026000 syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    5              0.000033000 syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    5              0.000024000 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    5              0.000009000 syn match   pythonEscape	"\\\o\{1,3}" contained
    5              0.000010000 syn match   pythonEscape	"\\x\x\{2}" contained
    5              0.000015000 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    5              0.000014000 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    5              0.000007000 syn match   pythonEscape	"\\$"
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/reference/lexical_analysis.html#numeric-literals
    5              0.000012000 if !exists("python_no_number_highlight")
                              " numbers (including complex)
    5              0.000020000   syn match   pythonNumber	"\<0[oO]\%(_\=\o\)\+\>"
    5              0.000010000   syn match   pythonNumber	"\<0[xX]\%(_\=\x\)\+\>"
    5              0.000014000   syn match   pythonNumber	"\<0[bB]\%(_\=[01]\)\+\>"
    5              0.000015000   syn match   pythonNumber	"\<\%([1-9]\%(_\=\d\)*\|0\+\%(_\=0\)*\)\>"
    5              0.000012000   syn match   pythonNumber	"\<\d\%(_\=\d\)*[jJ]\>"
    5              0.000023000   syn match   pythonNumber	"\<\d\%(_\=\d\)*[eE][+-]\=\d\%(_\=\d\)*[jJ]\=\>"
    5              0.000023000   syn match   pythonNumber
                                    \ "\<\d\%(_\=\d\)*\.\%([eE][+-]\=\d\%(_\=\d\)*\)\=[jJ]\=\%(\W\|$\)\@="
    5              0.000021000   syn match   pythonNumber
                                    \ "\%(^\|\W\)\zs\%(\d\%(_\=\d\)*\)\=\.\d\%(_\=\d\)*\%([eE][+-]\=\d\%(_\=\d\)*\)\=[jJ]\=\>"
    5              0.000004000 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/library/constants.html
                            " http://docs.python.org/library/functions.html
                            " Python built-in functions are in alphabetical order.
                            "
                            " The list can be checked using:
                            "
                            " python3 -c 'import builtins, pprint; pprint.pprint(dir(builtins), compact=True)'
                            "
                            " The constants added by the `site` module are not listed below because they
                            " should not be used in programs, only in interactive interpreter.
                            " Similarly for some other attributes and functions `__`-enclosed from the
                            " output of the above command.
                            "
    5              0.000011000 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
    5              0.000024000   syn keyword pythonBuiltin	False True None
    5              0.000027000   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " constants added by the `site` module
    5              0.000023000   syn keyword pythonBuiltin	quit exit copyright credits license
                              " built-in functions
    5              0.000025000   syn keyword pythonBuiltin	abs all any ascii bin bool breakpoint bytearray
    5              0.000027000   syn keyword pythonBuiltin	bytes callable chr classmethod compile complex
    5              0.000024000   syn keyword pythonBuiltin	delattr dict dir divmod enumerate eval exec
    5              0.000029000   syn keyword pythonBuiltin	filter float format frozenset getattr globals
    5              0.000024000   syn keyword pythonBuiltin	hasattr hash help hex id input int isinstance
    5              0.000022000   syn keyword pythonBuiltin	issubclass iter len list locals map max
    5              0.000027000   syn keyword pythonBuiltin	memoryview min next object oct open ord pow
    5              0.000031000   syn keyword pythonBuiltin	print property range repr reversed round set
    5              0.000026000   syn keyword pythonBuiltin	setattr slice sorted staticmethod str sum super
    5              0.000021000   syn keyword pythonBuiltin	tuple type vars zip __import__
                              " avoid highlighting attributes as builtins
    5              0.000079000   syn match   pythonAttribute	/\.\h\w*/hs=s+1
                            	\ contains=ALLBUT,pythonBuiltin,pythonFunction,pythonAsync
                            	\ transparent
    5              0.000004000 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/library/exceptions.html
    5              0.000008000 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
    5              0.000026000   syn keyword pythonExceptions	BaseException Exception
    5              0.000022000   syn keyword pythonExceptions	ArithmeticError BufferError LookupError
                              " builtin exceptions (actually raised)
    5              0.000021000   syn keyword pythonExceptions	AssertionError AttributeError EOFError
    5              0.000024000   syn keyword pythonExceptions	FloatingPointError GeneratorExit ImportError
    5              0.000020000   syn keyword pythonExceptions	IndentationError IndexError KeyError
    5              0.000023000   syn keyword pythonExceptions	KeyboardInterrupt MemoryError
    5              0.000022000   syn keyword pythonExceptions	ModuleNotFoundError NameError
    5              0.000022000   syn keyword pythonExceptions	NotImplementedError OSError OverflowError
    5              0.000019000   syn keyword pythonExceptions	RecursionError ReferenceError RuntimeError
    5              0.000022000   syn keyword pythonExceptions	StopAsyncIteration StopIteration SyntaxError
    5              0.000025000   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    5              0.000024000   syn keyword pythonExceptions	UnboundLocalError UnicodeDecodeError
    5              0.000018000   syn keyword pythonExceptions	UnicodeEncodeError UnicodeError
    5              0.000020000   syn keyword pythonExceptions	UnicodeTranslateError ValueError
    5              0.000022000   syn keyword pythonExceptions	ZeroDivisionError
                              " builtin exception aliases for OSError
    5              0.000024000   syn keyword pythonExceptions	EnvironmentError IOError WindowsError
                              " builtin OS exceptions in Python 3
    5              0.000019000   syn keyword pythonExceptions	BlockingIOError BrokenPipeError
    5              0.000027000   syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
    5              0.000020000   syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
    5              0.000022000   syn keyword pythonExceptions	ConnectionResetError FileExistsError
    5              0.000024000   syn keyword pythonExceptions	FileNotFoundError InterruptedError
    5              0.000020000   syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
    5              0.000020000   syn keyword pythonExceptions	PermissionError ProcessLookupError TimeoutError
                              " builtin warnings
    5              0.000026000   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    5              0.000021000   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    5              0.000023000   syn keyword pythonExceptions	ResourceWarning RuntimeWarning
    5              0.000023000   syn keyword pythonExceptions	SyntaxWarning UnicodeWarning
    5              0.000020000   syn keyword pythonExceptions	UserWarning Warning
    5              0.000002000 endif
                            
    5              0.000006000 if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
    5              0.000003000 endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    5              0.000008000 if !exists("python_no_doctest_highlight")
    5              0.000009000   if !exists("python_no_doctest_code_highlight")
    5              0.000058000     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,pythonFunction,@Spell
    5              0.000023000     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
                              else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
    5              0.000004000   endif
    5              0.000002000 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    5              0.000024000 syn sync match pythonSync grouphere NONE "^\%(def\|class\)\s\+\h\w*\s*[(:]"
                            
                            " The default highlight links.  Can be overridden later.
    5              0.000022000 hi def link pythonStatement		Statement
    5              0.000031000 hi def link pythonConditional		Conditional
    5              0.000033000 hi def link pythonRepeat		Repeat
    5              0.000031000 hi def link pythonOperator		Operator
    5              0.000029000 hi def link pythonException		Exception
    5              0.000031000 hi def link pythonInclude		Include
    5              0.000019000 hi def link pythonAsync			Statement
    5              0.000031000 hi def link pythonDecorator		Define
    5              0.000019000 hi def link pythonDecoratorName		Function
    5              0.000031000 hi def link pythonFunction		Function
    5              0.000020000 hi def link pythonComment		Comment
    5              0.000018000 hi def link pythonTodo			Todo
    5              0.000019000 hi def link pythonString		String
    5              0.000019000 hi def link pythonRawString		String
    5              0.000020000 hi def link pythonQuotes		String
    5              0.000006000 hi def link pythonTripleQuotes		pythonQuotes
    5              0.000019000 hi def link pythonEscape		Special
    5              0.000008000 if !exists("python_no_number_highlight")
    5              0.000020000   hi def link pythonNumber		Number
    5              0.000004000 endif
    5              0.000007000 if !exists("python_no_builtin_highlight")
    5              0.000031000   hi def link pythonBuiltin		Function
    5              0.000003000 endif
    5              0.000009000 if !exists("python_no_exception_highlight")
    5              0.000030000   hi def link pythonExceptions		Structure
    5              0.000003000 endif
    5              0.000008000 if exists("python_space_error_highlight")
                              hi def link pythonSpaceError		Error
    5              0.000003000 endif
    5              0.000007000 if !exists("python_no_doctest_highlight")
    5              0.000019000   hi def link pythonDoctest		Special
    5              0.000019000   hi def link pythonDoctestValue	Define
    5              0.000003000 endif
                            
    5              0.000008000 let b:current_syntax = "python"
                            
    5              0.000014000 let &cpo = s:cpo_save
    5              0.000004000 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /Users/peter.duke/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/tabnr.vim
Sourced 1 time
Total time:   0.000028000
 Self time:   0.000028000

count     total (s)      self (s)
                            " MIT License. Copyright (c) 2017-2021 Christian Brabandt et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000003000 scriptencoding utf-8
                            
    1              0.000004000 function! airline#extensions#tabline#formatters#tabnr#format(tab_nr, buflist)
                              let spc=g:airline_symbols.space
                              let tab_nr_type = get(g:, 'airline#extensions#tabline#tab_nr_type', 0)
                              if tab_nr_type == 0 " nr of splits
                                return spc. len(tabpagebuflist(a:tab_nr))
                              elseif tab_nr_type == 1 " tab number
                                " Return only the current tab number
                                return spc. a:tab_nr
                              else " tab_nr_type == 2 splits and tab number
                                " return the tab number followed by the number of buffers (in the tab)
                                return spc. a:tab_nr. spc. len(tabpagebuflist(a:tab_nr))
                              endif
                            endfunction

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/scripts.vim
Sourced 3 times
Total time:   0.002642000
 Self time:   0.002642000

count     total (s)      self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 27
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            
                            
                            " Bail out when a FileType autocommand has already set the filetype.
    3              0.000010000 if did_filetype()
                              finish
    3              0.000003000 endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    3              0.000011000 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    3              0.000001000 endif
                            
                            " The main code is in a compiled function for speed.
    3              0.002557000 call dist#script#DetectFiletype()

SCRIPT  /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/autoload/dist/script.vim
Sourced 1 time
Total time:   0.000868000
 Self time:   0.000868000

count     total (s)      self (s)
    1              0.000004000 vim9script
                            
                            # Vim function for detecting a filetype from the file contents.
                            # Invoked from "scripts.vim" in 'runtimepath'
                            #
                            # Maintainer:	The Vim Project <https://github.com/vim/vim>
                            # Last Change:	2023 Aug 10
                            # Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
    1              0.000008000 export def DetectFiletype()
                              var line1 = getline(1)
                              if line1[0] == '#' && line1[1] == '!'
                                # File that starts with "#!".
                                DetectFromHashBang(line1)
                              else
                                # File does not start with "#!".
                                DetectFromText(line1)
                              endif
                            enddef
                            
                            # Called for a script that has "#!" in the first line.
    1              0.000006000 def DetectFromHashBang(firstline: string)
                              var line1 = firstline
                            
                              # Check for a line like "#!/usr/bin/env {options} bash".  Turn it into
                              # "#!/usr/bin/bash" to make matching easier.
                              # Recognize only a few {options} that are commonly used.
                              if line1 =~ '^#!\s*\S*\<env\s'
                                line1 = substitute(line1, '\S\+=\S\+', '', 'g')
                                line1 = substitute(line1, '\(-[iS]\|--ignore-environment\|--split-string\)', '', '')
                                line1 = substitute(line1, '\<env\s\+', '', '')
                              endif
                            
                              # Get the program name.
                              # Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              # If the word env is used, use the first word after the space:
                              # "#!/usr/bin/env perl [path/args]"
                              # If there is no path use the first word: "#!perl [path/args]".
                              # Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              var name: string
                              if line1 =~ '^#!\s*\a:[/\\]'
                                name = substitute(line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif line1 =~ '^#!.*\<env\>'
                                name = substitute(line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif line1 =~ '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                name = substitute(line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                name = substitute(line1, '^#!\s*\S*[/\\]\(\f\+\).*', '\1', '')
                              endif
                            
                              # tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              # third line.  Suggested by Steven Atkinson.
                              if getline(3) =~ '^exec wish'
                                name = 'wish'
                              endif
                            
                              var ft = Exe2filetype(name, line1)
                              if ft != ''
                                exe 'setl ft=' .. ft
                              endif
                            enddef
                            
                            # Returns the filetype name associated with program "name".
                            # "line1" is the #! line at the top of the file.  Use the same as "name" if
                            # not available.
                            # Returns an empty string when not recognized.
    1              0.000006000 export def Exe2filetype(name: string, line1: string): string
                                # Bourne-like shell scripts: bash bash2 dash ksh ksh93 sh
                              if name =~ '^\(bash\d*\|dash\|ksh\d*\|sh\)\>'
                                return dist#ft#SetFileTypeSH(line1, false)
                            
                                # csh scripts
                              elseif name =~ '^csh\>'
                                return dist#ft#SetFileTypeShell(exists("g:filetype_csh") ? g:filetype_csh : 'csh', false)
                            
                                # tcsh scripts
                              elseif name =~ '^tcsh\>'
                                return dist#ft#SetFileTypeShell("tcsh", false)
                            
                                # Z shell scripts
                              elseif name =~ '^zsh\>'
                                return 'zsh'
                            
                                # TCL scripts
                              elseif name =~ '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                return 'tcl'
                            
                                # Expect scripts
                              elseif name =~ '^expect\>'
                                return 'expect'
                            
                                # Gnuplot scripts
                              elseif name =~ '^gnuplot\>'
                                return 'gnuplot'
                            
                                # Makefiles
                              elseif name =~ 'make\>'
                                return 'make'
                            
                                # Pike
                              elseif name =~ '^pike\%(\>\|[0-9]\)'
                                return 'pike'
                            
                                # Lua
                              elseif name =~ 'lua'
                                return 'lua'
                            
                                # Perl
                              elseif name =~ 'perl'
                                return 'perl'
                            
                                # PHP
                              elseif name =~ 'php'
                                return 'php'
                            
                                # Python
                              elseif name =~ 'python'
                                return 'python'
                            
                                # Groovy
                              elseif name =~ '^groovy\>'
                                return 'groovy'
                            
                                # Raku
                              elseif name =~ 'raku'
                                return 'raku'
                            
                                # Ruby
                              elseif name =~ 'ruby'
                                return 'ruby'
                            
                                # JavaScript
                              elseif name =~ 'node\(js\)\=\>\|js\>' || name =~ 'rhino\>'
                                return 'javascript'
                            
                                # BC calculator
                              elseif name =~ '^bc\>'
                                return 'bc'
                            
                                # sed
                              elseif name =~ 'sed\>'
                                return 'sed'
                            
                                # OCaml-scripts
                              elseif name =~ 'ocaml'
                                return 'ocaml'
                            
                                # Awk scripts; also finds "gawk"
                              elseif name =~ 'awk\>'
                                return 'awk'
                            
                                # Website MetaLanguage
                              elseif name =~ 'wml'
                                return 'wml'
                            
                                # Scheme scripts
                              elseif name =~ 'scheme'
                                return 'scheme'
                            
                                # CFEngine scripts
                              elseif name =~ 'cfengine'
                                return 'cfengine'
                            
                                # Erlang scripts
                              elseif name =~ 'escript'
                                return 'erlang'
                            
                                # Haskell
                              elseif name =~ 'haskell'
                                return 'haskell'
                            
                                # Scala
                              elseif name =~ 'scala\>'
                                return 'scala'
                            
                                # Clojure
                              elseif name =~ 'clojure'
                                return 'clojure'
                            
                                # Free Pascal
                              elseif name =~ 'instantfpc\>'
                                return 'pascal'
                            
                                # Fennel
                              elseif name =~ 'fennel\>'
                                return 'fennel'
                            
                                # MikroTik RouterOS script
                              elseif name =~ 'rsc\>'
                                return 'routeros'
                            
                                # Fish shell
                              elseif name =~ 'fish\>'
                                return 'fish'
                            
                                # Gforth
                              elseif name =~ 'gforth\>'
                                return 'forth'
                            
                                # Icon
                              elseif name =~ 'icon\>'
                                return 'icon'
                            
                                # Guile
                              elseif name =~ 'guile'
                                return 'scheme'
                            
                                # Nix
                              elseif name =~ 'nix-shell'
                                return 'nix'
                            
                                # Crystal
                              elseif name =~ '^crystal\>'
                                return 'crystal'
                            
                                # Rexx
                              elseif name =~ '^\%(rexx\|regina\)\>'
                                return 'rexx'
                            
                                # Janet
                              elseif name =~ '^janet\>'
                                return 'janet'
                            
                                # Dart
                              elseif name =~ '^dart\>'
                                return 'dart'
                            
                                # Execline (s6)
                              elseif name =~ '^execlineb\>'
                                return 'execline'
                            
                              endif
                            
                              return ''
                            enddef
                            
                            
                            # Called for a script that does not have "#!" in the first line.
    1              0.000004000 def DetectFromText(line1: string)
                              var line2 = getline(2)
                              var line3 = getline(3)
                              var line4 = getline(4)
                              var line5 = getline(5)
                            
                              # Bourne-like shell scripts: sh ksh bash bash2
                              if line1 =~ '^:$'
                                call dist#ft#SetFileTypeSH(line1)
                            
                              # Z shell scripts
                              elseif line1 =~ '^#compdef\>'
                                  || line1 =~ '^#autoload\>'
                                  || "\n" .. line1 .. "\n" .. line2 .. "\n" .. line3 ..
                            	 "\n" .. line4 .. "\n" .. line5
                            	 =~ '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                setl ft=zsh
                            
                              # ELM Mail files
                              elseif line1 =~ '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                setl ft=mail
                            
                              # Mason
                              elseif line1 =~ '^<[%&].*>'
                                setl ft=mason
                            
                              # Vim scripts (must have '" vim' as the first line to trigger this)
                              elseif line1 =~ '^" *[vV]im$'
                                setl ft=vim
                            
                              # libcxx and libstdc++ standard library headers like "iostream" do not have
                              # an extension, recognize the Emacs file mode.
                              elseif line1 =~? '-\*-.*C++.*-\*-'
                                setl ft=cpp
                            
                              # MOO
                              elseif line1 =~ '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                setl ft=moo
                            
                                # Diff file:
                                # - "diff" in first line (context diff)
                                # - "Only in " in first line
                                # - "--- " in first line and "+++ " in second line (unified diff).
                                # - "*** " in first line and "--- " in second line (context diff).
                                # - "# It was generated by makepatch " in the second line (makepatch diff).
                                # - "Index: <filename>" in the first line (CVS file)
                                # - "=== ", line of "=", "---", "+++ " (SVK diff)
                                # - "=== ", "--- ", "+++ " (bzr diff, common case)
                                # - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                # - "# HG changeset patch" in first line (Mercurial export format)
                              elseif line1 =~ '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	 || (line1 =~ '^--- ' && line2 =~ '^+++ ')
                            	 || (line1 =~ '^\* looking for ' && line2 =~ '^\* comparing to ')
                            	 || (line1 =~ '^\*\*\* ' && line2 =~ '^--- ')
                            	 || (line1 =~ '^=== ' && ((line2 =~ '^=\{66\}' && line3 =~ '^--- ' && line4 =~ '^+++') || (line2 =~ '^--- ' && line3 =~ '^+++ ')))
                            	 || (line1 =~ '^=== \(removed\|added\|renamed\|modified\)')
                                setl ft=diff
                            
                                # PostScript Files (must have %!PS as the first line, like a2ps output)
                              elseif line1 =~ '^%![ \t]*PS'
                                setl ft=postscr
                            
                                # M4 scripts: Guess there is a line that starts with "dnl".
                              elseif line1 =~ '^\s*dnl\>'
                            	 || line2 =~ '^\s*dnl\>'
                            	 || line3 =~ '^\s*dnl\>'
                            	 || line4 =~ '^\s*dnl\>'
                            	 || line5 =~ '^\s*dnl\>'
                                setl ft=m4
                            
                                # AmigaDos scripts
                              elseif $TERM == "amiga" && (line1 =~ "^;" || line1 =~? '^\.bra')
                                setl ft=amiga
                            
                                # SiCAD scripts (must have procn or procd as the first line to trigger this)
                              elseif line1 =~? '^ *proc[nd] *$'
                                setl ft=sicad
                            
                                # Purify log files start with "****  Purify"
                              elseif line1 =~ '^\*\*\*\*  Purify'
                                setl ft=purifylog
                            
                                # XML
                              elseif line1 =~ '<?\s*xml.*?>'
                                setl ft=xml
                            
                                # XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                              elseif line1 =~ '\<DTD\s\+XHTML\s'
                                setl ft=xhtml
                            
                                # HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                # Avoid "doctype html", used by slim.
                              elseif line1 =~? '<!DOCTYPE\s\+html\>'
                                setl ft=html
                            
                                # PDF
                              elseif line1 =~ '^%PDF-'
                                setl ft=pdf
                            
                                # XXD output
                              elseif line1 =~ '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                setl ft=xxd
                            
                                # RCS/CVS log output
                              elseif line1 =~ '^RCS file:' || line2 =~ '^RCS file:'
                                setl ft=rcslog
                            
                                # CVS commit
                              elseif line2 =~ '^CVS:' || getline("$") =~ '^CVS: '
                                setl ft=cvs
                            
                                # Prescribe
                              elseif line1 =~ '^!R!'
                                setl ft=prescribe
                            
                                # Send-pr
                              elseif line1 =~ '^SEND-PR:'
                                setl ft=sendpr
                            
                                # SNNS files
                              elseif line1 =~ '^SNNS network definition file'
                                setl ft=snnsnet
                              elseif line1 =~ '^SNNS pattern definition file'
                                setl ft=snnspat
                              elseif line1 =~ '^SNNS result file'
                                setl ft=snnsres
                            
                                # Virata
                              elseif line1 =~ '^%.\{-}[Vv]irata'
                            	 || line2 =~ '^%.\{-}[Vv]irata'
                            	 || line3 =~ '^%.\{-}[Vv]irata'
                            	 || line4 =~ '^%.\{-}[Vv]irata'
                            	 || line5 =~ '^%.\{-}[Vv]irata'
                                setl ft=virata
                            
                                # Strace
                                # inaccurate fast match first, then use accurate slow match
                              elseif (line1 =~ 'execve(' && line1 =~ '^[0-9:. ]*execve(')
                            	   || line1 =~ '^__libc_start_main'
                                setl ft=strace
                            
                                # VSE JCL
                              elseif line1 =~ '^\* $$ JOB\>' || line1 =~ '^// *JOB\>'
                                setl ft=vsejcl
                            
                                # TAK and SINDA
                              elseif line4 =~ 'K & K  Associates' || line2 =~ 'TAK 2000'
                                setl ft=takout
                              elseif line3 =~ 'S Y S T E M S   I M P R O V E D '
                                setl ft=sindaout
                              elseif getline(6) =~ 'Run Date: '
                                setl ft=takcmp
                              elseif getline(9) =~ 'Node    File  1'
                                setl ft=sindacmp
                            
                                # DNS zone files
                              elseif line1 .. line2 .. line3 .. line4 =~ '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setl ft=bindzone
                            
                                # BAAN
                              elseif line1 =~ '|\*\{1,80}' && line2 =~ 'VRC '
                            	 || line2 =~ '|\*\{1,80}' && line3 =~ 'VRC '
                                setl ft=baan
                            
                                # Valgrind
                              elseif line1 =~ '^==\d\+== valgrind' || line3 =~ '^==\d\+== Using valgrind'
                                setl ft=valgrind
                            
                                # Go docs
                              elseif line1 =~ '^PACKAGE DOCUMENTATION$'
                                setl ft=godoc
                            
                                # Renderman Interface Bytestream
                              elseif line1 =~ '^##RenderMan'
                                setl ft=rib
                            
                                # Scheme scripts
                              elseif line1 =~ 'exec\s\+\S*scheme' || line2 =~ 'exec\s\+\S*scheme'
                                setl ft=scheme
                            
                                # Git output
                              elseif line1 =~ '^\(commit\|tree\|object\) \x\{40,\}\>\|^tag \S\+$'
                                setl ft=git
                            
                                # Gprof (gnu profiler)
                              elseif line1 == 'Flat profile:'
                            	&& line2 == ''
                            	&& line3 =~ '^Each sample counts as .* seconds.$'
                                setl ft=gprof
                            
                                # Erlang terms
                                # (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
                              elseif line1 =~? '-\*-.*erlang.*-\*-'
                                setl ft=erlang
                            
                                # YAML
                              elseif line1 =~ '^%YAML'
                                setl ft=yaml
                            
                                # MikroTik RouterOS script
                              elseif line1 =~ '^#.*by RouterOS.*$'
                                setl ft=routeros
                            
                                # Sed scripts
                                # #ncomment is allowed but most likely a false positive so require a space
                                # before any trailing comment text
                              elseif line1 =~ '^#n\%($\|\s\)'
                                setl ft=sed
                            
                              else
                                var lnum = 1
                                while getline(lnum) =~ "^? " && lnum < line("$")
                                  lnum += 1
                                endwhile
                                if getline(lnum) =~ '^Index:\s\+\f\+$'
                                  # CVS diff
                                  setl ft=diff
                            
                                  # locale input files: Formal Definitions of Cultural Conventions
                                  # filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                elseif expand("%") =~ '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  lnum = 1
                                  while lnum < 100 && lnum < line("$")
                            	if getline(lnum) =~ '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	lnum += 1
                                  endwhile
                                endif
                              endif
                            enddef

SCRIPT  /Users/peter.duke/.vim/plugged/ale/ale_linters/vim/ale_custom_linting_rules.vim
Sourced 1 time
Total time:   0.000276000
 Self time:   0.000113000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: A linter for checking ALE project code itself.
                            
    1              0.000009000 function! ale_linters#vim#ale_custom_linting_rules#GetExecutable(buffer) abort
                                let l:filename = expand('#' . a:buffer . ':p')
                                let l:dir_list = []
                            
                                for l:dir in split(&runtimepath, ',')
                                    if l:filename[:len(l:dir) - 1] is# l:dir
                                        call add(l:dir_list, l:dir)
                                    endif
                                endfor
                            
                                return !empty(l:dir_list)
                                \   ? findfile('test/script/custom-linting-rules', join(l:dir_list, ','))
                                \   : ''
                            endfunction
                            
    1              0.000002000 function! s:GetALEProjectDir(buffer) abort
                                let l:executable = ale_linters#vim#ale_custom_linting_rules#GetExecutable(a:buffer)
                            
                                return ale#path#Dirname(ale#path#Dirname(ale#path#Dirname(l:executable)))
                            endfunction
                            
    1              0.000002000 function! ale_linters#vim#ale_custom_linting_rules#GetCwd(buffer) abort
                                let l:executable = ale_linters#vim#ale_custom_linting_rules#GetExecutable(a:buffer)
                            
                                return ale#path#Dirname(ale#path#Dirname(ale#path#Dirname(l:executable)))
                            endfunction
                            
    1              0.000001000 function! ale_linters#vim#ale_custom_linting_rules#GetCommand(buffer) abort
                                let l:temp_dir = ale#command#CreateDirectory(a:buffer)
                                let l:temp_file = l:temp_dir . '/example.vim'
                            
                                let l:lines = getbufline(a:buffer, 1, '$')
                                call ale#util#Writefile(a:buffer, l:lines, l:temp_file)
                            
                                return '%e ' . ale#Escape(l:temp_dir)
                            endfunction
                            
    1              0.000001000 function! ale_linters#vim#ale_custom_linting_rules#Handle(buffer, lines) abort
                                let l:dir = s:GetALEProjectDir(a:buffer)
                                let l:output = []
                                let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+) (.+)$'
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    " Ignore trailing whitespace errors if we've turned them off.
                                    if !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    \&& l:match[3] is# 'Trailing whitespace'
                                        continue
                                    endif
                            
                                    call add(l:output, {
                                    \   'lnum': l:match[2],
                                    \   'text': l:match[3],
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1   0.000187000   0.000024000 call ale#linter#Define('vim', {
                            \   'name': 'ale_custom_linting_rules',
                            \   'executable': function('ale_linters#vim#ale_custom_linting_rules#GetExecutable'),
                            \   'cwd': function('ale_linters#vim#ale_custom_linting_rules#GetCwd'),
                            \   'command': function('ale_linters#vim#ale_custom_linting_rules#GetCommand'),
                            \   'callback': 'ale_linters#vim#ale_custom_linting_rules#Handle',
                            \   'read_buffer': 0,
                            \})

SCRIPT  /Users/peter.duke/.vim/plugged/ale/ale_linters/vim/vimls.vim
Sourced 1 time
Total time:   0.000217000
 Self time:   0.000056000

count     total (s)      self (s)
                            " Author: Jeffrey Lau - https://github.com/zoonfafer
                            " Description: Vim Language Server integration for ALE
                            
    1   0.000020000   0.000004000 call ale#Set('vim_vimls_executable', 'vim-language-server')
    1   0.000012000   0.000004000 call ale#Set('vim_vimls_use_global', get(g:, 'ale_use_global_executables', 0))
    1   0.000007000   0.000002000 call ale#Set('vim_vimls_config', {})
                            
    1              0.000002000 function! ale_linters#vim#vimls#GetProjectRoot(buffer) abort
                                let l:trigger_file_candidates = [
                                \   '.vimrc',
                                \   'init.vim',
                                \]
                            
                                for l:candidate in l:trigger_file_candidates
                                    let l:trigger_file = fnamemodify(bufname(a:buffer), ':t')
                            
                                    if l:trigger_file is# l:candidate
                                        return fnamemodify(
                                        \   bufname(a:buffer),
                                        \   ':h',
                                        \)
                                    endif
                                endfor
                            
                                let l:trigger_dir_candidates = [
                                \   'autoload',
                                \   'plugin',
                                \   '.git',
                                \]
                            
                                let l:path_upwards = ale#path#Upwards(fnamemodify(bufname(a:buffer), ':p:h'))
                            
                                for l:path in l:path_upwards
                                    for l:candidate in l:trigger_dir_candidates
                                        let l:trigger_dir = ale#path#Simplify(
                                        \   l:path . '/' . l:candidate,
                                        \)
                            
                                        if isdirectory(l:trigger_dir)
                                            return fnamemodify(
                                            \   l:trigger_dir,
                                            \   ':p:h:h',
                                            \)
                                        endif
                                    endfor
                                endfor
                            
                                return ''
                            endfunction
                            
    1   0.000154000   0.000022000 call ale#linter#Define('vim', {
                            \   'name': 'vimls',
                            \   'lsp': 'stdio',
                            \   'lsp_config': {b -> ale#Var(b, 'vim_vimls_config')},
                            \   'executable': {b -> ale#path#FindExecutable(b, 'vim_vimls', [
                            \       'node_modules/.bin/vim-language-server',
                            \   ])},
                            \   'command': '%e --stdio',
                            \   'language': 'vim',
                            \   'project_root': function('ale_linters#vim#vimls#GetProjectRoot'),
                            \})

SCRIPT  /Users/peter.duke/.vim/plugged/ale/ale_linters/vim/vint.vim
Sourced 1 time
Total time:   0.000198000
 Self time:   0.000062000

count     total (s)      self (s)
                            " Author: w0rp <devw0rp@gmail.com>, KabbAmine <amine.kabb@gmail.com>
                            " Description: This file adds support for checking Vim code with Vint.
                            
                            " This flag can be used to change enable/disable style issues.
    1   0.000009000   0.000003000 call ale#Set('vim_vint_show_style_issues', 1)
    1   0.000007000   0.000002000 call ale#Set('vim_vint_executable', 'vint')
    1              0.000004000 let s:enable_neovim = has('nvim') ? ' --enable-neovim' : ''
    1              0.000002000 let s:format = '-f "{file_path}:{line_number}:{column_number}: {severity}: {policy_name} - {description} (see {reference})"'
                            
    1              0.000001000 function! ale_linters#vim#vint#GetCommand(buffer, version) abort
                                let l:can_use_no_color_flag = empty(a:version)
                                \   || ale#semver#GTE(a:version, [0, 3, 7])
                            
                                let l:warning_flag = ale#Var(a:buffer, 'vim_vint_show_style_issues') ? '-s' : '-w'
                            
                                " Use the --stdin-display-name argument if supported, temp file otherwise.
                                let l:stdin_or_temp = ale#semver#GTE(a:version, [0, 4, 0])
                                \   ? ' --stdin-display-name %s -'
                                \   : ' %t'
                            
                                return '%e'
                                \   . ' ' . l:warning_flag
                                \   . (l:can_use_no_color_flag ? ' --no-color' : '')
                                \   . s:enable_neovim
                                \   . ' ' . s:format
                                \   . l:stdin_or_temp
                            endfunction
                            
    1              0.000004000 let s:word_regex_list = [
                            \   '\v^Undefined variable: ([^ ]+)',
                            \   '\v^Make the scope explicit like ...([^ ]+). ',
                            \   '\v^.*start with a capital or contain a colon: ([^ ]+)',
                            \   '\v.*instead of .(\=[=~]).',
                            \]
                            
    1              0.000001000 function! ale_linters#vim#vint#Handle(buffer, lines) abort
                                let l:loclist = ale#handlers#gcc#HandleGCCFormat(a:buffer, a:lines)
                            
                                for l:item in l:loclist
                                    let l:match = []
                            
                                    for l:regex in s:word_regex_list
                                        let l:match = matchlist(l:item.text, l:regex)
                            
                                        if !empty(l:match)
                                            let l:item.end_col = l:item.col + len(l:match[1]) - 1
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                return l:loclist
                            endfunction
                            
    1   0.000147000   0.000022000 call ale#linter#Define('vim', {
                            \   'name': 'vint',
                            \   'executable': {buffer -> ale#Var(buffer, 'vim_vint_executable')},
                            \   'command': {buffer -> ale#semver#RunWithVersionCheck(
                            \       buffer,
                            \       ale#Var(buffer, 'vim_vint_executable'),
                            \       '%e --version',
                            \       function('ale_linters#vim#vint#GetCommand'),
                            \   )},
                            \   'callback': 'ale_linters#vim#vint#Handle',
                            \})

SCRIPT  /Users/peter.duke/.vim/plugged/fzf.vim/autoload/fzf/vim.vim
Sourced 1 time
Total time:   0.005479000
 Self time:   0.005105000

count     total (s)      self (s)
                            " Copyright (c) 2023 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000042000 let s:cpo_save = &cpo
    1   0.000044000   0.000031000 set cpo&vim
                            
                            " ------------------------------------------------------------------
                            " Common
                            " ------------------------------------------------------------------
                            
    1              0.000018000 function! s:conf(name, default)
                              let conf = get(g:, 'fzf_vim', {})
                              return get(conf, a:name, get(g:, 'fzf_' . a:name, a:default))
                            endfunction
                            
    1              0.000011000 let s:winpath = {}
    1              0.000006000 function! s:winpath(path)
                              if has_key(s:winpath, a:path)
                                return s:winpath[a:path]
                              endif
                            
                              let winpath = split(system('for %A in ("'.a:path.'") do @echo %~sA'), "\n")[0]
                              let s:winpath[a:path] = winpath
                            
                              return winpath
                            endfunction
                            
    1              0.000010000 let s:warned = 0
    1              0.000005000 function! s:bash()
                              if exists('s:bash')
                                return s:bash
                              endif
                            
                              let custom_bash = s:conf('preview_bash', '')
                              let git_bash = 'C:\Program Files\Git\bin\bash.exe'
                              let candidates = filter(s:is_win ? [custom_bash, 'bash', git_bash] : [custom_bash, 'bash'], 'len(v:val)')
                            
                              let found = filter(map(copy(candidates), 'exepath(v:val)'), 'len(v:val)')
                              if empty(found)
                                if !s:warned
                                  call s:warn(printf('Preview window not supported (%s not found)', join(candidates, ', ')))
                                  let s:warned = 1
                                endif
                                let s:bash = ''
                                return s:bash
                              endif
                            
                              let s:bash = found[0]
                            
                              " Make 8.3 filename via cmd.exe
                              if s:is_win
                                let s:bash = s:winpath(s:bash)
                              endif
                            
                              return s:bash
                            endfunction
                            
    1              0.000006000 function! s:escape_for_bash(path)
                              if !s:is_win
                                return fzf#shellescape(a:path)
                              endif
                            
                              if !exists('s:is_linux_like_bash')
                                call system(s:bash . ' -c "ls /mnt/[A-Za-z]"')
                                let s:is_linux_like_bash = v:shell_error == 0
                              endif
                            
                              let path = substitute(a:path, '\', '/', 'g')
                              if s:is_linux_like_bash
                                let path = substitute(path, '^\([A-Z]\):', '/mnt/\L\1', '')
                              endif
                            
                              return escape(path, ' ')
                            endfunction
                            
    1              0.000008000 let s:min_version = '0.23.0'
    1              0.000021000 let s:is_win = has('win32') || has('win64')
    1              0.000014000 let s:is_wsl_bash = s:is_win && (exepath('bash') =~? 'Windows[/\\]system32[/\\]bash.exe$')
    1              0.000013000 let s:layout_keys = ['window', 'up', 'down', 'left', 'right']
    1              0.000076000 let s:bin_dir = expand('<sfile>:p:h:h:h').'/bin/'
    1              0.000021000 let s:bin = {
                            \ 'preview': s:bin_dir.'preview.sh',
                            \ 'tags':    s:bin_dir.'tags.pl' }
    1              0.000040000 let s:TYPE = {'bool': type(0), 'dict': type({}), 'funcref': type(function('call')), 'string': type(''), 'list': type([])}
                            
    1              0.000005000 let s:wide = 120
    1              0.000005000 let s:checked = 0
                            
    1              0.000007000 function! s:check_requirements()
                              if s:checked
                                return
                              endif
                            
                              if !exists('*fzf#run')
                                throw "fzf#run function not found. You also need Vim plugin from the main fzf repository (i.e. junegunn/fzf *and* junegunn/fzf.vim)"
                              endif
                              if !exists('*fzf#exec')
                                throw "fzf#exec function not found. You need to upgrade Vim plugin from the main fzf repository ('junegunn/fzf')"
                              endif
                              let s:checked = !empty(fzf#exec(s:min_version))
                            endfunction
                            
    1              0.000006000 function! s:extend_opts(dict, eopts, prepend)
                              if empty(a:eopts)
                                return
                              endif
                              if has_key(a:dict, 'options')
                                if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
                                  if a:prepend
                                    let a:dict.options = extend(copy(a:eopts), a:dict.options)
                                  else
                                    call extend(a:dict.options, a:eopts)
                                  endif
                                else
                                  let all_opts = a:prepend ? [a:eopts, a:dict.options] : [a:dict.options, a:eopts]
                                  let a:dict.options = join(map(all_opts, 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
                                endif
                              else
                                let a:dict.options = a:eopts
                              endif
                            endfunction
                            
    1              0.000006000 function! s:merge_opts(dict, eopts)
                              return s:extend_opts(a:dict, a:eopts, 0)
                            endfunction
                            
    1              0.000005000 function! s:prepend_opts(dict, eopts)
                              return s:extend_opts(a:dict, a:eopts, 1)
                            endfunction
                            
                            " [spec to wrap], [preview window expression], [toggle-preview keys...]
    1              0.000004000 function! fzf#vim#with_preview(...)
                              " Default spec
                              let spec = {}
                              let window = ''
                            
                              let args = copy(a:000)
                            
                              " Spec to wrap
                              if len(args) && type(args[0]) == s:TYPE.dict
                                let spec = copy(args[0])
                                call remove(args, 0)
                              endif
                            
                              if !executable(s:bash())
                                return spec
                              endif
                            
                              " Placeholder expression (TODO/TBD: undocumented)
                              let placeholder = get(spec, 'placeholder', '{}')
                            
                              " g:fzf_preview_window
                              if empty(args)
                                let preview_args = s:conf('preview_window', ['', 'ctrl-/'])
                                if empty(preview_args)
                                  let args = ['hidden']
                                else
                                  " For backward-compatiblity
                                  let args = type(preview_args) == type('') ? [preview_args] : copy(preview_args)
                                endif
                              endif
                            
                              if len(args) && type(args[0]) == s:TYPE.string
                                if len(args[0]) && args[0] !~# '^\(up\|down\|left\|right\|hidden\)'
                                  throw 'invalid preview window: '.args[0]
                                endif
                                let window = args[0]
                                call remove(args, 0)
                              endif
                            
                              let preview = []
                              if len(window)
                                let preview += ['--preview-window', window]
                              endif
                              if s:is_win
                                if empty($MSWINHOME)
                                  let $MSWINHOME = $HOME
                                endif
                                if s:is_wsl_bash && $WSLENV !~# '[:]\?MSWINHOME\(\/[^:]*\)\?\(:\|$\)'
                                  let $WSLENV = 'MSWINHOME/u:'.$WSLENV
                                endif
                              endif
                              let preview_cmd = s:bash() . ' ' . s:escape_for_bash(s:bin.preview)
                              if len(placeholder)
                                let preview += ['--preview', preview_cmd.' '.placeholder]
                              end
                              if &ambiwidth ==# 'double'
                                let preview += ['--no-unicode']
                              end
                            
                              if len(args)
                                call extend(preview, ['--bind', join(map(args, 'v:val.":toggle-preview"'), ',')])
                              endif
                              call s:merge_opts(spec, preview)
                              return spec
                            endfunction
                            
    1              0.000006000 function! s:remove_layout(opts)
                              for key in s:layout_keys
                                if has_key(a:opts, key)
                                  call remove(a:opts, key)
                                endif
                              endfor
                              return a:opts
                            endfunction
                            
    1              0.000005000 function! s:reverse_list(opts)
                              let tokens = map(split($FZF_DEFAULT_OPTS, '[^a-z-]'), 'substitute(v:val, "^--", "", "")')
                              if index(tokens, 'reverse') < 0
                                return extend(['--layout=reverse-list'], a:opts)
                              endif
                              return a:opts
                            endfunction
                            
    1              0.000004000 function! s:wrap(name, opts, bang)
                              " fzf#wrap does not append --expect if sink or sink* is found
                              let opts = copy(a:opts)
                              let options = ''
                              if has_key(opts, 'options')
                                let options = type(opts.options) == s:TYPE.list ? join(opts.options) : opts.options
                              endif
                              if options !~ '--expect' && has_key(opts, 'sink*')
                                let Sink = remove(opts, 'sink*')
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                                let wrapped['sink*'] = Sink
                              else
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                              endif
                              return wrapped
                            endfunction
                            
    1              0.000004000 function! s:strip(str)
                              return substitute(a:str, '^\s*\|\s*$', '', 'g')
                            endfunction
                            
    1              0.000005000 function! s:rstrip(str)
                              return substitute(a:str, '\s*$', '', 'g')
                            endfunction
                            
    1              0.000005000 function! s:chomp(str)
                              return substitute(a:str, '\n*$', '', 'g')
                            endfunction
                            
    1              0.000004000 function! s:escape(path)
                              let path = fnameescape(a:path)
                              return s:is_win ? escape(path, '$') : path
                            endfunction
                            
    1              0.000009000 if v:version >= 704
    1              0.000005000   function! s:function(name)
                                return function(a:name)
                              endfunction
                            else
                              function! s:function(name)
                                " By Ingo Karkat
                                return function(substitute(a:name, '^s:', matchstr(expand('<sfile>'), '<SNR>\d\+_\zefunction$'), ''))
                              endfunction
    1              0.000002000 endif
                            
    1              0.000005000 function! s:get_color(attr, ...)
                              let gui = has('termguicolors') && &termguicolors
                              let fam = gui ? 'gui' : 'cterm'
                              let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
                              for group in a:000
                                let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
                                if code =~? pat
                                  return code
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000018000 let s:ansi = {'black': 30, 'red': 31, 'green': 32, 'yellow': 33, 'blue': 34, 'magenta': 35, 'cyan': 36}
                            
    1              0.000005000 function! s:csi(color, fg)
                              let prefix = a:fg ? '38;' : '48;'
                              if a:color[0] == '#'
                                return prefix.'2;'.join(map([a:color[1:2], a:color[3:4], a:color[5:6]], 'str2nr(v:val, 16)'), ';')
                              endif
                              return prefix.'5;'.a:color
                            endfunction
                            
    1              0.000006000 function! s:ansi(str, group, default, ...)
                              let fg = s:get_color('fg', a:group)
                              let bg = s:get_color('bg', a:group)
                              let color = (empty(fg) ? s:ansi[a:default] : s:csi(fg, 1)) .
                                    \ (empty(bg) ? '' : ';'.s:csi(bg, 0))
                              return printf("\x1b[%s%sm%s\x1b[m", color, a:0 ? ';1' : '', a:str)
                            endfunction
                            
    8              0.000041000 for s:color_name in keys(s:ansi)
    7              0.000141000   execute "function! s:".s:color_name."(str, ...)\n"
                                    \ "  return s:ansi(a:str, get(a:, 1, ''), '".s:color_name."')\n"
                                    \ "endfunction"
    8              0.000016000 endfor
                            
    1              0.000004000 function! s:buflisted()
                              return filter(range(1, bufnr('$')), 'buflisted(v:val) && getbufvar(v:val, "&filetype") != "qf"')
                            endfunction
                            
    1              0.000004000 function! s:fzf(name, opts, extra)
                              call s:check_requirements()
                            
                              let [extra, bang] = [{}, 0]
                              if len(a:extra) <= 1
                                let first = get(a:extra, 0, 0)
                                if type(first) == s:TYPE.dict
                                  let extra = first
                                else
                                  let bang = first
                                endif
                              elseif len(a:extra) == 2
                                let [extra, bang] = a:extra
                              else
                                throw 'invalid number of arguments'
                              endif
                            
                              let extra  = copy(extra)
                              let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
                              let merged = extend(copy(a:opts), extra)
                              call s:merge_opts(merged, eopts)
                              return fzf#run(s:wrap(a:name, merged, bang))
                            endfunction
                            
    1              0.000018000 let s:default_action = {
                              \ 'ctrl-t': 'tab split',
                              \ 'ctrl-x': 'split',
                              \ 'ctrl-v': 'vsplit' }
                            
    1              0.000005000 function! s:execute_silent(cmd)
                              silent keepjumps keepalt execute a:cmd
                            endfunction
                            
                            " [key, [filename, [stay_on_edit: 0]]]
    1              0.000004000 function! s:action_for(key, ...)
                              let Cmd = get(get(g:, 'fzf_action', s:default_action), a:key, '')
                              let cmd = type(Cmd) == s:TYPE.string ? Cmd : ''
                            
                              " See If the command is the default action that opens the selected file in
                              " the current window. i.e. :edit
                              let edit = stridx('edit', cmd) == 0 " empty, e, ed, ..
                            
                              " If no extra argument is given, we just execute the command and ignore
                              " errors. e.g. E471: Argument required: tab drop
                              if !a:0
                                if !edit
                                  normal! m'
                                  silent! call s:execute_silent(cmd)
                                endif
                              else
                                " For the default edit action, we don't execute the action if the
                                " selected file is already opened in the current window, or we are
                                " instructed to stay on the current buffer.
                                let stay = edit && (a:0 > 1 && a:2 || fnamemodify(a:1, ':p') ==# expand('%:p'))
                                if !stay
                                  normal! m'
                                  call s:execute_silent((len(cmd) ? cmd : 'edit').' '.s:escape(a:1))
                                endif
                              endif
                            endfunction
                            
    1              0.000004000 function! s:open(target)
                              if fnamemodify(a:target, ':p') ==# expand('%:p')
                                return
                              endif
                              execute 'edit' s:escape(a:target)
                            endfunction
                            
    1              0.000004000 function! s:align_lists(lists)
                              let maxes = {}
                              for list in a:lists
                                let i = 0
                                while i < len(list)
                                  let maxes[i] = max([get(maxes, i, 0), len(list[i])])
                                  let i += 1
                                endwhile
                              endfor
                              for list in a:lists
                                call map(list, "printf('%-'.maxes[v:key].'s', v:val)")
                              endfor
                              return a:lists
                            endfunction
                            
    1              0.000003000 function! s:warn(message)
                              echohl WarningMsg
                              echom a:message
                              echohl None
                              return 0
                            endfunction
                            
    1              0.000004000 function! s:fill_quickfix(name, list)
                              if len(a:list) > 1
                                let Handler = s:conf('listproc_'.a:name, s:conf('listproc', function('fzf#vim#listproc#quickfix')))
                                call call(Handler, [a:list], {})
                                return 1
                              endif
                              return 0
                            endfunction
                            
    1              0.000005000 function! fzf#vim#_uniq(list)
                              let visited = {}
                              let ret = []
                              for l in a:list
                                if !empty(l) && !has_key(visited, l)
                                  call add(ret, l)
                                  let visited[l] = 1
                                endif
                              endfor
                              return ret
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Files
                            " ------------------------------------------------------------------
    1              0.000015000 function! s:shortpath()
                              let short = fnamemodify(getcwd(), ':~:.')
                              if !has('win32unix')
                                let short = pathshorten(short)
                              endif
                              let slash = (s:is_win && !&shellslash) ? '\' : '/'
                              return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)
                            endfunction
                            
    1              0.000004000 function! fzf#vim#files(dir, ...)
                              let args = {}
                              if !empty(a:dir)
                                if !isdirectory(expand(a:dir))
                                  return s:warn('Invalid directory')
                                endif
                                let slash = (s:is_win && !&shellslash) ? '\\' : '/'
                                let dir = substitute(a:dir, '[/\\]*$', slash, '')
                                let args.dir = dir
                              else
                                let dir = s:shortpath()
                              endif
                            
                              let args.options = ['-m', '--prompt', strwidth(dir) < &columns / 2 - 20 ? dir : '> ']
                              call s:merge_opts(args, s:conf('files_options', []))
                              return s:fzf('files', args, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Lines
                            " ------------------------------------------------------------------
    1              0.000005000 function! s:line_handler(lines)
                              if len(a:lines) < 2
                                return
                              endif
                            
                              let qfl = []
                              for line in a:lines[1:]
                                let chunks = split(line, "\t", 1)
                                call add(qfl, {'bufnr': str2nr(chunks[0]), 'lnum': str2nr(chunks[2]), 'text': join(chunks[3:], "\t")})
                              endfor
                            
                              call s:action_for(a:lines[0])
                              if !s:fill_quickfix('lines', qfl)
                                let chunks = split(a:lines[1], '\t')
                                execute 'buffer' chunks[0]
                                execute chunks[2]
                              endif
                              normal! ^zvzz
                            endfunction
                            
    1              0.000005000 function! fzf#vim#_lines(all)
                              let cur = []
                              let rest = []
                              let buf = bufnr('')
                              let longest_name = 0
                              let display_bufnames = &columns > s:wide
                              if display_bufnames
                                let bufnames = {}
                                for b in s:buflisted()
                                  let bufnames[b] = pathshorten(fnamemodify(bufname(b), ":~:."))
                                  let longest_name = max([longest_name, len(bufnames[b])])
                                endfor
                              endif
                              let len_bufnames = min([15, longest_name])
                              for b in s:buflisted()
                                let lines = getbufline(b, 1, "$")
                                if empty(lines)
                                  let path = fnamemodify(bufname(b), ':p')
                                  let lines = filereadable(path) ? readfile(path) : []
                                endif
                                if display_bufnames
                                  let bufname = bufnames[b]
                                  if len(bufname) > len_bufnames + 1
                                    let bufname = '…' . bufname[-len_bufnames+1:]
                                  endif
                                  let bufname = printf(s:green("%".len_bufnames."s", "Directory"), bufname)
                                else
                                  let bufname = ''
                                endif
                                let linefmt = s:blue("%2d\t", "TabLine")."%s".s:yellow("\t%4d ", "LineNr")."\t%s"
                                call extend(b == buf ? cur : rest,
                                \ filter(
                                \   map(lines,
                                \       '(!a:all && empty(v:val)) ? "" : printf(linefmt, b, bufname, v:key + 1, v:val)'),
                                \   'a:all || !empty(v:val)'))
                              endfor
                              return [display_bufnames, extend(cur, rest)]
                            endfunction
                            
    1              0.000003000 function! fzf#vim#lines(...)
                              let [display_bufnames, lines] = fzf#vim#_lines(1)
                              let nth = display_bufnames ? 3 : 2
                              let [query, args] = (a:0 && type(a:1) == type('')) ?
                                    \ [a:1, a:000[1:]] : ['', a:000]
                              return s:fzf('lines', {
                              \ 'source':  lines,
                              \ 'sink*':   s:function('s:line_handler'),
                              \ 'options': s:reverse_list(['--tiebreak=index', '--prompt', 'Lines> ', '--ansi', '--extended', '--nth='.nth.'..', '--tabstop=1', '--query', query, '--multi'])
                              \}, args)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " BLines
                            " ------------------------------------------------------------------
    1              0.000005000 function! s:buffer_line_handler(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let qfl = []
                              for line in a:lines[1:]
                                let chunks = split(line, "\t", 1)
                                let ln = chunks[0]
                                let ltxt = join(chunks[1:], "\t")
                                call add(qfl, {'filename': expand('%'), 'lnum': str2nr(ln), 'text': ltxt})
                              endfor
                              call s:action_for(a:lines[0])
                              if !s:fill_quickfix('blines', qfl)
                                execute split(a:lines[1], '\t')[0]
                              endif
                              normal! ^zvzz
                            endfunction
                            
    1              0.000005000 function! s:buffer_lines(query)
                              let linefmt = s:yellow(" %4d ", "LineNr")."\t%s"
                              let fmtexpr = 'printf(linefmt, v:key + 1, v:val)'
                              let lines = getline(1, '$')
                              if empty(a:query)
                                return map(lines, fmtexpr)
                              end
                              return filter(map(lines, 'v:val =~ a:query ? '.fmtexpr.' : ""'), 'len(v:val)')
                            endfunction
                            
    1              0.000466000 function! fzf#vim#buffer_lines(...)
                              let [query, args] = (a:0 && type(a:1) == type('')) ?
                                    \ [a:1, a:000[1:]] : ['', a:000]
                              return s:fzf('blines', {
                              \ 'source':  s:buffer_lines(query),
                              \ 'sink*':   s:function('s:buffer_line_handler'),
                              \ 'options': s:reverse_list(['+m', '--tiebreak=index', '--multi', '--prompt', 'BLines> ', '--ansi', '--extended', '--nth=2..', '--tabstop=1'])
                              \}, args)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Colors
                            " ------------------------------------------------------------------
    1              0.000003000 function! fzf#vim#colors(...)
                              let colors = split(globpath(&rtp, "colors/*.vim"), "\n")
                              if has('packages')
                                let colors += split(globpath(&packpath, "pack/*/opt/*/colors/*.vim"), "\n")
                              endif
                              return s:fzf('colors', {
                              \ 'source':  fzf#vim#_uniq(map(colors, "substitute(fnamemodify(v:val, ':t'), '\\..\\{-}$', '', '')")),
                              \ 'sink':    'colo',
                              \ 'options': '+m --prompt="Colors> "'
                              \}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Locate
                            " ------------------------------------------------------------------
    1              0.000004000 function! fzf#vim#locate(query, ...)
                              return s:fzf('locate', {
                              \ 'source':  'locate '.a:query,
                              \ 'options': '-m --prompt "Locate> "'
                              \}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " History[:/]
                            " ------------------------------------------------------------------
    1              0.000003000 function! fzf#vim#_recent_files()
                              return fzf#vim#_uniq(map(
                                \ filter([expand('%')], 'len(v:val)')
                                \   + filter(map(fzf#vim#_buflisted_sorted(), 'bufname(v:val)'), 'len(v:val)')
                                \   + filter(copy(v:oldfiles), "filereadable(fnamemodify(v:val, ':p'))"),
                                \ 'fnamemodify(v:val, ":~:.")'))
                            endfunction
                            
    1              0.000004000 function! s:history_source(type)
                              let max = histnr(a:type)
                              if max <= 0
                                return ['No entries']
                              endif
                              let fmt = s:yellow(' %'.len(string(max)).'d ', 'Number')
                              let list = filter(map(range(1, max), 'histget(a:type, - v:val)'), '!empty(v:val)')
                              return extend([' :: Press '.s:magenta('CTRL-E', 'Special').' to edit'],
                                \ map(list, 'printf(fmt, len(list) - v:key)." ".v:val'))
                            endfunction
                            
    1              0.000079000 nnoremap <plug>(-fzf-vim-do) :execute g:__fzf_command<cr>
    1              0.000015000 nnoremap <plug>(-fzf-/) /
    1              0.000013000 nnoremap <plug>(-fzf-:) :
                            
    1              0.000004000 function! s:history_sink(type, lines)
                              if len(a:lines) < 2
                                return
                              endif
                            
                              let prefix = "\<plug>(-fzf-".a:type.')'
                              let key  = a:lines[0]
                              let item = matchstr(a:lines[1], ' *[0-9]\+ *\zs.*')
                              if key == 'ctrl-e'
                                call histadd(a:type, item)
                                redraw
                                call feedkeys(a:type."\<up>", 'n')
                              else
                                if a:type == ':'
                                  call histadd(a:type, item)
                                endif
                                let g:__fzf_command = "normal ".prefix.item."\<cr>"
                                call feedkeys("\<plug>(-fzf-vim-do)")
                              endif
                            endfunction
                            
    1              0.000004000 function! s:cmd_history_sink(lines)
                              call s:history_sink(':', a:lines)
                            endfunction
                            
    1              0.000006000 function! fzf#vim#command_history(...)
                              return s:fzf('history-command', {
                              \ 'source':  s:history_source(':'),
                              \ 'sink*':   s:function('s:cmd_history_sink'),
                              \ 'options': '+m --ansi --prompt="Hist:> " --header-lines=1 --expect=ctrl-e --tiebreak=index'}, a:000)
                            endfunction
                            
    1              0.000006000 function! s:search_history_sink(lines)
                              call s:history_sink('/', a:lines)
                            endfunction
                            
    1              0.000004000 function! fzf#vim#search_history(...)
                              return s:fzf('history-search', {
                              \ 'source':  s:history_source('/'),
                              \ 'sink*':   s:function('s:search_history_sink'),
                              \ 'options': '+m --ansi --prompt="Hist/> " --header-lines=1 --expect=ctrl-e --tiebreak=index'}, a:000)
                            endfunction
                            
    1              0.000003000 function! fzf#vim#history(...)
                              return s:fzf('history-files', {
                              \ 'source':  fzf#vim#_recent_files(),
                              \ 'options': ['-m', '--header-lines', !empty(expand('%')), '--prompt', 'Hist> ']
                              \}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " GFiles[?]
                            " ------------------------------------------------------------------
                            
    1              0.000005000 function! s:get_git_root(dir)
                              let dir = len(a:dir) ? a:dir : substitute(split(expand('%:p:h'), '[/\\]\.git\([/\\]\|$\)')[0], '^fugitive://', '', '')
                              let root = systemlist('git -C ' . fzf#shellescape(dir) . ' rev-parse --show-toplevel')[0]
                              return v:shell_error ? '' : (len(a:dir) ? fnamemodify(a:dir, ':p') : root)
                            endfunction
                            
    1              0.000005000 function! s:version_requirement(val, min)
                              for idx in range(0, len(a:min) - 1)
                                let v = get(a:val, idx, 0)
                                if     v < a:min[idx] | return 0
                                elseif v > a:min[idx] | return 1
                                endif
                              endfor
                              return 1
                            endfunction
                            
    1              0.000004000 function! s:git_version_requirement(...)
                              if !exists('s:git_version')
                                let s:git_version = map(split(split(system('git --version'))[2], '\.'), 'str2nr(v:val)')
                              endif
                              return s:version_requirement(s:git_version, a:000)
                            endfunction
                            
    1              0.000004000 function! fzf#vim#gitfiles(args, ...)
                              let dir = get(get(a:, 1, {}), 'dir', '')
                              let root = s:get_git_root(dir)
                              if empty(root)
                                return s:warn('Not in git repo')
                              endif
                              let prefix = 'git -C ' . fzf#shellescape(root) . ' '
                              if a:args != '?'
                                let source = prefix . 'ls-files -z ' . a:args
                                if s:git_version_requirement(2, 31)
                                  let source .= ' --deduplicate'
                                endif
                                return s:fzf('gfiles', {
                                \ 'source':  source,
                                \ 'dir':     root,
                                \ 'options': '-m --read0 --prompt "GitFiles> "'
                                \}, a:000)
                              endif
                            
                              " Here be dragons!
                              " We're trying to access the common sink function that fzf#wrap injects to
                              " the options dictionary.
                              let bar = s:is_win ? '^|' : '|'
                              let diff_prefix = 'git -C ' . s:escape_for_bash(root) . ' '
                              let preview = printf(
                                \ s:bash() . ' -c "if [[ {1} =~ M ]]; then %s; else %s {-1}; fi"',
                                \ executable('delta')
                                  \ ? diff_prefix . 'diff -- {-1} ' . bar . ' delta --width $FZF_PREVIEW_COLUMNS --file-style=omit ' . bar . ' sed 1d'
                                  \ : diff_prefix . 'diff --color=always -- {-1} ' . bar . ' sed 1,4d',
                                \ s:escape_for_bash(s:bin.preview))
                              let wrapped = fzf#wrap({
                              \ 'source':  prefix . '-c color.status=always status --short --untracked-files=all',
                              \ 'dir':     root,
                              \ 'options': ['--ansi', '--multi', '--nth', '2..,..', '--tiebreak=index', '--prompt', 'GitFiles?> ', '--preview', preview]
                              \})
                              call s:remove_layout(wrapped)
                              let wrapped.common_sink = remove(wrapped, 'sink*')
                              function! wrapped.newsink(lines)
                                let lines = extend(a:lines[0:0], map(a:lines[1:], 'substitute(v:val[3:], ".* -> ", "", "")'))
                                return self.common_sink(lines)
                              endfunction
                              let wrapped['sink*'] = remove(wrapped, 'newsink')
                              return s:fzf('gfiles-diff', wrapped, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Buffers
                            " ------------------------------------------------------------------
    1              0.000004000 function! s:find_open_window(b)
                              let [tcur, tcnt] = [tabpagenr() - 1, tabpagenr('$')]
                              for toff in range(0, tabpagenr('$') - 1)
                                let t = (tcur + toff) % tcnt + 1
                                let buffers = tabpagebuflist(t)
                                for w in range(1, len(buffers))
                                  let b = buffers[w - 1]
                                  if b == a:b
                                    return [t, w]
                                  endif
                                endfor
                              endfor
                              return [0, 0]
                            endfunction
                            
    1              0.000003000 function! s:jump(t, w)
                              execute a:t.'tabnext'
                              execute a:w.'wincmd w'
                            endfunction
                            
    1              0.000003000 function! s:bufopen(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let b = matchstr(a:lines[1], '\[\zs[0-9]*\ze\]')
                              if empty(a:lines[0]) && s:conf('buffers_jump', 0)
                                let [t, w] = s:find_open_window(b)
                                if t
                                  call s:jump(t, w)
                                  return
                                endif
                              endif
                              call s:action_for(a:lines[0])
                              execute 'buffer' b
                            endfunction
                            
    1              0.000004000 function! fzf#vim#_format_buffer(b)
                              let name = bufname(a:b)
                              let line = exists('*getbufinfo') ? getbufinfo(a:b)[0]['lnum'] : 0
                              let fullname = empty(name) ? '' : fnamemodify(name, ":p:~:.")
                              let dispname = empty(name) ? '[No Name]' : name
                              let flag = a:b == bufnr('')  ? s:blue('%', 'Conditional') :
                                      \ (a:b == bufnr('#') ? s:magenta('#', 'Special') : ' ')
                              let modified = getbufvar(a:b, '&modified') ? s:red(' [+]', 'Exception') : ''
                              let readonly = getbufvar(a:b, '&modifiable') ? '' : s:green(' [RO]', 'Constant')
                              let extra = join(filter([modified, readonly], '!empty(v:val)'), '')
                              let target = empty(name) ? '' : (line == 0 ? fullname : fullname.':'.line)
                              return s:rstrip(printf("%s\t%d\t[%s] %s\t%s\t%s", target, line, s:yellow(a:b, 'Number'), flag, dispname, extra))
                            endfunction
                            
    1              0.000007000 function! s:sort_buffers(...)
                              let [b1, b2] = map(copy(a:000), 'get(g:fzf#vim#buffers, v:val, v:val)')
                              " Using minus between a float and a number in a sort function causes an error
                              return b1 < b2 ? 1 : -1
                            endfunction
                            
    1              0.000003000 function! fzf#vim#_buflisted_sorted()
                              return sort(s:buflisted(), 's:sort_buffers')
                            endfunction
                            
                            " [query (string)], [bufnrs (list)], [spec (dict)], [fullscreen (bool)]
    1              0.000003000 function! fzf#vim#buffers(...)
                              let [query, args] = (a:0 && type(a:1) == type('')) ?
                                    \ [a:1, a:000[1:]] : ['', a:000]
                              if len(args) && type(args[0]) == s:TYPE.list
                                let [buffers; args] = args
                              else
                                let buffers = s:buflisted()
                              endif
                              let sorted = sort(buffers, 's:sort_buffers')
                              let header_lines = '--header-lines=' . (bufnr('') == get(sorted, 0, 0) ? 1 : 0)
                              let tabstop = len(max(sorted)) >= 4 ? 9 : 8
                              return s:fzf('buffers', {
                              \ 'source':  map(sorted, 'fzf#vim#_format_buffer(v:val)'),
                              \ 'sink*':   s:function('s:bufopen'),
                              \ 'options': ['+m', '-x', '--tiebreak=index', header_lines, '--ansi', '-d', '\t', '--with-nth', '3..', '-n', '2,1..2', '--prompt', 'Buf> ', '--query', query, '--preview-window', '+{2}-/2', '--tabstop', tabstop]
                              \}, args)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Ag / Rg
                            " ------------------------------------------------------------------
    1              0.000003000 function! s:ag_to_qf(line)
                              let parts = matchlist(a:line, '\(.\{-}\)\s*:\s*\(\d\+\)\%(\s*:\s*\(\d\+\)\)\?\%(\s*:\(.*\)\)\?')
                              let dict = {'filename': &acd ? fnamemodify(parts[1], ':p') : parts[1], 'lnum': parts[2], 'text': parts[4]}
                              if len(parts[3])
                                let dict.col = parts[3]
                              endif
                              return dict
                            endfunction
                            
    1              0.000004000 function! s:ag_handler(name, lines)
                              if len(a:lines) < 2
                                return
                              endif
                            
                              let list = map(filter(a:lines[1:], 'len(v:val)'), 's:ag_to_qf(v:val)')
                              if empty(list)
                                return
                              endif
                            
                              call s:action_for(a:lines[0], list[0].filename, len(list) > 1)
                              if s:fill_quickfix(a:name, list)
                                return
                              endif
                            
                              " Single item selected
                              let first = list[0]
                              try
                                execute first.lnum
                                if has_key(first, 'col')
                                  call cursor(0, first.col)
                                endif
                                normal! zvzz
                              catch
                              endtry
                            endfunction
                            
                            " query, [ag options], [spec (dict)], [fullscreen (bool)]
    1              0.000003000 function! fzf#vim#ag(query, ...)
                              if type(a:query) != s:TYPE.string
                                return s:warn('Invalid query argument')
                              endif
                              let query = empty(a:query) ? '^(?=.)' : a:query
                              let args = copy(a:000)
                              let ag_opts = len(args) > 1 && type(args[0]) == s:TYPE.string ? remove(args, 0) : ''
                              let command = ag_opts . ' -- ' . fzf#shellescape(query)
                              return call('fzf#vim#ag_raw', insert(args, command, 0))
                            endfunction
                            
                            " ag command suffix, [spec (dict)], [fullscreen (bool)]
    1              0.000004000 function! fzf#vim#ag_raw(command_suffix, ...)
                              if !executable('ag')
                                return s:warn('ag is not found')
                              endif
                              return call('fzf#vim#grep', extend(['ag --nogroup --column --color '.a:command_suffix, 1], a:000))
                            endfunction
                            
                            " command (string), [spec (dict)], [fullscreen (bool)]
    1              0.000002000 function! fzf#vim#grep(grep_command, ...)
                              let args = copy(a:000)
                              let words = []
                              for word in split(a:grep_command)
                                if word !~# '^[a-z]'
                                  break
                                endif
                                call add(words, word)
                              endfor
                              let words   = empty(words) ? ['grep'] : words
                              let name    = join(words, '-')
                              let capname = join(map(words, 'toupper(v:val[0]).v:val[1:]'), '')
                              let opts = {
                              \ 'options': ['--ansi', '--prompt', capname.'> ',
                              \             '--multi', '--bind', 'alt-a:select-all,alt-d:deselect-all',
                              \             '--delimiter', ':', '--preview-window', '+{2}-/2']
                              \}
                              if len(args) && type(args[0]) == s:TYPE.bool
                                call remove(args, 0)
                              endif
                            
                              function! opts.sink(lines) closure
                                return s:ag_handler(get(opts, 'name', name), a:lines)
                              endfunction
                              let opts['sink*'] = remove(opts, 'sink')
                              try
                                let prev_default_command = $FZF_DEFAULT_COMMAND
                                let $FZF_DEFAULT_COMMAND = a:grep_command
                                return s:fzf(name, opts, args)
                              finally
                                let $FZF_DEFAULT_COMMAND = prev_default_command
                              endtry
                            endfunction
                            
                            
                            " command_prefix (string), initial_query (string), [spec (dict)], [fullscreen (bool)]
    1              0.000082000 function! fzf#vim#grep2(command_prefix, query, ...)
                              let args = copy(a:000)
                              let words = []
                              for word in split(a:command_prefix)
                                if word !~# '^[a-z]'
                                  break
                                endif
                                call add(words, word)
                              endfor
                              let words = empty(words) ? ['grep'] : words
                              let name = join(words, '-')
                              let fallback = s:is_win ? '' : ' || :'
                              let opts = {
                              \ 'source': s:is_win ? 'cd .' : ':',
                              \ 'options': ['--ansi', '--prompt', toupper(name).'> ', '--query', a:query,
                              \             '--disabled',
                              \             '--bind', 'start:reload:'.a:command_prefix.' '.fzf#shellescape(a:query),
                              \             '--bind', 'change:reload:'.a:command_prefix.' {q}'.fallback,
                              \             '--multi', '--bind', 'alt-a:select-all,alt-d:deselect-all',
                              \             '--delimiter', ':', '--preview-window', '+{2}-/2']
                              \}
                              if len(args) && type(args[0]) == s:TYPE.bool
                                call remove(args, 0)
                              endif
                              function! opts.sink(lines) closure
                                return s:ag_handler(name, a:lines)
                              endfunction
                              let opts['sink*'] = remove(opts, 'sink')
                              return s:fzf(name, opts, args)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " BTags
                            " ------------------------------------------------------------------
    1              0.000004000 function! s:btags_source(tag_cmds)
                              if !filereadable(expand('%'))
                                throw 'Save the file first'
                              endif
                            
                              for cmd in a:tag_cmds
                                let lines = split(system(cmd), "\n")
                                if !v:shell_error && len(lines)
                                  break
                                endif
                              endfor
                              if v:shell_error
                                throw get(lines, 0, 'Failed to extract tags')
                              elseif empty(lines)
                                throw 'No tags found'
                              endif
                              return map(s:align_lists(map(lines, 'split(v:val, "\t")')), 'join(v:val, "\t")')
                            endfunction
                            
    1              0.000003000 function! s:btags_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              call s:action_for(a:lines[0])
                              let qfl = []
                              for line in a:lines[1:]
                                call s:execute_silent(split(line, "\t")[2])
                                call add(qfl, {'filename': expand('%'), 'lnum': line('.'), 'text': getline('.')})
                              endfor
                            
                              if len(qfl) > 1
                                " Go back to the original position
                                normal! g`'
                                " Because 'listproc' will use 'cfirst' to go to the first item in the list
                                call s:fill_quickfix('btags', qfl)
                              else
                                normal! zvzz
                              endif
                            endfunction
                            
                            " query, [tag commands], [spec (dict)], [fullscreen (bool)]
    1              0.000003000 function! fzf#vim#buffer_tags(query, ...)
                              let args = copy(a:000)
                              let escaped = fzf#shellescape(expand('%'))
                              let null = s:is_win ? 'nul' : '/dev/null'
                              let sort = has('unix') && !has('win32unix') && executable('sort') ? '| sort -s -k 5' : ''
                              let tag_cmds = (len(args) > 1 && type(args[0]) != type({})) ? remove(args, 0) : [
                                \ printf('ctags -f - --sort=yes --excmd=number --language-force=%s %s 2> %s %s', get({ 'cpp': 'c++' }, &filetype, &filetype), escaped, null, sort),
                                \ printf('ctags -f - --sort=yes --excmd=number %s 2> %s %s', escaped, null, sort)]
                              if type(tag_cmds) != type([])
                                let tag_cmds = [tag_cmds]
                              endif
                              try
                                return s:fzf('btags', {
                                \ 'source':  s:btags_source(tag_cmds),
                                \ 'sink*':   s:function('s:btags_sink'),
                                \ 'options': s:reverse_list(['-m', '-d', '\t', '--with-nth', '1,4..', '-n', '1', '--prompt', 'BTags> ', '--query', a:query, '--preview-window', '+{3}-/2'])}, args)
                              catch
                                return s:warn(v:exception)
                              endtry
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Tags
                            " ------------------------------------------------------------------
    1              0.000003000 function! s:tags_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                            
                              " Remember the current position
                              let buf = bufnr('')
                              let view = winsaveview()
                            
                              let qfl = []
                              let [key; list] = a:lines
                            
                              try
                                let [magic, &magic, wrapscan, &wrapscan, acd, &acd] = [&magic, 0, &wrapscan, 1, &acd, 0]
                                for line in list
                                  try
                                    let parts   = split(line, '\t\zs')
                                    let excmd   = matchstr(join(parts[2:-2], '')[:-2], '^.\{-}\ze;\?"\t')
                                    let base    = fnamemodify(parts[-1], ':h')
                                    let relpath = parts[1][:-2]
                                    let abspath = relpath =~ (s:is_win ? '^[A-Z]:\' : '^/') ? relpath : join([base, relpath], '/')
                            
                                    if len(list) == 1
                                      call s:action_for(key, expand(abspath, 1))
                                    else
                                      call s:open(expand(abspath, 1))
                                    endif
                                    call s:execute_silent(excmd)
                                    call add(qfl, {'filename': expand('%'), 'lnum': line('.'), 'text': getline('.')})
                                  catch /^Vim:Interrupt$/
                                    break
                                  catch
                                    call s:warn(v:exception)
                                  endtry
                                endfor
                              finally
                                let [&magic, &wrapscan, &acd] = [magic, wrapscan, acd]
                              endtry
                            
                              if len(qfl) > 1
                                " Go back to the original position. Because 'listproc' will use 'cfirst'
                                " to go to the first item in the list.
                                call s:execute_silent('b '.buf)
                                call winrestview(view)
                            
                                " However, if a non-default action is triggered, we need to open the first
                                " entry using the action, to be as backward compatible as possible.
                                call s:action_for(key, qfl[0].filename, 1)
                            
                                call s:fill_quickfix('tags', qfl)
                              else
                                normal! ^zvzz
                              endif
                            endfunction
                            
    1              0.000003000 function! fzf#vim#tags(query, ...)
                              if !executable('perl')
                                return s:warn('Tags command requires perl')
                              endif
                              if len(a:query) && !executable('readtags')
                                return s:warn('readtags from universal-ctags is required to pre-filter tags with a prefix')
                              endif
                            
                              if empty(tagfiles())
                                call inputsave()
                                echohl WarningMsg
                                let gen = input('tags not found. Generate? (y/N) ')
                                echohl None
                                call inputrestore()
                                redraw
                                if gen =~? '^y'
                                  call s:warn('Preparing tags')
                                  call system(s:conf('tags_command', 'ctags -R'.(s:is_win ? ' --output-format=e-ctags' : '')))
                                  if empty(tagfiles())
                                    return s:warn('Failed to create tags')
                                  endif
                                else
                                  return s:warn('No tags found')
                                endif
                              endif
                            
                              let tagfiles = tagfiles()
                              let v2_limit = 1024 * 1024 * 200
                              for tagfile in tagfiles
                                let v2_limit -= getfsize(tagfile)
                                if v2_limit < 0
                                  break
                                endif
                              endfor
                              let opts = v2_limit < 0 ? ['--algo=v1'] : []
                            
                              let args = insert(map(tagfiles, 'fzf#shellescape(fnamemodify(v:val, ":p"))'), fzf#shellescape(a:query), 0)
                              return s:fzf('tags', {
                              \ 'source':  join(['perl', fzf#shellescape(s:bin.tags), join(args)]),
                              \ 'sink*':   s:function('s:tags_sink'),
                              \ 'options': extend(opts, ['--nth', '1..2', '-m', '-d', '\t', '--tiebreak=begin', '--prompt', 'Tags> ', '--query', a:query])}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Snippets (UltiSnips)
                            " ------------------------------------------------------------------
    1              0.000003000 function! s:inject_snippet(line)
                              let snip = split(a:line, "\t")[0]
                              execute 'normal! a'.s:strip(snip)."\<c-r>=UltiSnips#ExpandSnippet()\<cr>"
                            endfunction
                            
    1              0.000002000 function! fzf#vim#snippets(...)
                              if !exists(':UltiSnipsEdit')
                                return s:warn('UltiSnips not found')
                              endif
                              let list = UltiSnips#SnippetsInCurrentScope()
                              if empty(list)
                                return s:warn('No snippets available here')
                              endif
                              let aligned = sort(s:align_lists(items(list)))
                              let colored = map(aligned, 's:yellow(v:val[0])."\t".v:val[1]')
                              return s:fzf('snippets', {
                              \ 'source':  colored,
                              \ 'options': '--ansi --tiebreak=index +m -n 1,.. -d "\t"',
                              \ 'sink':    s:function('s:inject_snippet')}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Commands
                            " ------------------------------------------------------------------
    1              0.000016000 let s:nbs = nr2char(0xa0)
                            
    1              0.000003000 function! s:format_cmd(line)
                              return substitute(a:line, '\C \([A-Z]\S*\) ',
                                    \ '\=s:nbs.s:yellow(submatch(1), "Function").s:nbs', '')
                            endfunction
                            
    1              0.000003000 function! s:command_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let cmd = matchstr(a:lines[1], s:nbs.'\zs\S*\ze'.s:nbs)
                              if empty(a:lines[0])
                                call feedkeys(':'.cmd.(a:lines[1][0] == '!' ? '' : ' '), 'n')
                              else
                                call feedkeys(':'.cmd."\<cr>", 'n')
                              endif
                            endfunction
                            
    1   0.000385000   0.000032000 let s:fmt_excmd = '   '.s:blue('%-38s', 'Statement').'%s'
                            
    1              0.000004000 function! s:format_excmd(ex)
                              let match = matchlist(a:ex, '^|:\(\S\+\)|\s*\S*\(.*\)')
                              return printf(s:fmt_excmd, s:nbs.match[1].s:nbs, s:strip(match[2]))
                            endfunction
                            
    1              0.000003000 function! s:excmds()
                              let help = globpath($VIMRUNTIME, 'doc/index.txt')
                              if empty(help)
                                return []
                              endif
                            
                              let commands = []
                              let command = ''
                              for line in readfile(help)
                                if line =~ '^|:[^|]'
                                  if !empty(command)
                                    call add(commands, s:format_excmd(command))
                                  endif
                                  let command = line
                                elseif line =~ '^\s\+\S' && !empty(command)
                                  let command .= substitute(line, '^\s*', ' ', '')
                                elseif !empty(commands) && line =~ '^\s*$'
                                  break
                                endif
                              endfor
                              if !empty(command)
                                call add(commands, s:format_excmd(command))
                              endif
                              return commands
                            endfunction
                            
    1              0.000003000 function! fzf#vim#commands(...)
                              redir => cout
                              silent command
                              redir END
                              let list = split(cout, "\n")
                              return s:fzf('commands', {
                              \ 'source':  extend(extend(list[0:0], map(list[1:], 's:format_cmd(v:val)')), s:excmds()),
                              \ 'sink*':   s:function('s:command_sink'),
                              \ 'options': '--ansi --expect '.s:conf('commands_expect', 'ctrl-x').
                              \            ' --tiebreak=index --header-lines 1 -x --prompt "Commands> " -n2,3,2..3 -d'.s:nbs}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Changes
                            " ------------------------------------------------------------------
                            
    1              0.000004000 function! s:format_change(bufnr, offset, item)
                              return printf("%3d  %s  %4d  %3d  %s", a:bufnr, s:yellow(printf('%6s', a:offset)), a:item.lnum, a:item.col, getbufline(a:bufnr, a:item.lnum)[0])
                            endfunction
                            
    1              0.000003000 function! s:changes_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                            
                              call s:action_for(a:lines[0])
                              let [b, o, l, c] = split(a:lines[1])[0:3]
                            
                              if o == '-'
                                execute 'buffer' b
                                call cursor(l, c)
                              elseif o[0] == '+'
                                execute 'normal!' o[1:].'g,'
                              else
                                execute 'normal!' o.'g;'
                              endif
                            endfunction
                            
    1              0.000004000 function! s:format_change_offset(current, index, cursor)
                              if !a:current
                                return '-'
                              endif
                            
                              let offset = a:index - a:cursor + 1
                              if offset < 0
                                return '+'.-offset
                              endif
                              return offset
                            endfunction
                            
    1              0.000003000 function! fzf#vim#changes(...)
                              let all_changes = ["buf  offset  line  col  text"]
                              let cursor = 0
                              for bufnr in fzf#vim#_buflisted_sorted()
                                let [changes, position_or_length] = getchangelist(bufnr)
                                let current = bufnr('') == bufnr
                                if current
                                  let cursor = len(changes) - position_or_length
                                endif
                                let all_changes += map(reverse(changes), { idx, val -> s:format_change(bufnr, s:format_change_offset(current, idx, cursor), val) })
                              endfor
                            
                              return s:fzf('changes', {
                              \ 'source':  all_changes,
                              \ 'sink*':   s:function('s:changes_sink'),
                              \ 'options': printf('+m -x --ansi --tiebreak=index --header-lines=1 --cycle --scroll-off 999 --sync --bind start:pos:%d --prompt "Changes> "', cursor)}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Marks
                            " ------------------------------------------------------------------
    1              0.000003000 function! s:format_mark(line)
                              return substitute(a:line, '\S', '\=s:yellow(submatch(0), "Number")', '')
                            endfunction
                            
    1              0.000003000 function! s:mark_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              call s:action_for(a:lines[0])
                              execute 'normal! `'.matchstr(a:lines[1], '\S').'zz'
                            endfunction
                            
    1              0.000003000 function! fzf#vim#marks(...)
                              redir => cout
                              silent marks
                              redir END
                              let list = split(cout, "\n")
                              return s:fzf('marks', {
                              \ 'source':  extend(list[0:0], map(list[1:], 's:format_mark(v:val)')),
                              \ 'sink*':   s:function('s:mark_sink'),
                              \ 'options': '+m -x --ansi --tiebreak=index --header-lines 1 --tiebreak=begin --prompt "Marks> "'}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Jumps
                            " ------------------------------------------------------------------
    1              0.000003000 function! s:jump_format(line)
                              return substitute(a:line, '[0-9]\+', '\=s:yellow(submatch(0), "Number")', '')
                            endfunction
                            
    1              0.000003000 function! s:jump_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              call s:action_for(a:lines[0])
                              let idx = index(s:jumplist, a:lines[1])
                              if idx == -1
                                return
                              endif
                              let current = match(s:jumplist, '\v^\s*\>')
                              let delta = idx - current
                              if delta < 0
                                execute 'normal! ' . -delta . "\<C-O>"
                              else
                                execute 'normal! ' . delta . "\<C-I>"
                              endif
                            endfunction
                            
    1              0.000003000 function! fzf#vim#jumps(...)
                              redir => cout
                              silent jumps
                              redir END
                              let s:jumplist = split(cout, '\n')
                              let current = -match(s:jumplist, '\v^\s*\>')
                              return s:fzf('jumps', {
                              \ 'source'  : extend(s:jumplist[0:0], map(s:jumplist[1:], 's:jump_format(v:val)')),
                              \ 'sink*'   : s:function('s:jump_sink'),
                              \ 'options' : '+m -x --ansi --tiebreak=index --cycle --scroll-off 999 --sync --bind start:pos:'.current.' --tac --header-lines 1 --tiebreak=begin --prompt "Jumps> "',
                              \ }, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Help tags
                            " ------------------------------------------------------------------
    1              0.000003000 function! s:helptag_sink(line)
                              let [tag, file, path] = split(a:line, "\t")[0:2]
                              let rtp = fnamemodify(path, ':p:h:h')
                              if stridx(&rtp, rtp) < 0
                                execute 'set rtp+='.s:escape(rtp)
                              endif
                              execute 'help' tag
                            endfunction
                            
    1              0.000002000 function! fzf#vim#helptags(...)
                              if !executable('perl')
                                return s:warn('Helptags command requires perl')
                              endif
                              let sorted = sort(split(globpath(&runtimepath, 'doc/tags', 1), '\n'))
                              let tags = exists('*uniq') ? uniq(sorted) : fzf#vim#_uniq(sorted)
                            
                              if exists('s:helptags_script')
                                silent! call delete(s:helptags_script)
                              endif
                              let s:helptags_script = tempname()
                            
                              call writefile(['for my $filename (@ARGV) { open(my $file,q(<),$filename) or die; while (<$file>) { /(.*?)\t(.*?)\t(.*)/; push @lines, sprintf(qq('.s:green('%-40s', 'Label').'\t%s\t%s\t%s\n), $1, $2, $filename, $3); } close($file) or die; } print for sort @lines;'], s:helptags_script)
                              return s:fzf('helptags', {
                              \ 'source': 'perl '.fzf#shellescape(s:helptags_script).' '.join(map(tags, 'fzf#shellescape(v:val)')),
                              \ 'sink':    s:function('s:helptag_sink'),
                              \ 'options': ['--ansi', '+m', '--tiebreak=begin', '--with-nth', '..3']}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " File types
                            " ------------------------------------------------------------------
    1              0.000003000 function! fzf#vim#filetypes(...)
                              return s:fzf('filetypes', {
                              \ 'source':  fzf#vim#_uniq(sort(map(split(globpath(&rtp, 'syntax/*.vim'), '\n'),
                              \            'fnamemodify(v:val, ":t:r")'))),
                              \ 'sink':    'setf',
                              \ 'options': '+m --prompt="File types> "'
                              \}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Windows
                            " ------------------------------------------------------------------
    1              0.000003000 function! s:format_win(tab, win, buf)
                              let modified = getbufvar(a:buf, '&modified')
                              let name = bufname(a:buf)
                              let name = empty(name) ? s:nbs.s:nbs.'[No Name]' : ' '.s:nbs.name
                              let active = tabpagewinnr(a:tab) == a:win
                              return (active? s:blue('>', 'Operator') : ' ') . name . s:nbs . (modified? s:red(' [+]', 'Exception') : '')
                            endfunction
                            
    1              0.000003000 function! s:windows_sink(line)
                              let list = matchlist(a:line, '^ *\([0-9]\+\) *\([0-9]\+\)')
                              call s:jump(list[1], list[2])
                            endfunction
                            
    1              0.000003000 function! fzf#vim#windows(...)
                              let lines = []
                              for t in range(1, tabpagenr('$'))
                                let buffers = tabpagebuflist(t)
                                for w in range(1, len(buffers))
                                  call add(lines,
                                    \ printf('%s %s  %s',
                                        \ s:yellow(printf('%3d', t), 'Number'),
                                        \ s:cyan(printf('%3d', w), 'String'),
                                        \ s:format_win(t, w, buffers[w-1])))
                                endfor
                              endfor
                              return s:fzf('windows', {
                              \ 'source':  extend(['Tab Win     Name'], lines),
                              \ 'sink':    s:function('s:windows_sink'),
                              \ 'options': '+m --ansi --tiebreak=begin --header-lines=1 -d'.s:nbs}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Commits / BCommits
                            " ------------------------------------------------------------------
    1              0.000003000 function! s:yank_to_register(data)
                              let @" = a:data
                              silent! let @* = a:data
                              silent! let @+ = a:data
                            endfunction
                            
    1              0.000003000 function! s:commits_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                            
                              let pat = '[0-9a-f]\{7,40}'
                            
                              if a:lines[0] == 'ctrl-y'
                                let hashes = join(filter(map(a:lines[1:], 'matchstr(v:val, pat)'), 'len(v:val)'))
                                return s:yank_to_register(hashes)
                              end
                            
                              let diff = a:lines[0] == 'ctrl-d'
                              let Cmd = get(get(g:, 'fzf_action', s:default_action), a:lines[0], '')
                              let cmd = type(Cmd) == s:TYPE.string ? Cmd : ''
                            
                              let buf = bufnr('')
                              for idx in range(1, len(a:lines) - 1)
                                let sha = matchstr(a:lines[idx], pat)
                                if !empty(sha)
                                  if diff
                                    if idx > 1
                                      execute 'tab sb' buf
                                    endif
                                    execute 'Gdiff' sha
                                  else
                                    " Since fugitive buffers are unlisted, we can't keep using 'e'
                                    let c = empty(cmd) ? (idx == 1 ? 'edit' : 'tab split') : cmd
                                    execute c FugitiveFind(sha)
                                  endif
                                endif
                              endfor
                            endfunction
                            
    1              0.000004000 function! s:commits(range, buffer_local, args)
                              let s:git_root = s:get_git_root('')
                              if empty(s:git_root)
                                return s:warn('Not in git repository')
                              endif
                            
                              let prefix = 'git -C ' . fzf#shellescape(s:git_root) . ' '
                              let source = prefix . 'log '.s:conf('commits_log_options', '--color=always '.fzf#shellescape('--format=%C(auto)%h%d %s %C(green)%cr'))
                              let current = expand('%:p')
                              let managed = 0
                              if !empty(current)
                                call system(prefix . 'show '.fzf#shellescape(current).' 2> '.(s:is_win ? 'nul' : '/dev/null'))
                                let managed = !v:shell_error
                              endif
                            
                              let args = copy(a:args)
                              let log_opts = len(args) && type(args[0]) == type('') ? remove(args, 0) : ''
                            
                              if len(a:range) || a:buffer_local
                                if !managed
                                  return s:warn('The current buffer is not in the working tree')
                                endif
                                let source .= len(a:range)
                                  \ ? join([printf(' -L %d,%d:%s --no-patch', a:range[0], a:range[1], fzf#shellescape(current)), log_opts])
                                  \ : join([' --follow', log_opts, fzf#shellescape(current)])
                                let command = 'BCommits'
                              else
                                let source .= join([' --graph', log_opts])
                                let command = 'Commits'
                              endif
                            
                              let expect_keys = join(keys(get(g:, 'fzf_action', s:default_action)), ',')
                              let options = {
                              \ 'source':  source,
                              \ 'sink*':   s:function('s:commits_sink'),
                              \ 'options': s:reverse_list(['--ansi', '--multi', '--tiebreak=index',
                              \   '--inline-info', '--prompt', command.'> ', '--bind=ctrl-s:toggle-sort',
                              \   '--header', ':: Press '.s:magenta('CTRL-S', 'Special').' to toggle sort, '.s:magenta('CTRL-Y', 'Special').' to yank commit hashes',
                              \   '--expect=ctrl-y,'.expect_keys])
                              \ }
                            
                              if a:buffer_local
                                let options.options[-2] .= ', '.s:magenta('CTRL-D', 'Special').' to diff'
                                let options.options[-1] .= ',ctrl-d'
                              endif
                            
                              if !s:is_win && &columns > s:wide
                                let suffix = executable('delta') ? '| delta --width $FZF_PREVIEW_COLUMNS' : ''
                                let orderfile = tempname()
                                call writefile([current[len(s:git_root)+1:]], orderfile)
                                call extend(options.options,
                                \ ['--preview', 'echo {} | grep -o "[a-f0-9]\{7,\}" | head -1 | xargs ' . prefix . 'show -O'.fzf#shellescape(orderfile).' --format=format: --color=always ' . suffix])
                              endif
                            
                              return s:fzf(a:buffer_local ? 'bcommits' : 'commits', options, args)
                            endfunction
                            
                            " Heuristically determine if the user specified a range
    1              0.000004000 function! s:given_range(line1, line2)
                              " 1. From visual mode
                              "   :'<,'>Commits
                              " 2. From command-line
                              "   :10,20Commits
                              if a:line1 == line("'<") && a:line2 == line("'>") ||
                                    \ (a:line1 != 1 || a:line2 != line('$'))
                                return [a:line1, a:line2]
                              endif
                            
                              return []
                            endfunction
                            
                            " [git-log-args], [spec (dict)], [fullscreen (bool)]
    1              0.000003000 function! fzf#vim#commits(...) range
                              if exists('b:fzf_winview')
                                call winrestview(b:fzf_winview)
                                unlet b:fzf_winview
                              endif
                              return s:commits(s:given_range(a:firstline, a:lastline), 0, a:000)
                            endfunction
                            
                            " [git-log-args], [spec (dict)], [fullscreen (bool)]
    1              0.000003000 function! fzf#vim#buffer_commits(...) range
                              if exists('b:fzf_winview')
                                call winrestview(b:fzf_winview)
                                unlet b:fzf_winview
                              endif
                              return s:commits(s:given_range(a:firstline, a:lastline), 1, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " fzf#vim#maps(mode, opts[with count and op])
                            " ------------------------------------------------------------------
    1              0.000003000 function! s:align_pairs(list)
                              let maxlen = 0
                              let pairs = []
                              for elem in a:list
                                let match = matchlist(elem, '^\(\S*\)\s*\(.*\)$')
                                let [_, k, v] = match[0:2]
                                let maxlen = max([maxlen, len(k)])
                                call add(pairs, [k, substitute(v, '^\*\?[@ ]\?', '', '')])
                              endfor
                              let maxlen = min([maxlen, 35])
                              return map(pairs, "printf('%-'.maxlen.'s', v:val[0]).' '.v:val[1]")
                            endfunction
                            
    1              0.000004000 function! s:highlight_keys(str)
                              return substitute(
                                    \ substitute(a:str, '<[^ >]\+>', s:yellow('\0', 'Special'), 'g'),
                                    \ '<Plug>', s:blue('<Plug>', 'SpecialKey'), 'g')
                            endfunction
                            
    1              0.000003000 function! s:key_sink(line)
                              let key = matchstr(a:line, '^\S*')
                              redraw
                              call feedkeys(s:map_gv.s:map_cnt.s:map_reg, 'n')
                              call feedkeys(s:map_op.
                                    \ substitute(key, '<[^ >]\+>', '\=eval("\"\\".submatch(0)."\"")', 'g'))
                            endfunction
                            
    1              0.000002000 function! fzf#vim#maps(mode, ...)
                              let s:map_gv  = a:mode == 'x' ? 'gv' : ''
                              let s:map_cnt = v:count == 0 ? '' : v:count
                              let s:map_reg = empty(v:register) ? '' : ('"'.v:register)
                              let s:map_op  = a:mode == 'o' ? v:operator : ''
                            
                              redir => cout
                              silent execute 'verbose' a:mode.'map'
                              redir END
                              let list = []
                              let curr = ''
                              for line in split(cout, "\n")
                                if line =~ "^\t"
                                  let src = "\t".substitute(matchstr(line, '/\zs[^/\\]*\ze$'), ' [^ ]* ', ':', '')
                                  call add(list, printf('%s %s', curr, s:green(src, 'Comment')))
                                  let curr = ''
                                else
                                  if !empty(curr)
                                    call add(list, curr)
                                  endif
                                  let curr = line[3:]
                                endif
                              endfor
                              if !empty(curr)
                                call add(list, curr)
                              endif
                              let aligned = s:align_pairs(list)
                              let sorted  = sort(aligned)
                              let colored = map(sorted, 's:highlight_keys(v:val)')
                              let pcolor  = a:mode == 'x' ? 9 : a:mode == 'o' ? 10 : 12
                              return s:fzf('maps', {
                              \ 'source':  colored,
                              \ 'sink':    s:function('s:key_sink'),
                              \ 'options': '--prompt "Maps ('.a:mode.')> " --ansi --no-hscroll --nth 1,.. --color prompt:'.pcolor}, a:000)
                            endfunction
                            
                            " ----------------------------------------------------------------------------
                            " fzf#vim#complete - completion helper
                            " ----------------------------------------------------------------------------
    1              0.000045000 inoremap <silent> <Plug>(-fzf-complete-trigger) <c-o>:call <sid>complete_trigger()<cr>
                            
    1              0.000004000 function! s:pluck(dict, key, default)
                              return has_key(a:dict, a:key) ? remove(a:dict, a:key) : a:default
                            endfunction
                            
    1              0.000003000 function! s:complete_trigger()
                              let opts = copy(s:opts)
                              call s:prepend_opts(opts, ['+m', '-q', s:query])
                              let opts['sink*'] = s:function('s:complete_insert')
                              let s:reducer = s:pluck(opts, 'reducer', s:function('s:first_line'))
                              call fzf#run(opts)
                            endfunction
                            
                            " The default reducer
    1              0.000003000 function! s:first_line(lines)
                              return a:lines[0]
                            endfunction
                            
    1              0.000005000 function! s:complete_insert(lines)
                              if empty(a:lines)
                                return
                              endif
                            
                              let chars = strchars(s:query)
                              if     chars == 0 | let del = ''
                              elseif chars == 1 | let del = '"_x'
                              else              | let del = (chars - 1).'"_dvh'
                              endif
                            
                              let data = call(s:reducer, [a:lines])
                              let ve = &ve
                              set ve=
                              execute 'normal!' ((s:eol || empty(chars)) ? '' : 'h').del.(s:eol ? 'a': 'i').data
                              let &ve = ve
                              if mode() =~ 't'
                                call feedkeys('a', 'n')
                              elseif has('nvim')
                                execute "normal! \<esc>la"
                              else
                                call feedkeys("\<Plug>(-fzf-complete-finish)")
                              endif
                            endfunction
                            
    1              0.000022000 nnoremap <silent> <Plug>(-fzf-complete-finish) a
    1              0.000018000 inoremap <silent> <Plug>(-fzf-complete-finish) <c-o>l
                            
    1              0.000004000 function! s:eval(dict, key, arg)
                              if has_key(a:dict, a:key) && type(a:dict[a:key]) == s:TYPE.funcref
                                let ret = copy(a:dict)
                                let ret[a:key] = call(a:dict[a:key], [a:arg])
                                return ret
                              endif
                              return a:dict
                            endfunction
                            
    1              0.000002000 function! fzf#vim#complete(...)
                              if a:0 == 0
                                let s:opts = fzf#wrap()
                              elseif type(a:1) == s:TYPE.dict
                                let s:opts = copy(a:1)
                              elseif type(a:1) == s:TYPE.string
                                let s:opts = extend({'source': a:1}, get(a:000, 1, fzf#wrap()))
                              else
                                echoerr 'Invalid argument: '.string(a:000)
                                return ''
                              endif
                              for s in ['sink', 'sink*']
                                if has_key(s:opts, s)
                                  call remove(s:opts, s)
                                endif
                              endfor
                            
                              let eol = col('$')
                              let ve = &ve
                              set ve=all
                              let s:eol = col('.') == eol
                              let &ve = ve
                            
                              let Prefix = s:pluck(s:opts, 'prefix', '\k*$')
                              if col('.') == 1
                                let s:query = ''
                              else
                                let full_prefix = getline('.')[0 : col('.')-2]
                                if type(Prefix) == s:TYPE.funcref
                                  let s:query = call(Prefix, [full_prefix])
                                else
                                  let s:query = matchstr(full_prefix, Prefix)
                                endif
                              endif
                              let s:opts = s:eval(s:opts, 'source', s:query)
                              let s:opts = s:eval(s:opts, 'options', s:query)
                              let s:opts = s:eval(s:opts, 'extra_options', s:query)
                              if has_key(s:opts, 'extra_options')
                                call s:merge_opts(s:opts, remove(s:opts, 'extra_options'))
                              endif
                              if has_key(s:opts, 'options')
                                if type(s:opts.options) == s:TYPE.list
                                  call add(s:opts.options, '--no-expect')
                                else
                                  let s:opts.options .= ' --no-expect'
                                endif
                              endif
                            
                              call feedkeys("\<Plug>(-fzf-complete-trigger)")
                              return ''
                            endfunction
                            
                            " ------------------------------------------------------------------
    1   0.000029000   0.000021000 let &cpo = s:cpo_save
    1              0.000009000 unlet s:cpo_save

SCRIPT  /Users/peter.duke/.vim/plugged/ultisnips/autoload/UltiSnips.vim
Sourced 1 time
Total time:   0.081890000
 Self time:   0.081890000

count     total (s)      self (s)
    1              0.000040000 if exists("b:did_autoload_ultisnips")
                                finish
    1              0.000002000 endif
    1              0.000014000 let b:did_autoload_ultisnips = 1
                            
                            " Ensure snippets are loaded for current buffer
    1              0.000043000 au UltiSnips_AutoTrigger FileType,BufEnter * call UltiSnips#CheckFiletype()
                            
                            " Also import vim as we expect it to be imported in many places.
    1              0.038244000 py3 import vim
    1              0.042420000 py3 from UltiSnips import UltiSnips_Manager
                            
    1              0.000005000 function! s:compensate_for_pum() abort
                                """ The CursorMovedI event is not triggered while the popup-menu is visible,
                                """ and it's by this event that UltiSnips updates its vim-state. The fix is
                                """ to explicitly check for the presence of the popup menu, and update
                                """ the vim-state accordingly.
                                if pumvisible()
                                    py3 UltiSnips_Manager._cursor_moved()
                                endif
                            endfunction
                            
    1              0.000002000 function! s:is_floating(winId) abort
                                if has('nvim')
                                    return get(nvim_win_get_config(a:winId), 'relative', '') !=# ''
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000001000 function! UltiSnips#Edit(bang, ...) abort
                                if a:0 == 1 && a:1 != ''
                                    let type = a:1
                                else
                                    let type = ""
                                endif
                                py3 vim.command("let file = '%s'" % UltiSnips_Manager._file_to_edit(vim.eval("type"), vim.eval('a:bang')))
                            
                                if !len(file)
                                   return
                                endif
                            
                                let mode = 'e'
                                if exists('g:UltiSnipsEditSplit')
                                    if g:UltiSnipsEditSplit == 'vertical'
                                        let mode = 'vs'
                                    elseif g:UltiSnipsEditSplit == 'horizontal'
                                        let mode = 'sp'
                                    elseif g:UltiSnipsEditSplit == 'tabdo'
                                        let mode = 'tabedit'
                                    elseif g:UltiSnipsEditSplit == 'context'
                                        let mode = 'vs'
                                        if winwidth(0) <= 2 * (&tw ? &tw : 80)
                                            let mode = 'sp'
                                        endif
                                    endif
                                endif
                                exe ':'.mode.' '.escape(file, ' ')
                            endfunction
                            
    1              0.000001000 function! UltiSnips#AddFiletypes(filetypes) abort
                                py3 UltiSnips_Manager.add_buffer_filetypes(vim.eval("a:filetypes"))
                                return ""
                            endfunction
                            
    1              0.000001000 function! UltiSnips#FileTypeComplete(arglead, cmdline, cursorpos) abort
                                let ret = {}
                                let items = map(
                                \   split(globpath(&runtimepath, 'syntax/*.vim'), '\n'),
                                \   'fnamemodify(v:val, ":t:r")'
                                \ )
                                call insert(items, 'all')
                                for item in items
                                    if !has_key(ret, item) && item =~ '^'.a:arglead
                                        let ret[item] = 1
                                    endif
                                endfor
                            
                                return sort(keys(ret))
                            endfunction
                            
    1              0.000001000 function! UltiSnips#ExpandSnippet() abort
                                py3 UltiSnips_Manager.expand()
                                return ""
                            endfunction
                            
    1              0.000001000 function! UltiSnips#ExpandSnippetOrJump() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.expand_or_jump()
                                return ""
                            endfunction
                            
    1              0.000001000 function! UltiSnips#JumpOrExpandSnippet() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_or_expand()
                                return ""
                            endfunction
                            
    1              0.000001000 function! UltiSnips#ListSnippets() abort
                                py3 UltiSnips_Manager.list_snippets()
                                return ""
                            endfunction
                            
    1              0.000001000 function! UltiSnips#SnippetsInCurrentScope(...) abort
                                let g:current_ulti_dict = {}
                                let all = get(a:, 1, 0)
                                if all
                                  let g:current_ulti_dict_info = {}
                                endif
                                py3 UltiSnips_Manager.snippets_in_current_scope(int(vim.eval("all")))
                                return g:current_ulti_dict
                            endfunction
                            
    1              0.000001000 function! UltiSnips#CanExpandSnippet() abort
                            	py3 vim.command("let can_expand = %d" % UltiSnips_Manager.can_expand())
                            	return can_expand
                            endfunction
                            
    1              0.000001000 function! UltiSnips#CanJumpForwards() abort
                            	py3 vim.command("let can_jump_forwards = %d" % UltiSnips_Manager.can_jump_forwards())
                            	return can_jump_forwards
                            endfunction
                            
    1              0.000001000 function! UltiSnips#CanJumpBackwards() abort
                            	py3 vim.command("let can_jump_backwards = %d" % UltiSnips_Manager.can_jump_backwards())
                            	return can_jump_backwards
                            endfunction
                            
    1              0.000000000 function! UltiSnips#ToggleAutoTrigger() abort
                                py3 vim.command("let autotrigger = %d" % UltiSnips_Manager._toggle_autotrigger())
                                return autotrigger
                            endfunction
                            
    1              0.000001000 function! UltiSnips#SaveLastVisualSelection() range abort
                                py3 UltiSnips_Manager._save_last_visual_selection()
                                return ""
                            endfunction
                            
    1              0.000001000 function! UltiSnips#JumpBackwards() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_backwards()
                                return ""
                            endfunction
                            
    1              0.000001000 function! UltiSnips#JumpForwards() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_forwards()
                                return ""
                            endfunction
                            
    1              0.000001000 function! UltiSnips#AddSnippetWithPriority(trigger, value, description, options, filetype, priority) abort
                                py3 trigger = vim.eval("a:trigger")
                                py3 value = vim.eval("a:value")
                                py3 description = vim.eval("a:description")
                                py3 options = vim.eval("a:options")
                                py3 filetype = vim.eval("a:filetype")
                                py3 priority = vim.eval("a:priority")
                                py3 UltiSnips_Manager.add_snippet(trigger, value, description, options, filetype, priority)
                                return ""
                            endfunction
                            
    1              0.000000000 function! UltiSnips#Anon(value, ...) abort
                                " Takes the same arguments as SnippetManager.expand_anon:
                                " (value, trigger="", description="", options="")
                                py3 args = vim.eval("a:000")
                                py3 value = vim.eval("a:value")
                                py3 UltiSnips_Manager.expand_anon(value, *args)
                                return ""
                            endfunction
                            
    1              0.000001000 function! UltiSnips#CursorMoved() abort
                                py3 UltiSnips_Manager._cursor_moved()
                            endf
                            
    1              0.000001000 function! UltiSnips#LeavingBuffer() abort
                                let from_preview = getwinvar(winnr('#'), '&previewwindow')
                                let to_preview = getwinvar(winnr(), '&previewwindow')
                                let from_floating = s:is_floating(win_getid('#'))
                                let to_floating = s:is_floating(win_getid())
                            
                                if !(from_preview || to_preview || from_floating || to_floating)
                                    py3 UltiSnips_Manager._leaving_buffer()
                                endif
                            endf
                            
    1              0.000001000 function! UltiSnips#LeavingInsertMode() abort
                                py3 UltiSnips_Manager._leaving_insert_mode()
                            endfunction
                            
    1              0.000001000 function! UltiSnips#TrackChange() abort
                                py3 UltiSnips_Manager._track_change()
                            endfunction
                            
    1              0.000001000 function! UltiSnips#CheckFiletype() abort
                                py3 UltiSnips_Manager._check_filetype(vim.eval('&ft'))
                            endfunction
                            
    1              0.000000000 function! UltiSnips#RefreshSnippets() abort
                                py3 UltiSnips_Manager._refresh_snippets()
                            endfunction
                            " }}}

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:423
Called 131 times
Total time:   0.068290000
 Self time:   0.032368000

count     total (s)      self (s)
  131                 0.000950000   if type(a:path) ==# type({})
                                      return get(a:path, 'fugitive_dir', get(a:path, 'git_dir', ''))
  131                 0.000406000   elseif type(a:path) == type(0)
    2   0.000022000   0.000014000     let path = s:Slash(a:path > 0 ? bufname(a:path) : bufname(''))
  129                 0.000107000   else
  129   0.001251000   0.000855000     let path = s:Slash(a:path)
  131                 0.000101000   endif
  131                 0.000897000   if path =~# '^fugitive://'
                                      return fugitive#Parse(path)[1]
  131                 0.000276000   elseif empty(path)
                                      return ''
  131                 0.000084000   endif
  131                 0.001959000   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
  131                 0.000491000   if len(pre) && exists('*' . pre . 'Real')
                                      let path = {pre}Real(path)
  131                 0.000080000   endif
  131   0.002872000   0.002583000   let root = s:Slash(fnamemodify(path, ':p:h'))
  131                 0.000227000   let previous = ""
  131                 0.001492000   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
  131   0.002481000   0.000857000   call s:Tree(env_git_dir)
  131   0.014314000   0.000697000   let ceiling_directories = s:CeilingDirectories()
  257                 0.002159000   while root !=# previous && root !~# '^$\|^//[^/]*$'
  257                 0.001017000     if index(ceiling_directories, root) >= 0
    3                 0.000002000       break
  254                 0.000220000     endif
  254                 0.001014000     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                        return env_git_dir
  254                 0.000942000     elseif has_key(s:dir_for_worktree, root)
                                        return s:dir_for_worktree[root]
  254                 0.000169000     endif
  254                 0.003060000     let dir = substitute(root, '[\/]$', '', '') . '/.git'
  254   0.017146000   0.001585000     let resolved = s:ResolveGitDir(dir)
  254                 0.000631000     if !empty(resolved)
  128                 0.000646000       let s:resolved_git_dirs[dir] = resolved
  128                 0.000647000       return dir is# resolved || s:Tree(resolved) is# 0 ? dir : resolved
  126   0.005107000   0.000680000     elseif FugitiveIsGitDir(root)
                                        let s:resolved_git_dirs[root] = root
                                        return root
  126                 0.000091000     endif
  126                 0.000219000     let previous = root
  126                 0.000489000     let root = fnamemodify(root, ':h')
  129                 0.000370000   endwhile
    3                 0.000003000   return ''

FUNCTION  fugitive#DidChange()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:4342
Called 19 times
Total time:   0.004913000
 Self time:   0.000432000

count     total (s)      self (s)
   19   0.004486000   0.000091000   call s:ExpireStatus(a:0 ? a:1 : -1)
   19                 0.000038000   if a:0 > 1 ? a:2 : (!a:0 || a:1 isnot# 0)
                                      let t = reltime()
                                      let t:fugitive_reload_status = t
                                      for tabnr in range(1, tabpagenr('$'))
                                        call settabvar(tabnr, 'fugitive_reload_status', t)
                                      endfor
                                      call s:ReloadTabStatus()
   19                 0.000019000   else
   19   0.000148000   0.000062000     call s:ReloadWinStatus()
   19                 0.000012000     return ''
                                    endif
                                    exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
                                    return ''

FUNCTION  <SNR>62_dopopd()
    Defined: ~/.fzf/plugin/fzf.vim:618
Called 24 times
Total time:   0.000791000
 Self time:   0.000386000

count     total (s)      self (s)
   24                 0.000089000   if !exists('w:fzf_pushd')
   22                 0.000020000     return
    2                 0.000002000   endif
                                  
                                    " FIXME: We temporarily change the working directory to 'dir' entry
                                    " of options dictionary (set to the current working directory if not given)
                                    " before running fzf.
                                    "
                                    " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                                    "
                                    " After processing the sink function, we have to restore the current working
                                    " directory. But doing so may not be desirable if the function changed the
                                    " working directory on purpose.
                                    "
                                    " So how can we tell if we should do it or not? A simple heuristic we use
                                    " here is that we change directory only if the current working directory
                                    " matches 'dir' entry. However, it is possible that the sink function did
                                    " change the directory to 'dir'. In that case, the user will have an
                                    " unexpected result.
    2   0.000411000   0.000036000   if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
    2   0.000212000   0.000182000     execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
    2                 0.000003000   endif
    2                 0.000005000   unlet! w:fzf_pushd

FUNCTION  go#lsp#DidOpen()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:715
Called 26 times
Total time:   0.000087000
 Self time:   0.000087000

count     total (s)      self (s)
   26                 0.000052000   if get(b:, 'go_lsp_did_open', 0)
   26                 0.000014000     return
                                    endif
                                  
                                    let l:fname = fnamemodify(a:fname, ':p')
                                    if !isdirectory(fnamemodify(l:fname, ':h'))
                                      return
                                    endif
                                  
                                    let l:lsp = s:lspfactory.get()
                                  
                                    if !has_key(l:lsp.notificationQueue, l:fname)
                                      let l:lsp.notificationQueue[l:fname] = []
                                    endif
                                  
                                    call s:ensureWorkspace(fnamemodify(l:fname, ':h'))
                                  
                                    let l:lsp.fileVersions[l:fname] = getbufvar(l:fname, 'changedtick')
                                  
                                    let l:msg = go#lsp#message#DidOpen(l:fname, join(go#util#GetLines(), "\n") . "\n", l:lsp.fileVersions[l:fname])
                                    let l:state = s:newHandlerState('')
                                  
                                    " TODO(bc): setting a buffer level variable here assumes that a:fname is the
                                    " current buffer. Change to a:fname first before setting it and then change
                                    " back to active buffer.
                                    let b:go_lsp_did_open = 1
                                  
                                    return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  go#config#HighlightExtraTypes()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:402
Called 16 times
Total time:   0.000035000
 Self time:   0.000035000

count     total (s)      self (s)
   16                 0.000031000   return get(g:, 'go_highlight_extra_types', 0)

FUNCTION  airline#extensions#tabline#group_of_bufnr()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:255
Called 209 times
Total time:   0.004194000
 Self time:   0.004194000

count     total (s)      self (s)
  209                 0.000413000     let cur = bufnr('%')
  209                 0.000223000     if cur == a:bufnr
   40                 0.000163000       if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                          let group = 'airline_tabmod'
   40                 0.000020000       else
   40                 0.000051000         let group = 'airline_tabsel'
   40                 0.000022000       endif
  169                 0.000079000     else
  169                 0.000513000       if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                          let group = 'airline_tabmod_unsel'
  169                 0.000362000       elseif index(a:tab_bufs, a:bufnr) > -1
   43                 0.000042000         let group = 'airline_tab'
  126                 0.000069000       else
  126                 0.000152000         let group = 'airline_tabhid'
  169                 0.000086000       endif
  209                 0.000102000     endif
  209                 0.000182000     return group

FUNCTION  <SNR>142_VimSlash()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:186
Called 57 times
Total time:   0.000087000
 Self time:   0.000087000

count     total (s)      self (s)
   57                 0.000064000     return a:path

FUNCTION  1()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:14
Called 499 times
Total time:   0.043079000
 Self time:   0.029094000

count     total (s)      self (s)
  499                 0.000805000     let l:prependWorkingDir = 0
                                  
  499   0.004126000   0.001236000     if nerdtree#runningWindows()
                                          let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
  499                 0.000267000     else
  499                 0.001617000         let l:prependWorkingDir = a:pathStr !~# '^/'
  499                 0.000280000     endif
                                  
  499                 0.000676000     let l:result = a:pathStr
                                  
  499                 0.000498000     if l:prependWorkingDir
  451                 0.015376000         let l:result = getcwd()
                                  
  451   0.007868000   0.001971000         if l:result[-1:] == nerdtree#slash()
                                              let l:result = l:result . a:pathStr
  451                 0.000224000         else
  451   0.006791000   0.001593000             let l:result = l:result . nerdtree#slash() . a:pathStr
  451                 0.000218000         endif
  499                 0.000244000     endif
                                  
  499                 0.000505000     return l:result

FUNCTION  3()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:47
Called 471 times
Total time:   0.032226000
 Self time:   0.025350000

count     total (s)      self (s)
  471   0.006097000   0.001994000     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                                  
  471                 0.000427000     if self.isExecutable
                                          let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
  471                 0.000210000     endif
                                  
  471                 0.000790000     let self._bookmarkNames = []
  471   0.003501000   0.001251000     for i in g:NERDTreeBookmark.Bookmarks()
                                          if i.path.equals(self)
                                              call add(self._bookmarkNames, i.name)
                                          endif
  471                 0.000310000     endfor
  471                 0.000881000     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                          let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
  471                 0.000213000     endif
                                  
  471                 0.000404000     if self.isSymLink
                                          let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
  471                 0.000190000     endif
                                  
  471   0.001981000   0.001512000     if !self.isDirectory && b:NERDTree.ui.getShowFileLines() != 0
                                          let l:bufname = self.str({'format': 'Edit'})
                                          let l:lines = 0
                                          if executable('wc') 
                                              let l:lines = split(system('wc -l "'.l:bufname.'"'))[0]
                                          elseif nerdtree#runningWindows()
                                              let l:lines = substitute(system('type "'.l:bufname.'" | find /c /v ""'), '\n', '', 'g')
                                          else 
                                              let s:lines = readfile(l:bufname)
                                              let l:lines = 0
                                              for s:line in s:lines
                                                  let l:lines += 1
                                                  if l:lines >= 20000 
                                                      break
                                                  endif
                                              endfor
                                          endif
                                          let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ('.l:lines.')'
  471                 0.000204000     endif
  471                 0.000381000     if self.isReadOnly
    6   0.000073000   0.000019000         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
  471                 0.000190000     endif

FUNCTION  4()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:93
Called 6 times
Total time:   0.000054000
 Self time:   0.000054000

count     total (s)      self (s)
    6                 0.000041000     if a:line =~# '\(.*' . g:NERDTreeNodeDelimiter . '\)\{2}'
                                          return a:line
    6                 0.000000000     else
    6                 0.000005000         return a:line . g:NERDTreeNodeDelimiter
                                      endif

FUNCTION  5()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:102
Called 3 times
Total time:   0.079856000
 Self time:   0.000911000

count     total (s)      self (s)
    3   0.000598000   0.000023000     let dir = self.str({'format': 'Cd'})
    3                 0.000005000     if self.isDirectory ==# 0
                                          let dir = self.getParent().str({'format': 'Cd'})
    3                 0.000003000     endif
                                  
    3                 0.000003000     try
    3                 0.000010000         if g:NERDTreeUseTCD && exists(':tcd') ==# 2
                                              execute 'tcd ' . dir
                                              call nerdtree#echo("Tab's CWD is now: " . getcwd())
    3                 0.000003000         else
    3                 0.000671000             execute 'cd ' . dir
    3   0.078514000   0.000144000             call nerdtree#echo('CWD is now: ' . getcwd())
    3                 0.000003000         endif
                                      catch
                                          throw 'NERDTree.PathChangeError: cannot change CWD to ' . dir
    3                 0.000003000     endtry

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:192
Called 396 times
Total time:   0.008084000
 Self time:   0.003634000

count     total (s)      self (s)
  396   0.007670000   0.003220000   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? "\u2026" : '>') : &filetype

FUNCTION  dist#script#DetectFiletype()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/autoload/dist/script.vim:10
Called 3 times
Total time:   0.001196000
 Self time:   0.000492000

count     total (s)      self (s)
    3                 0.000010000   var line1 = getline(1)
    3                 0.000005000   if line1[0] == '#' && line1[1] == '!'
                                      # File that starts with "#!".
                                      DetectFromHashBang(line1)
                                    else
                                      # File does not start with "#!".
    3   0.000709000   0.000005000     DetectFromText(line1)
    3                 0.000000000   endif

FUNCTION  ale#events#LintOnEnter()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:42
Called 10 times
Total time:   0.002881000
 Self time:   0.000146000

count     total (s)      self (s)
                                      " Unmark a file as being changed outside of Vim after we try to check it.
   10                 0.000041000     call setbufvar(a:buffer, 'ale_file_changed', 0)
                                  
   10   0.000171000   0.000041000     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
   10   0.002648000   0.000043000         call ale#Queue(0, 'lint_file', a:buffer)
   10                 0.000005000     endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:95
Called 152 times
Total time:   0.141511000
 Self time:   0.012422000

count     total (s)      self (s)
 1120                 0.001621000     for Fn in a:list
 1118   0.135769000   0.006680000       let code = call(Fn, a:000)
 1118                 0.001417000       if code != 0
  150                 0.000180000         return code
  968                 0.000566000       endif
  970                 0.000586000     endfor
    2                 0.000001000     return 0

FUNCTION  <SNR>43_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:340
Called 149 times
Total time:   0.001724000
 Self time:   0.001724000

count     total (s)      self (s)
  149                 0.000680000   if a:path =~# '/\.git$'
   18                 0.000042000     return len(a:path) ==# 5 ? '/' : a:path[0:-6]
  131                 0.000214000   elseif a:path ==# ''
  131                 0.000134000     return ''
                                    endif
                                    let dir = FugitiveActualDir(a:path)
                                    if !has_key(s:worktree_for_dir, dir)
                                      let s:worktree_for_dir[dir] = ''
                                      let ext_wtc_pat = 'v:val =~# "^\\s*worktreeConfig *= *\\%(true\\|yes\\|on\\|1\\) *$"'
                                      let config = s:ReadFile(dir . '/config', 50)
                                      if len(config)
                                        let ext_wtc_config = filter(copy(config), ext_wtc_pat)
                                        if len(ext_wtc_config) == 1 && filereadable(dir . '/config.worktree')
                                           let config += s:ReadFile(dir . '/config.worktree', 50)
                                        endif
                                      else
                                        let worktree = fnamemodify(FugitiveVimPath(get(s:ReadFile(dir . '/gitdir', 1), '0', '')), ':h')
                                        if worktree ==# '.'
                                          unlet! worktree
                                        endif
                                        if len(filter(s:ReadFile(FugitiveCommonDir(dir) . '/config', 50), ext_wtc_pat))
                                          let config = s:ReadFile(dir . '/config.worktree', 50)
                                        endif
                                      endif
                                      if len(config)
                                        let wt_config = filter(copy(config), 'v:val =~# "^\\s*worktree *="')
                                        if len(wt_config)
                                          let worktree = FugitiveVimPath(matchstr(wt_config[0], '= *\zs.*'))
                                        elseif !exists('worktree')
                                          call filter(config,'v:val =~# "^\\s*bare *= *true *$"')
                                          if empty(config)
                                            let s:worktree_for_dir[dir] = 0
                                          endif
                                        endif
                                      endif
                                      if exists('worktree')
                                        let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                        let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                      endif
                                    endif
                                    if s:worktree_for_dir[dir] =~# '^\.'
                                      return simplify(dir . '/' . s:worktree_for_dir[dir])
                                    else
                                      return s:worktree_for_dir[dir]
                                    endif

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 72 times
Total time:   0.002365000
 Self time:   0.002365000

count     total (s)      self (s)
   72                 0.000156000   if &ft == 'netrw'
                                      let spc = g:airline_symbols.space
                                  
                                      call a:1.add_section('airline_a', spc.'netrw'.spc)
                                      if exists('*airline#extensions#branch#get_head')
                                        call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                      endif
                                      call a:1.add_section('airline_c', spc.'%f'.spc)
                                      call a:1.split()
                                      call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                      return 1
   72                 0.000034000   endif

FUNCTION  <SNR>81_Remove_Matches()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/plugin/matchparen.vim:206
Called 646 times
Total time:   0.011159000
 Self time:   0.011159000

count     total (s)      self (s)
  646                 0.002305000   if exists('w:paren_hl_on') && w:paren_hl_on
   18                 0.000065000     while !empty(w:matchparen_ids)
    9                 0.000117000       silent! call remove(w:matchparen_ids, 0)->matchdelete()
   18                 0.000023000     endwhile
    9                 0.000018000     let w:paren_hl_on = 0
  646                 0.000411000   endif

FUNCTION  381()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 3 times
Total time:   0.000360000
 Self time:   0.000115000

count     total (s)      self (s)
    3                 0.000008000     let bufnum = get(self.buffers, a:i, -1)
    3   0.000138000   0.000013000     let group = self.get_group(a:i)
    3   0.000131000   0.000011000     let pgroup = self.get_group(a:i - 1)
                                      " always add a space when powerline_fonts are used
                                      " or for the very first item
    3                 0.000009000     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1                 0.000002000       let space = s:spc
    2                 0.000002000     else
    2                 0.000006000       let space= (pgroup == group ? s:spc : '')
    3                 0.000000000     endif
                                  
    3                 0.000008000     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                        if len(s:number_map) > 0
                                          return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                        else
                                          return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                        endif
    3                 0.000001000     else
    3                 0.000012000       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                      endif

FUNCTION  <SNR>101_update_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 257 times
Total time:   0.185380000
 Self time:   0.006156000

count     total (s)      self (s)
  257   0.003551000   0.001231000   call airline#util#ignore_next_focusgain()
  257   0.003207000   0.001032000   if airline#util#has_fugitive()
  257   0.176079000   0.001350000     call s:config_fugitive_branch()
                                    elseif airline#util#has_gina()
                                      call s:config_gina_branch()
                                    else
                                      let s:vcs_config['git'].branch = ''
                                      return
  257                 0.000152000   endif

FUNCTION  dist#script#Exe2filetype()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/autoload/dist/script.vim:67
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                      # Bourne-like shell scripts: bash bash2 dash ksh ksh93 sh
                                    if name =~ '^\(bash\d*\|dash\|ksh\d*\|sh\)\>'
                                      return dist#ft#SetFileTypeSH(line1, false)
                                  
                                      # csh scripts
                                    elseif name =~ '^csh\>'
                                      return dist#ft#SetFileTypeShell(exists("g:filetype_csh") ? g:filetype_csh : 'csh', false)
                                  
                                      # tcsh scripts
                                    elseif name =~ '^tcsh\>'
                                      return dist#ft#SetFileTypeShell("tcsh", false)
                                  
                                      # Z shell scripts
                                    elseif name =~ '^zsh\>'
                                      return 'zsh'
                                  
                                      # TCL scripts
                                    elseif name =~ '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                      return 'tcl'
                                  
                                      # Expect scripts
                                    elseif name =~ '^expect\>'
                                      return 'expect'
                                  
                                      # Gnuplot scripts
                                    elseif name =~ '^gnuplot\>'
                                      return 'gnuplot'
                                  
                                      # Makefiles
                                    elseif name =~ 'make\>'
                                      return 'make'
                                  
                                      # Pike
                                    elseif name =~ '^pike\%(\>\|[0-9]\)'
                                      return 'pike'
                                  
                                      # Lua
                                    elseif name =~ 'lua'
                                      return 'lua'
                                  
                                      # Perl
                                    elseif name =~ 'perl'
                                      return 'perl'
                                  
                                      # PHP
                                    elseif name =~ 'php'
                                      return 'php'
                                  
                                      # Python
                                    elseif name =~ 'python'
                                      return 'python'
                                  
                                      # Groovy
                                    elseif name =~ '^groovy\>'
                                      return 'groovy'
                                  
                                      # Raku
                                    elseif name =~ 'raku'
                                      return 'raku'
                                  
                                      # Ruby
                                    elseif name =~ 'ruby'
                                      return 'ruby'
                                  
                                      # JavaScript
                                    elseif name =~ 'node\(js\)\=\>\|js\>' || name =~ 'rhino\>'
                                      return 'javascript'
                                  
                                      # BC calculator
                                    elseif name =~ '^bc\>'
                                      return 'bc'
                                  
                                      # sed
                                    elseif name =~ 'sed\>'
                                      return 'sed'
                                  
                                      # OCaml-scripts
                                    elseif name =~ 'ocaml'
                                      return 'ocaml'
                                  
                                      # Awk scripts; also finds "gawk"
                                    elseif name =~ 'awk\>'
                                      return 'awk'
                                  
                                      # Website MetaLanguage
                                    elseif name =~ 'wml'
                                      return 'wml'
                                  
                                      # Scheme scripts
                                    elseif name =~ 'scheme'
                                      return 'scheme'
                                  
                                      # CFEngine scripts
                                    elseif name =~ 'cfengine'
                                      return 'cfengine'
                                  
                                      # Erlang scripts
                                    elseif name =~ 'escript'
                                      return 'erlang'
                                  
                                      # Haskell
                                    elseif name =~ 'haskell'
                                      return 'haskell'
                                  
                                      # Scala
                                    elseif name =~ 'scala\>'
                                      return 'scala'
                                  
                                      # Clojure
                                    elseif name =~ 'clojure'
                                      return 'clojure'
                                  
                                      # Free Pascal
                                    elseif name =~ 'instantfpc\>'
                                      return 'pascal'
                                  
                                      # Fennel
                                    elseif name =~ 'fennel\>'
                                      return 'fennel'
                                  
                                      # MikroTik RouterOS script
                                    elseif name =~ 'rsc\>'
                                      return 'routeros'
                                  
                                      # Fish shell
                                    elseif name =~ 'fish\>'
                                      return 'fish'
                                  
                                      # Gforth
                                    elseif name =~ 'gforth\>'
                                      return 'forth'
                                  
                                      # Icon
                                    elseif name =~ 'icon\>'
                                      return 'icon'
                                  
                                      # Guile
                                    elseif name =~ 'guile'
                                      return 'scheme'
                                  
                                      # Nix
                                    elseif name =~ 'nix-shell'
                                      return 'nix'
                                  
                                      # Crystal
                                    elseif name =~ '^crystal\>'
                                      return 'crystal'
                                  
                                      # Rexx
                                    elseif name =~ '^\%(rexx\|regina\)\>'
                                      return 'rexx'
                                  
                                      # Janet
                                    elseif name =~ '^janet\>'
                                      return 'janet'
                                  
                                      # Dart
                                    elseif name =~ '^dart\>'
                                      return 'dart'
                                  
                                      # Execline (s6)
                                    elseif name =~ '^execlineb\>'
                                      return 'execline'
                                  
                                    endif
                                  
                                    return ''

FUNCTION  <SNR>142_cpath()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:221
Called 48 times
Total time:   0.001186000
 Self time:   0.000820000

count     total (s)      self (s)
   48   0.000528000   0.000241000   if s:FileIgnoreCase(0)
   48   0.000346000   0.000267000     let path = s:VimSlash(tolower(a:path))
                                    else
                                      let path = s:VimSlash(a:path)
   48                 0.000026000   endif
   48                 0.000122000   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  <SNR>192_wrap()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:235
Called 1 time
Total time:   0.001371000
 Self time:   0.000072000

count     total (s)      self (s)
                                    " fzf#wrap does not append --expect if sink or sink* is found
    1                 0.000005000   let opts = copy(a:opts)
    1                 0.000002000   let options = ''
    1                 0.000003000   if has_key(opts, 'options')
    1                 0.000015000     let options = type(opts.options) == s:TYPE.list ? join(opts.options) : opts.options
    1                 0.000001000   endif
    1                 0.000012000   if options !~ '--expect' && has_key(opts, 'sink*')
    1                 0.000005000     let Sink = remove(opts, 'sink*')
    1   0.001316000   0.000017000     let wrapped = fzf#wrap(a:name, opts, a:bang)
    1                 0.000003000     let wrapped['sink*'] = Sink
                                    else
                                      let wrapped = fzf#wrap(a:name, opts, a:bang)
    1                 0.000001000   endif
    1                 0.000002000   return wrapped

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 78 times
Total time:   0.001223000
 Self time:   0.001223000

count     total (s)      self (s)
   78                 0.000747000   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                      call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
   78                 0.000052000   endif

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 34 times
Total time:   0.140619000
 Self time:   0.004452000

count     total (s)      self (s)
                                    " NOTE a:bufnr is not necessarily the current buffer.
                                  
   34   0.001128000   0.000414000   if gitgutter#utility#getbufvar(a:bufnr, 'enabled', -1) == -1
   10   0.000179000   0.000040000     call gitgutter#utility#setbufvar(a:bufnr, 'enabled', g:gitgutter_enabled)
   34                 0.000030000   endif
                                  
   34   0.011935000   0.000190000   if gitgutter#utility#is_active(a:bufnr)
                                  
   21                 0.000202000     if has('patch-7.4.1559')
   21                 0.000238000       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                      else
                                        let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   21                 0.000014000     endif
   21   0.006149000   0.000190000     let how = s:setup_path(a:bufnr, l:Callback)
   21                 0.000063000     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    2                 0.000001000       return
   19                 0.000016000     endif
                                  
   19   0.000316000   0.000104000     if a:force || s:has_fresh_changes(a:bufnr)
                                  
   11                 0.000018000       let diff = 'NOT SET'
   11                 0.000019000       try
   11   0.118219000   0.000821000         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                        catch /gitgutter not tracked/
                                          call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                        catch /gitgutter assume unchanged/
                                          call gitgutter#debug#log('Assume unchanged: '.gitgutter#utility#file(a:bufnr))
                                        catch /gitgutter diff failed/
                                          call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                          call gitgutter#hunk#reset(a:bufnr)
   11                 0.000025000       endtry
                                  
   11                 0.000057000       if diff != 'async' && diff != 'NOT SET'
                                          call gitgutter#diff#handler(a:bufnr, diff)
   11                 0.000011000       endif
                                  
   19                 0.000019000     endif
   32                 0.000027000   endif

FUNCTION  <SNR>101_reset_untracked_cache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:329
Called 9 times
Total time:   0.000880000
 Self time:   0.000697000

count     total (s)      self (s)
                                    " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    9                 0.000016000   if !exists('#airline')
                                      " airline disabled
                                      return
    9                 0.000004000   endif
    9                 0.000016000   if !g:airline#init#vim_async && !has('nvim')
                                      if a:shellcmdpost
                                        " Clear cache only if there was no error or the script uses an
                                        " asynchronous interface. Otherwise, cache clearing would overwrite
                                        " v:shell_error with a system() call inside get_*_untracked.
                                        if v:shell_error
                                          return
                                        endif
                                      endif
    9                 0.000003000   endif
                                  
    9                 0.000336000   let file = expand("%:p")
   27                 0.000046000   for vcs in keys(s:vcs_config)
                                      " Dump the value of the cache for the current file. Partially mitigates the
                                      " issue of cache invalidation happening before a call to
                                      " s:update_untracked()
   18   0.000241000   0.000058000     call airline#extensions#branch#update_untracked_config(file, vcs)
   18                 0.000090000     let s:vcs_config[vcs].untracked = {}
   27                 0.000019000   endfor

FUNCTION  airline#async#vim_vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:181
Called 20 times
Total time:   0.005101000
 Self time:   0.004956000

count     total (s)      self (s)
   20                 0.000055000     if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                        let cmd = a:cmd
   20                 0.000009000     else
   20                 0.000044000       let cmd = [&shell, &shellcmdflag, a:cmd]
   20                 0.000005000     endif
                                  
   20                 0.000073000     let options = {'buf': '', 'vcs': a:vcs, 'file': a:file}
   20                 0.000079000     let jobs = get(s:clean_jobs, a:vcs, {})
   20                 0.000032000     if has_key(jobs, a:file)
   11                 0.000076000       if job_status(get(jobs, a:file)) == 'run'
    8                 0.000004000         return
    3                 0.000004000       elseif has_key(jobs, a:file)
                                          " still running
    3                 0.000001000         return
                                          " jobs dict should be cleaned on exit, so not needed here
                                          " call remove(jobs, a:file)
                                        endif
    9                 0.000001000     endif
    9                 0.004008000     let id = job_start(cmd, { 'err_io':   'null', 'out_cb':   function('s:on_stdout', options), 'close_cb': function('s:on_exit_clean', options)})
    9   0.000392000   0.000247000     call s:set_clean_jobs_variable(a:vcs, a:file, id)

FUNCTION  <SNR>153_job_id()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:104
Called 26 times
Total time:   0.002092000
 Self time:   0.002092000

count     total (s)      self (s)
                                    " Vim
   26                 0.001839000   return job_info(a:job).process

FUNCTION  <SNR>157_IsCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:82
Called 2 times
Total time:   0.000005000
 Self time:   0.000005000

count     total (s)      self (s)
    2                 0.000004000     return type(a:value) is v:t_string || type(a:value) is v:t_func

FUNCTION  fzf#exec()
    Defined: ~/.fzf/plugin/fzf.vim:202
Called 5 times
Total time:   0.371584000
 Self time:   0.001731000

count     total (s)      self (s)
    5                 0.000022000   if !exists('s:exec')
    1                 0.000002000     let binaries = []
    1                 0.001152000     if executable('fzf')
    1                 0.000007000       call add(binaries, 'fzf')
    1                 0.000001000     endif
    1                 0.000026000     if executable(s:fzf_go)
    1                 0.000004000       call add(binaries, s:fzf_go)
    1                 0.000001000     endif
                                  
    1                 0.000002000     if empty(binaries)
                                        if input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                          redraw
                                          call fzf#install()
                                          return fzf#exec()
                                        else
                                          redraw
                                          throw 'fzf executable not found'
                                        endif
    1                 0.000003000     elseif len(binaries) > 1
    1   0.369782000   0.000030000       call sort(binaries, 's:compare_binary_versions')
    1                 0.000001000     endif
                                  
    1                 0.000009000     let s:exec = binaries[-1]
    5                 0.000005000   endif
                                  
    5                 0.000026000   if a:0 && !has_key(s:checked, a:1)
    2   0.000021000   0.000010000     let fzf_version = s:get_version(s:exec)
    2                 0.000004000     if empty(fzf_version)
                                        let message = printf('Failed to run "%s --version"', s:exec)
                                        unlet s:exec
                                        throw message
    2                 0.000002000     end
                                  
    2   0.000100000   0.000010000     if s:compare_versions(fzf_version, a:1) >= 0
    2                 0.000005000       let s:checked[a:1] = 1
    2                 0.000002000       return s:exec
                                      elseif a:0 < 2 && input(printf('You need fzf %s or above. Found: %s. Download binary? (y/n) ', a:1, fzf_version)) =~? '^y'
                                        let s:versions = {}
                                        unlet s:exec
                                        redraw
                                        call fzf#install()
                                        return fzf#exec(a:1, 1)
                                      else
                                        throw printf('You need to upgrade fzf (required: %s or above)', a:1)
                                      endif
    3                 0.000018000   endif
                                  
    3                 0.000007000   return s:exec

FUNCTION  go#config#AutoSameids()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:224
Called 9 times
Total time:   0.000038000
 Self time:   0.000038000

count     total (s)      self (s)
    9                 0.000027000     return get(g:, 'go_auto_sameids', 0)

FUNCTION  ale#linter#Get()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:374
Called 12 times
Total time:   0.008194000
 Self time:   0.002674000

count     total (s)      self (s)
   12                 0.000050000     let l:possibly_duplicated_linters = []
                                  
                                      " Handle dot-separated filetypes.
   24                 0.000200000     for l:original_filetype in split(a:original_filetypes, '\.')
   12   0.000822000   0.000092000         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   12   0.000364000   0.000058000         let l:linter_names = s:GetLinterNames(l:original_filetype)
   12   0.004535000   0.000051000         let l:all_linters = ale#linter#GetAll(l:filetype)
   12                 0.000014000         let l:filetype_linters = []
                                  
   12                 0.000035000         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                              let l:filetype_linters = l:all_linters
   12                 0.000025000         elseif type(l:linter_names) is v:t_list
                                              " Select only the linters we or the user has specified.
  123                 0.000104000             for l:linter in l:all_linters
  111                 0.000274000                 let l:name_list = [l:linter.name] + l:linter.aliases
                                  
  240                 0.000168000                 for l:name in l:name_list
  129                 0.000187000                     if index(l:linter_names, l:name) >= 0
                                                          call add(l:filetype_linters, l:linter)
                                                          break
  129                 0.000040000                     endif
  240                 0.000104000                 endfor
  123                 0.000041000             endfor
   12                 0.000032000         endif
                                  
   12                 0.000027000         call extend(l:possibly_duplicated_linters, l:filetype_linters)
   24                 0.000017000     endfor
                                  
   12                 0.000011000     let l:name_list = []
   12                 0.000013000     let l:combined_linters = []
                                  
                                      " Make sure we override linters so we don't get two with the same name,
                                      " like 'eslint' for both 'javascript' and 'typescript'
                                      "
                                      " Note that the reverse calls here modify the List variables.
   12                 0.000035000     for l:linter in reverse(l:possibly_duplicated_linters)
                                          if index(l:name_list, l:linter.name) < 0
                                              call add(l:name_list, l:linter.name)
                                              call add(l:combined_linters, l:linter)
                                          endif
   12                 0.000010000     endfor
                                  
   12                 0.000021000     return reverse(l:combined_linters)

FUNCTION  <SNR>142_TempReadPost()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3290
Called 1 time
Total time:   0.000069000
 Self time:   0.000032000

count     total (s)      self (s)
    1   0.000039000   0.000007000   let key = s:cpath(s:AbsoluteVimPath(a:file))
    1                 0.000002000   if has_key(s:temp_files, key)
                                      let dict = s:temp_files[key]
                                      if !has_key(dict, 'job')
                                        setlocal nobuflisted
                                      endif
                                      if get(dict, 'filetype', '') ==# 'git'
                                        call fugitive#MapJumps()
                                        call s:Map('n', '.', ":<C-U> <C-R>=<SID>fnameescape(<SID>TempDotMap())<CR><Home>")
                                        call s:Map('x', '.', ":<C-U> <C-R>=<SID>fnameescape(<SID>TempDotMap())<CR><Home>")
                                      endif
                                      if has_key(dict, 'filetype')
                                        if dict.filetype ==# 'man' && has('nvim')
                                          let b:man_sect = matchstr(getline(1), '^\w\+(\zs\d\+\ze)')
                                        endif
                                        if !get(g:, 'did_load_ftplugin') && dict.filetype ==# 'fugitiveblame'
                                          call s:BlameMaps(0)
                                        endif
                                        let &l:filetype = dict.filetype
                                      endif
                                      setlocal foldmarker=<<<<<<<<,>>>>>>>>
                                      if !&modifiable
                                        call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                      endif
    1                 0.000000000   endif
    1   0.000009000   0.000004000   return s:DoAutocmd('User FugitivePager')

FUNCTION  <SNR>8_DetectJS()
    Defined: ~/.vim/plugged/vim-javascript-syntax/ftdetect/javascript.vim:1
Called 3 times
Total time:   0.000022000
 Self time:   0.000022000

count     total (s)      self (s)
    3                 0.000015000     if getline(1) =~# '^#!.*/bin/\(env\s\+\)\?node\>'
                                          setfiletype javascript
    3                 0.000000000     endif

FUNCTION  go#auto#metalinter_autosave()
    Defined: ~/.vim/plugged/vim-go/autoload/go/auto.vim:181
Called 9 times
Total time:   0.000067000
 Self time:   0.000046000

count     total (s)      self (s)
    9   0.000057000   0.000036000   if !go#config#MetalinterAutosave() || !isdirectory(expand('%:p:h'))
    9                 0.000005000     return
                                    endif
                                  
                                    " run gometalinter on save
                                    call go#lint#Gometa(!g:go_jump_to_error, 1)

FUNCTION  <SNR>192_yellow()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:312
Called 3 times
Total time:   0.000447000
 Self time:   0.000025000

count     total (s)      self (s)
    3   0.000446000   0.000024000    return s:ansi(a:str, get(a:, 1, ''), 'yellow')

FUNCTION  <SNR>143_set_clean_jobs_variable()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:80
Called 9 times
Total time:   0.000145000
 Self time:   0.000145000

count     total (s)      self (s)
    9                 0.000036000   if !has_key(s:clean_jobs, a:vcs)
                                      let s:clean_jobs[a:vcs] = {}
    9                 0.000001000   endif
    9                 0.000050000   let s:clean_jobs[a:vcs][a:file]=a:id

FUNCTION  <SNR>62_validate_layout()
    Defined: ~/.fzf/plugin/fzf.vim:371
Called 2 times
Total time:   0.000084000
 Self time:   0.000084000

count     total (s)      self (s)
    4                 0.000018000   for key in keys(a:layout)
    2                 0.000012000     if index(s:layout_keys, key) < 0
                                        throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s', key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
    2                 0.000003000     endif
    4                 0.000005000   endfor
    2                 0.000004000   return a:layout

FUNCTION  UltiSnips#CheckFiletype()
    Defined: ~/.vim/plugged/ultisnips/autoload/UltiSnips.vim:194
Called 17 times
Total time:   0.002978000
 Self time:   0.002978000

count     total (s)      self (s)
   17                 0.002934000     py3 UltiSnips_Manager._check_filetype(vim.eval('&ft'))

FUNCTION  go#config#ListTypeCommands()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:5
Called 8 times
Total time:   0.000016000
 Self time:   0.000016000

count     total (s)      self (s)
    8                 0.000015000   return get(g:, 'go_list_type_commands', {})

FUNCTION  go#config#FmtExperimental()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:355
Called 18 times
Total time:   0.000079000
 Self time:   0.000079000

count     total (s)      self (s)
   18                 0.000060000   return get(g:, "go_fmt_experimental", 0 )

FUNCTION  go#config#HighlightVariableAssignments()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:455
Called 16 times
Total time:   0.000035000
 Self time:   0.000035000

count     total (s)      self (s)
   16                 0.000034000   return get(g:, 'go_highlight_variable_assignments', 0)

FUNCTION  go#config#HighlightBuildConstraints()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:439
Called 32 times
Total time:   0.000060000
 Self time:   0.000060000

count     total (s)      self (s)
   32                 0.000053000   return get(g:, 'go_highlight_build_constraints', 0)

FUNCTION  airline#extensions#tagbar#currenttag()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim:31
Called 396 times
Total time:   0.051267000
 Self time:   0.046945000

count     total (s)      self (s)
  396                 0.001366000   if get(w:, 'airline_active', 0)
  305                 0.000525000     if !s:init
                                        try
                                          " try to load the plugin, if filetypes are disabled,
                                          " this will cause an error, so try only once
                                          let a = tagbar#currenttag('%s', '', '')
                                        catch
                                        endtry
                                        unlet! a
                                        let s:init=1
  305                 0.000214000     endif
  305                 0.029378000     let cursize = getfsize(fnamemodify(bufname('%'), ':p'))
  305                 0.001593000     if cursize > 0 && cursize > get(g:, 'airline#extensions#tagbar#max_filesize', 1024 * 1024)
                                        return ''
  305                 0.000226000     endif
  305                 0.001097000     let flags = get(g:, 'airline#extensions#tagbar#flags', '')
                                      " function tagbar#currenttag does not exist, if filetype is not enabled
  305                 0.001720000     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
   75   0.005592000   0.001270000       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', flags, get(g:, 'airline#extensions#tagbar#searchmethod', 'nearest-stl'))
   75                 0.000337000       let s:airline_tagbar_last_lookup_time = localtime()
  305                 0.000205000     endif
  305                 0.000609000     return s:airline_tagbar_last_lookup_val
   91                 0.000041000   endif
   91                 0.000067000   return ''

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:227
Called 720 times
Total time:   1.496724000
 Self time:   0.100143000

count     total (s)      self (s)
  720                 0.002513000   if !has_key(s:contexts, a:winnr)
                                      return ''
  720                 0.000676000   endif
  720                 0.002800000   let context = s:contexts[a:winnr]
                                  
  720                 0.002527000   if get(w:, 'airline_active', 1)
  594                 0.001710000     let m = mode(1)
                                      " Refer :help mode() to see the list of modes
                                      "   NB: 'let mode' here refers to the display colour _groups_,
                                      "   not the literal mode's code (i.e., m). E.g., Select modes
                                      "   v, S and ^V use 'visual' since they are of similar ilk.
                                      "   Some modes do not get recognised for status line purposes:
                                      "   no, nov, noV, no^V, !, cv, and ce.
                                      "   Mode name displayed is handled in init.vim (g:airline_mode_map).
                                      "
  594                 0.001636000     if m[0] ==# "i"
    7                 0.000012000       let mode = ['insert']  " Insert modes + submodes (i, ic, ix)
  587                 0.001685000     elseif m[0] == "R"
                                        let mode = ['replace']  " Replace modes + submodes (R, Rc, Rv, Rx) (NB: case sensitive as 'r' is a mode)
  587                 0.007266000     elseif m[0] =~ '\v(v|V||s|S|)'
                                          let mode = ['visual']  " Visual and Select modes (v, V, ^V, s, S, ^S))
  587                 0.000829000     elseif m ==# "t"
                                        let mode = ['terminal']  " Terminal mode (only has one mode (t))
  587                 0.003515000     elseif m[0] =~ '\v(c|r|!)'
   34                 0.000160000       let mode = ['commandline']  " c, cv, ce, r, rm, r? (NB: cv and ce stay showing as mode entered from)
  553                 0.000493000     else
  553                 0.001214000       let mode = ['normal']  " Normal mode + submodes (n, niI, niR, niV; plus operator pendings no, nov, noV, no^V)
  594                 0.000407000     endif
  594                 0.003387000     if exists("*VMInfos") && !empty(VMInfos())
                                        " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                        let m = 'multi'
  594                 0.000361000     endif
                                      " Adjust to handle additional modes, which don't display correctly otherwise
  594                 0.004495000     if index(['niI', 'niR', 'niV', 'ic', 'ix', 'Rc', 'Rv', 'Rx', 'multi'], m) == -1
  594                 0.001324000       let m = m[0]
  594                 0.000394000     endif
  594                 0.003626000     let w:airline_current_mode = get(g:airline_mode_map, m, m)
  126                 0.000068000   else
  126                 0.000200000     let mode = ['inactive']
  126                 0.000515000     let w:airline_current_mode = get(g:airline_mode_map, '__')
  720                 0.000455000   endif
                                  
  720                 0.002780000   if g:airline_detect_modified && &modified
                                      call add(mode, 'modified')
  720                 0.000422000   endif
                                  
  720                 0.001290000   if g:airline_detect_paste && &paste
                                      call add(mode, 'paste')
  720                 0.000413000   endif
                                  
  720                 0.003371000   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                      call add(mode, 'crypt')
  720                 0.000421000   endif
                                  
  720                 0.001655000   if g:airline_detect_spell && &spell
                                      call add(mode, 'spell')
  720                 0.000391000   endif
                                  
  720                 0.001204000   if &readonly || ! &modifiable
  369                 0.001356000     call add(mode, 'readonly')
  720                 0.000557000   endif
                                  
  720                 0.003193000   let mode_string = join(mode)
  720                 0.002856000   if get(w:, 'airline_lastmode', '') != mode_string
   80   0.029894000   0.000550000     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   80   1.361715000   0.000853000     call airline#highlighter#highlight(mode, string(context.bufnr))
   80   0.006745000   0.000370000     call airline#util#doautocmd('AirlineModeChanged')
   80                 0.000202000     let w:airline_lastmode = mode_string
  720                 0.000430000   endif
                                  
  720                 0.000759000   return ''

FUNCTION  <SNR>41_WinEnterHandler()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:577
Called 22 times
Total time:   0.002272000
 Self time:   0.000965000

count     total (s)      self (s)
   22                 0.000058000   if s:disable_handlers_for_tabdo
                                      return
   22                 0.000016000   endif
                                  
                                    " We need to handle VimLeave properly.
                                    " But we shouldn't nest redefined autocmds
   22                 0.000090000   let s:ei = &eventignore
   22   0.000440000   0.000356000   let &eventignore = 'VimEnter,TabEnter,TabLeave,WinEnter,WinLeave,BufWinEnter,BufRead'
   22                 0.000044000   if g:nerdtree_tabs_autoclose
   22   0.001330000   0.000141000     call s:CloseIfOnlyNerdTreeLeft()
   22                 0.000016000   endif
   22   0.000155000   0.000121000   let &eventignore = s:ei

FUNCTION  <SNR>172_save_last_seen_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:417
Called 11 times
Total time:   0.000121000
 Self time:   0.000041000

count     total (s)      self (s)
   11   0.000115000   0.000035000   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  go#util#has_job()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:64
Called 8 times
Total time:   0.000032000
 Self time:   0.000032000

count     total (s)      self (s)
    8                 0.000030000   return has('job') || has('nvim')

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:51
Called 1078 times
Total time:   0.011064000
 Self time:   0.011064000

count     total (s)      self (s)
 1078                 0.002470000   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                      return ''
 1078                 0.000642000   endif
 1078                 0.003225000   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1078                 0.003196000   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#add_statusline_funcref()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:27
Called 4 times
Total time:   0.000037000
 Self time:   0.000037000

count     total (s)      self (s)
    4                 0.000008000   if index(g:airline_statusline_funcrefs, a:function) >= 0
                                      let warn = get(a:, 1, 1)
                                      if warn > 0
                                        call airline#util#warning(printf('The airline statusline funcref "%s" has already been added.', string(a:function)))
                                      endif
                                      return
    4                 0.000001000   endif
    4                 0.000005000   call add(g:airline_statusline_funcrefs, a:function)

FUNCTION  ale#events#QuitRecently()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:19
Called 9 times
Total time:   0.000051000
 Self time:   0.000051000

count     total (s)      self (s)
    9                 0.000023000     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                                  
    9                 0.000016000     return l:time && ale#events#ClockMilliseconds() - l:time < 1000

FUNCTION  <SNR>118_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 1079 times
Total time:   0.042563000
 Self time:   0.032582000

count     total (s)      self (s)
 1079                 0.003112000   if has_key(s:section_truncate_width, a:key)
  629   0.009275000   0.002723000     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
   77                 0.000082000       return ''
  552                 0.000433000     endif
 1002                 0.000507000   endif
 1002                 0.001945000   let spc = g:airline_symbols.space
 1002                 0.003964000   if !exists('g:airline_section_{a:key}')
                                      return ''
 1002                 0.000522000   endif
 1002   0.009054000   0.005625000   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
 1002                 0.005904000   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
 1002                 0.003442000   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#extensions#tabline#add_label()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:30
Called 31 times
Total time:   0.000900000
 Self time:   0.000442000

count     total (s)      self (s)
   31                 0.000086000   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
   31   0.000757000   0.000299000     call a:dict.add_section_spaced('airline_tablabel'. (a:right ? '_right' : ''), get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
   31                 0.000022000   endif

FUNCTION  nerdtree#onBufLeave()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:239
Called 12 times
Total time:   0.004676000
 Self time:   0.000931000

count     total (s)      self (s)
                                      " detect whether we are in the middle of sourcing a session.
                                      " if it is a buffer from the sourced session we need to restore it.
   12                 0.000157000     if exists('g:SessionLoad') && !exists('b:NERDTree')
                                          let bname = bufname('%')
                                          " is the buffer for a tab tree?
                                          if bname =~# '^' . g:NERDTreeCreator.BufNamePrefix() . 'tab_\d\+$'
                                              " rename loaded buffer and mark it as trash to prevent this event
                                              " getting fired again
                                              exec 'file TRASH_' . bname
                                              " delete the trash buffer
                                              exec 'bwipeout!'
                                              " rescue the tab tree at the current working directory
                                              call g:NERDTreeCreator.CreateTabTree(getcwd())
                                          " is the buffer for a window tree?
                                          elseif bname =~# '^' . g:NERDTreeCreator.BufNamePrefix(). 'win_\d\+$'
                                              " rescue the window tree at the current working directory
                                              call g:NERDTreeCreator.CreateWindowTree(getcwd())
                                          else " unknown buffer type
                                              " rename buffer to mark it as broken.
                                              exec 'file BROKEN_' . bname
                                              call nerdtree#echoError('Failed to restore "' . bname . '" from session. Is this session created with an older version of NERDTree?')
                                          endif
   12                 0.000011000     else
   12   0.000987000   0.000125000         if g:NERDTree.IsOpen()
   12   0.003012000   0.000129000             call b:NERDTree.ui.saveScreenState()
   12                 0.000009000         endif
   12                 0.000008000     endif

FUNCTION  <SNR>143_untracked_output()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:12
Called 10 times
Total time:   0.000109000
 Self time:   0.000109000

count     total (s)      self (s)
   10                 0.000052000   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                      let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
   10                 0.000002000   else
   10                 0.000019000     let a:dict.cfg.untracked[a:dict.file] = ''
   10                 0.000003000   endif

FUNCTION  <SNR>102_sh_autocmd_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:36
Called 36 times
Total time:   0.000417000
 Self time:   0.000417000

count     total (s)      self (s)
   36                 0.000258000   if exists('#airline')
   36                 0.000094000     unlet! b:fugitive_name
   36                 0.000025000   endif

FUNCTION  AutoSave()
    Defined: ~/.vim/plugged/vim-auto-save/plugin/AutoSave.vim:54
Called 53 times
Total time:  48.929607000
 Self time:   0.001853000

count     total (s)      self (s)
   53   0.001079000   0.000277000   if s:GetVar('auto_save', 0) == 0
                                      return
   53                 0.000026000   end
                                  
   53   0.000944000   0.000218000   let was_modified = s:IsModified()
   53                 0.000051000   if !was_modified
   42                 0.000018000     return
   11                 0.000007000   end
                                  
   11                 0.000035000   if exists("g:auto_save_presave_hook")
                                      let g:auto_save_abort = 0
                                      execute "" . g:auto_save_presave_hook
                                      if g:auto_save_abort >= 1
                                        return
                                      endif
   11                 0.000008000   endif
                                  
                                    " Preserve marks that are used to remember start and
                                    " end position of the last changed or yanked text (`:h '[`).
   11                 0.000043000   let first_char_pos = getpos("'[")
   11                 0.000033000   let last_char_pos = getpos("']")
                                  
                                    " Preserve the window view.
   11                 0.000095000   let window_view = winsaveview()
                                  
   11  48.926284000   0.000058000   call DoSave()
                                  
   11                 0.000152000   call winrestview(window_view)
                                  
   11                 0.000025000   call setpos("'[", first_char_pos)
   11                 0.000020000   call setpos("']", last_char_pos)
                                  
   11                 0.000020000   if was_modified && !&modified
    9                 0.000015000     if exists("g:auto_save_postsave_hook")
                                        execute "" . g:auto_save_postsave_hook
    9                 0.000004000     endif
                                  
    9                 0.000008000     if g:auto_save_silent == 0
    9                 0.000428000       echo "(AutoSave) saved at " . strftime("%H:%M:%S")
    9                 0.000007000     endif
   11                 0.000005000   endif

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:223
Called 13 times
Total time:   0.000334000
 Self time:   0.000334000

count     total (s)      self (s)
                                    " Ignore lasts for at most one second and is cleared on the first
                                    " focusgained. We use ignore to prevent system() calls from triggering
                                    " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                                    " tmux).
   13                 0.000122000   let dt = localtime() - s:focusgained_ignore_time
   13                 0.000100000   let s:focusgained_ignore_time = 0
   13                 0.000027000   return dt >= 1

FUNCTION  <SNR>104_conflict_marker()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:52
Called 15 times
Total time:   0.001546000
 Self time:   0.001546000

count     total (s)      self (s)
                                    " Checks for git conflict markers
   15                 0.000035000   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
   15                 0.000057000   if match(['rst', 'markdown', 'rmd'], &ft) >= 0
                                      " rst filetypes use '=======' as header
    5                 0.000019000     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
   10                 0.000005000   else
   10                 0.000027000     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
   15                 0.000004000   endif
   15                 0.001356000   return search(pattern, 'nw')

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:193
Called 126 times
Total time:   0.001998000
 Self time:   0.001998000

count     total (s)      self (s)
  126                 0.000557000   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
   10                 0.000006000     return
  116                 0.000584000   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                      let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                      unlet! b:airline_head
  116                 0.000076000   endif

FUNCTION  <SNR>119_clear()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:193
Called 2 times
Total time:   0.000503000
 Self time:   0.000102000

count     total (s)      self (s)
    2   0.000071000   0.000026000   call gitgutter#sign#clear_signs(a:bufnr)
    2   0.000209000   0.000022000   call gitgutter#hunk#reset(a:bufnr)
    2   0.000092000   0.000019000   call s:reset_tick(a:bufnr)
    2   0.000062000   0.000013000   call gitgutter#utility#setbufvar(a:bufnr, 'path', '')
    2   0.000059000   0.000012000   call gitgutter#utility#setbufvar(a:bufnr, 'basepath', '')

FUNCTION  <SNR>43_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:502
Called 710 times
Total time:   0.001580000
 Self time:   0.001580000

count     total (s)      self (s)
  710                 0.001158000     return a:path

FUNCTION  <SNR>148_debug()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:1394
Called 15 times
Total time:   0.000540000
 Self time:   0.000436000

count     total (s)      self (s)
   15                 0.000049000   let l:shouldStart = s:logtimer is 0
   15                 0.000095000   let s:log = add(s:log, [a:event, a:data])
                                  
   15                 0.000018000   if l:shouldStart
   13   0.000325000   0.000221000     let s:logtimer = timer_start(go#config#DebugLogDelay(), function('s:debugasync', []))
   15                 0.000015000   endif

FUNCTION  <SNR>172_process_modified_and_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:329
Called 11 times
Total time:   0.000148000
 Self time:   0.000148000

count     total (s)      self (s)
   11                 0.000011000   let offset = 0
   22                 0.000018000   while offset < a:to_count
   11                 0.000017000     let line_number = a:to_line + offset
   11                 0.000018000     call add(a:modifications, [line_number, 'modified'])
   11                 0.000009000     let offset += 1
   22                 0.000008000   endwhile
   11                 0.000024000   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:327
Called 12 times
Total time:   0.000730000
 Self time:   0.000187000

count     total (s)      self (s)
   12   0.000662000   0.000119000     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                                  
   12                 0.000019000     if type(l:filetype) isnot v:t_list
   12                 0.000013000         return [l:filetype]
                                      endif
                                  
                                      return l:filetype

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:307
Called 80 times
Total time:   0.001783000
 Self time:   0.001373000

count     total (s)      self (s)
                                    " airline#visual_active
                                    " Boolean: for when to get visual wordcount
                                    " needed for the wordcount extension
   80                 0.000927000   let g:airline#visual_active = (mode() =~? '[vs]')
   80   0.000680000   0.000270000   call airline#update_tabline()

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:308
Called 18 times
Total time:   0.000758000
 Self time:   0.000104000

count     total (s)      self (s)
   18   0.000720000   0.000066000   let tree = s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))
   18                 0.000016000   if tree isnot# 0 || a:0 > 1
   18                 0.000006000     return tree
                                    else
                                      return ''
                                    endif

FUNCTION  <SNR>90_Disable()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:312
Called 17 times
Total time:   0.000368000
 Self time:   0.000095000

count     total (s)      self (s)
   17   0.000316000   0.000043000     if s:Filter() == 0
                                          call s:IndentLinesDisable()
                                          call s:LeadingSpaceDisable()
   17                 0.000003000     endif

FUNCTION  <SNR>44_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:87
Called 413 times
Total time:   0.024350000
 Self time:   0.018700000

count     total (s)      self (s)
  413                 0.010916000   if winnr() != s:active_winnr || !exists('w:airline_active')
    2   0.000086000   0.000004000     call s:on_window_changed('CursorMoved')
  413                 0.000830000   endif
  413   0.008953000   0.003385000   call airline#update_tabline()

FUNCTION  <SNR>37_findAndRevealPath()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:298
Called 3 times
Total time:   0.553650000
 Self time:   0.000895000

count     total (s)      self (s)
    3                 0.000330000     let l:pathStr = !empty(a:pathStr) ? a:pathStr : expand('%:p')
    3                 0.000015000     let l:revealOpts = {}
                                  
    3                 0.000009000     if empty(l:pathStr)
    1   0.000119000   0.000014000         call nerdtree#echoWarning('no file for the current buffer')
    1                 0.000001000         return
    2                 0.000001000     endif
                                  
    2                 0.000125000     if !filereadable(l:pathStr)
                                          let l:pathStr = fnamemodify(l:pathStr, ':h')
                                          let l:revealOpts['open'] = 1
    2                 0.000002000     endif
                                  
    2                 0.000002000     try
    2   0.000140000   0.000051000         let l:pathStr = g:NERDTreePath.Resolve(l:pathStr)
    2   0.001120000   0.000017000         let l:pathObj = g:NERDTreePath.New(l:pathStr)
                                      catch /^NERDTree.InvalidArgumentsError/
                                          call nerdtree#echoWarning('invalid path')
                                          return
    2                 0.000004000     endtry
                                  
    2   0.000043000   0.000029000     if !g:NERDTree.ExistsForTab()
    2                 0.000002000         try
    2   0.000701000   0.000098000             let l:cwd = g:NERDTreePath.New(getcwd())
                                          catch /^NERDTree.InvalidArgumentsError/
                                              call nerdtree#echo('current directory does not exist.')
                                              let l:cwd = l:pathObj.getParent()
    2                 0.000003000         endtry
                                  
    2   0.000205000   0.000014000         if l:pathObj.isUnder(l:cwd)
    1   0.201744000   0.000017000             call g:NERDTreeCreator.CreateTabTree(l:cwd.str())
    1                 0.000000000         else
    1   0.209240000   0.000043000             call g:NERDTreeCreator.CreateTabTree(l:pathObj.getParent().str())
    2                 0.000000000         endif
                                      else
                                          NERDTreeFocus
                                  
                                          if !l:pathObj.isUnder(b:NERDTree.root.path)
                                              call s:chRoot(g:NERDTreeDirNode.New(l:pathObj.getParent(), b:NERDTree))
                                          endif
    2                 0.000000000     endif
                                  
    2   0.000130000   0.000007000     if l:pathObj.isHiddenUnder(b:NERDTree.root.path)
    1   0.000003000   0.000002000         call b:NERDTree.ui.setShowHidden(1)
    2                 0.000000000     endif
                                  
    2   0.071963000   0.000011000     let l:node = b:NERDTree.root.reveal(l:pathObj, l:revealOpts)
    2   0.064392000   0.000004000     call b:NERDTree.render()
    2   0.003267000   0.000005000     call l:node.putCursorHere(1, 0)

FUNCTION  FugitiveHead()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:236
Called 257 times
Total time:   0.170023000
 Self time:   0.009805000

count     total (s)      self (s)
  257                 0.001751000   if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                      let dir = FugitiveGitDir(a:1)
                                      let arg = get(a:, 2, 0)
  257                 0.000335000   elseif a:0 > 1
                                      let dir = FugitiveGitDir(a:2)
                                      let arg = a:1
  257                 0.000168000   else
  257   0.111535000   0.001371000     let dir = FugitiveGitDir()
  257                 0.000963000     let arg = get(a:, 1, 0)
  257                 0.000170000   endif
  257                 0.000459000   if empty(dir)
    3                 0.000003000     return ''
  254                 0.000145000   endif
  254   0.051563000   0.001509000   return fugitive#Head(arg, dir)

FUNCTION  <SNR>76_IsModified()
    Defined: ~/.vim/plugged/vim-auto-save/plugin/AutoSave.vim:98
Called 53 times
Total time:   0.000726000
 Self time:   0.000726000

count     total (s)      self (s)
   53                 0.000115000   if g:auto_save_write_all_buffers >= 1
                                      let buffers = filter(range(1, bufnr('$')), 'bufexists(v:val)')
                                      call filter(buffers, 'getbufvar(v:val, "&modified")')
                                      return len(buffers) > 0
   53                 0.000030000   else
   53                 0.000099000     return &modified
                                    endif

FUNCTION  <SNR>41_WinLeaveHandler()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:595
Called 22 times
Total time:   0.002372000
 Self time:   0.000509000

count     total (s)      self (s)
   22                 0.000117000   if s:disable_handlers_for_tabdo
                                      return
   22                 0.000022000   endif
                                  
   22                 0.000060000   if g:nerdtree_tabs_synchronize_view
   22   0.002047000   0.000184000     call s:SaveNERDTreeViewIfPossible()
   22                 0.000018000   endif

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:13
Called 349 times
Total time:   0.012343000
 Self time:   0.012343000

count     total (s)      self (s)
  349                 0.001413000   if !exists('b:fugitive_name')
   24                 0.000034000     let b:fugitive_name = ''
   24                 0.000011000     try
   24                 0.000150000       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                          let b:fugitive_name = FugitiveReal(bufname('%'))
   24                 0.000013000       endif
                                      catch
   24                 0.000012000     endtry
  349                 0.000230000   endif
                                  
  349                 0.001457000   let fmod = (exists("+autochdir") && &autochdir) ? ':p' : ':.'
  349                 0.000449000   let result=''
  349                 0.000764000   if empty(b:fugitive_name)
  349                 0.001379000     if empty(bufname('%'))
  145                 0.000567000       return &buftype ==# 'nofile' ? '[Scratch]' : '[No Name]'
  204                 0.000114000     endif
  204                 0.000758000     return s:has_percent_eval ? '%f' : fnamemodify(bufname('%'), fmod)
                                    else
                                      return s:has_percent_eval ? '%f [git]' : (fnamemodify(b:fugitive_name, fmod). " [git]")
                                    endif

FUNCTION  153()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:423
Called 10 times
Total time:   0.310920000
 Self time:   0.003377000

count     total (s)      self (s)
                                      "remove all the current child nodes
   10                 0.000019000     let self.children = []
                                  
   10   0.026563000   0.000137000     let files = self._glob('*', 1) + self._glob('.*', 0)
                                  
   10                 0.000030000     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                          call nerdtree#echo('Please wait, caching a large dir ...')
   10                 0.000006000     endif
                                  
   10                 0.000019000     let invalidFilesFound = 0
   10                 0.000012000     let invalidFiles = []
  261                 0.000169000     for i in files
  251                 0.000092000         try
  251   0.046254000   0.000526000             let path = g:NERDTreePath.New(i)
  251   0.007575000   0.000439000             call self.createChild(path, 0)
  251   0.006840000   0.000819000             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
                                          catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                              let invalidFilesFound += 1
                                              let invalidFiles += [i]
  251                 0.000127000         endtry
  261                 0.000091000     endfor
                                  
   10                 0.000027000     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
   10   0.121665000   0.000023000     call self.sortChildren()
                                  
   10   0.100596000   0.000028000     call nerdtree#echo('')
                                  
   10                 0.000009000     if invalidFilesFound
                                          call nerdtree#echoWarning(invalidFilesFound . ' Invalid file(s): ' . join(invalidFiles, ', '))
   10                 0.000005000     endif
   10   0.000046000   0.000024000     return self.getChildCount()

FUNCTION  <SNR>62_pushd()
    Defined: ~/.fzf/plugin/fzf.vim:596
Called 2 times
Total time:   0.000925000
 Self time:   0.000465000

count     total (s)      self (s)
    2   0.000055000   0.000013000   if s:present(a:dict, 'dir')
    2   0.000251000   0.000013000     let cwd = s:fzf_getcwd()
    2                 0.000045000     let w:fzf_pushd = {   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),   'origin': cwd,   'bufname': bufname('') }
    2   0.000414000   0.000350000     execute 'lcd' s:escape(a:dict.dir)
    2   0.000131000   0.000015000     let cwd = s:fzf_getcwd()
    2                 0.000009000     let w:fzf_pushd.dir = cwd
    2                 0.000007000     let a:dict.pushd = w:fzf_pushd
    2                 0.000004000     return cwd
                                    endif
                                    return ''

FUNCTION  <SNR>41_RestoreNERDTreeViewIfPossible()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:391
Called 2 times
Total time:   0.000132000
 Self time:   0.000119000

count     total (s)      self (s)
                                    " if nerdtree exists in current tab, it is the current window and if saved
                                    " state is available, restore it
    2                 0.000015000   let l:view_state_saved = exists('s:nerdtree_view') && exists('s:nerdtree_width')
    2   0.000033000   0.000020000   if s:IsNERDTreeOpenInCurrentTab() && l:view_state_saved
                                      let l:current_winnr = winnr()
                                      let l:nerdtree_winnr = bufwinnr(t:NERDTreeBufName)
                                  
                                      " switch to NERDTree window
                                      exe l:nerdtree_winnr . "wincmd w"
                                      " load the correct NERDTree buffer if not already loaded
                                      if exists('s:nerdtree_buffer') && t:NERDTreeBufName != s:nerdtree_buffer
                                        silent NERDTreeClose
                                        silent NERDTreeMirror
                                      endif
                                      " restore cursor, scroll and window width
                                      call winrestview(s:nerdtree_view)
                                      exe "vertical resize " . s:nerdtree_width
                                  
                                      " switch back to whatever window was focused before
                                      exe l:current_winnr . "wincmd w"
    2                 0.000002000   endif

FUNCTION  <SNR>99_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:64
Called 299 times
Total time:   0.013549000
 Self time:   0.002884000

count     total (s)      self (s)
  299   0.012141000   0.001476000   let hunks = GitGutterGetHunkSummary()
  299                 0.000996000   return hunks == [0, 0, 0] ? [] : hunks

FUNCTION  airline#util#has_custom_scm()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:174
Called 3 times
Total time:   0.000013000
 Self time:   0.000013000

count     total (s)      self (s)
    3                 0.000011000   return !empty(get(g:, 'airline#extensions#branch#custom_head', ''))

FUNCTION  <SNR>51_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:72
Called 34 times
Total time:   0.000239000
 Self time:   0.000239000

count     total (s)      self (s)
   34                 0.000205000   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  go#config#HighlightTypes()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:435
Called 16 times
Total time:   0.000029000
 Self time:   0.000029000

count     total (s)      self (s)
   16                 0.000026000   return get(g:, 'go_highlight_types', 0)

FUNCTION  airline#extensions#tabline#tabs#tabnr_formatter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/tabs.vim:130
Called 10 times
Total time:   0.000638000
 Self time:   0.000495000

count     total (s)      self (s)
   10                 0.000031000   let formatter = get(g:, 'airline#extensions#tabline#tabnr_formatter', 'tabnr')
   10                 0.000007000   try
   10   0.000528000   0.000385000     return airline#extensions#tabline#formatters#{formatter}#format(a:nr, a:i)
                                    catch /^Vim\%((\a\+)\)\=:E117/	" catch E117, unknown function
                                      " Function not found
                                      return call(formatter, [a:nr, a:i])
                                    catch
                                      " something went wrong, return an empty string
                                      return ""
   10                 0.000009000   endtry

FUNCTION  go#config#Debug()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:173
Called 22 times
Total time:   0.000115000
 Self time:   0.000115000

count     total (s)      self (s)
   22                 0.000094000   return get(g:, 'go_debug', [])

FUNCTION  <SNR>62_escape()
    Defined: ~/.fzf/plugin/fzf.vim:276
Called 4 times
Total time:   0.000094000
 Self time:   0.000094000

count     total (s)      self (s)
    4                 0.000060000   let path = fnameescape(a:path)
    4                 0.000029000   return s:is_win ? escape(path, '$') : path

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:157
Called 2 times
Total time:   0.004950000
 Self time:   0.000139000

count     total (s)      self (s)
                                    " Values of path:
                                    " * non-empty string - path
                                    " *               -1 - pending
                                    " *               -2 - not tracked by git
                                    " *               -3 - assume unchanged
                                  
    2   0.000040000   0.000016000   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    2   0.000354000   0.000025000   let cmd = gitgutter#utility#cd_cmd(a:bufnr, gitgutter#git().' ls-files -v --error-unmatch --full-name -z -- '. gitgutter#utility#shellescape(gitgutter#utility#filename(a:bufnr)))
                                  
    2   0.000017000   0.000013000   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    2                 0.000007000     let handler = copy(s:set_path_handler)
    2                 0.000003000     let handler.continuation = a:continuation
    2   0.004507000   0.000053000     call gitgutter#async#execute(cmd, a:bufnr, handler)
    2                 0.000008000     return 'async'
                                    endif
                                  
                                    let [listing, error_code] = gitgutter#utility#system(cmd)
                                  
                                    if error_code
                                      call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                      return
                                    endif
                                  
                                    let listing = s:strip_trailing_new_line(listing)
                                    let [status, path] = [listing[0], listing[2:]]
                                    if status =~# '[a-z]'
                                      call gitgutter#utility#setbufvar(a:bufnr, 'path', -3)
                                    else
                                      call gitgutter#utility#setbufvar(a:bufnr, 'path', path)
                                    endif

FUNCTION  <SNR>50_on_bufenter()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:236
Called 24 times
Total time:   0.019669000
 Self time:   0.001165000

count     total (s)      self (s)
   24   0.004663000   0.000110000   call gitgutter#setup_maps()
                                  
                                    " To keep vim's start-up fast, do not process the buffer when vim is starting.
                                    " Instead process it a short time later.  Normally we would rely on our
                                    " CursorHold autocommand to handle this but it turns out CursorHold is not
                                    " guaranteed to fire if the user has not typed anything yet; so set up a
                                    " timer instead.  The disadvantage is that if CursorHold does fire, the
                                    " plugin will do a round of unnecessary work; but since there will not have
                                    " been any changes to the buffer since the first round, the second round
                                    " will be cheap.
   24                 0.000137000   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                      if exists('*timer_start') && has('lambda')
                                        call s:next_tick("call gitgutter#process_buffer(+".bufnr('').", 0)")
                                      else
                                        call gitgutter#process_buffer(bufnr(''), 0)
                                      endif
                                      return
   24                 0.000045000   endif
                                  
   24                 0.000102000   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
    2                 0.000007000     let t:gitgutter_didtabenter = 0
    2   0.001762000   0.000020000     call gitgutter#all(!g:gitgutter_terminal_reports_focus)
   22                 0.000019000   else
   22   0.012381000   0.000172000     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
   24                 0.000008000   endif

FUNCTION  nerdtree#slash()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:47
Called 7102 times
Total time:   0.105008000
 Self time:   0.063616000

count     total (s)      self (s)
 7102   0.059801000   0.018409000     if nerdtree#runningWindows()
                                          if exists('+shellslash') && &shellslash
                                              return '/'
                                          endif
                                  
                                          return '\'
 7102                 0.004148000     endif
                                  
 7102                 0.006046000     return '/'

FUNCTION  nerdtree#pathEquals()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:229
Called 774 times
Total time:   0.013148000
 Self time:   0.006242000

count     total (s)      self (s)
  774   0.009282000   0.002376000     if nerdtree#caseSensitiveFS()
                                          return a:lhs ==# a:rhs
  774                 0.000544000     else
  774                 0.001704000         return a:lhs ==? a:rhs
                                      endif

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:51
Called 83 times
Total time:   0.240888000
 Self time:   0.005212000

count     total (s)      self (s)
   83                 0.000075000   try
   83   0.022690000   0.000417000     call <sid>map_keys()
                                    catch
                                      " no-op
   83                 0.000091000   endtry
   83                 0.000277000   let cur = bufnr('%')
   83                 0.000355000   if cur == s:current_bufnr && &columns == s:column_width
   62                 0.000320000     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
   62                 0.000163000       return s:current_tabline
                                      endif
   21                 0.000011000   endif
                                  
   21   0.001798000   0.000129000   let b = airline#extensions#tabline#new_builder()
   21                 0.000082000   let tab_bufs = tabpagebuflist(tabpagenr())
   21                 0.000035000   let show_buf_label_first = 0
                                  
   21                 0.000057000   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                      let show_buf_label_first = 1
   21                 0.000011000   endif
   21                 0.000023000   if show_buf_label_first
                                      call airline#extensions#tabline#add_label(b, 'buffers', 0)
   21                 0.000012000   endif
                                  
   21                 0.000083000   let b.tab_bufs = tabpagebuflist(tabpagenr())
                                  
   21                 0.000034000   let b.overflow_group = 'airline_tabhid'
   21   0.007814000   0.000131000   let b.buffers = airline#extensions#tabline#buflist#list()
   21                 0.000061000   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                      if index(b.buffers, cur) > -1
                                        call remove(b.buffers, index(b.buffers, cur))
                                      endif
                                      let b.buffers = [cur] + b.buffers
   21                 0.000010000   endif
                                  
   21                 0.000102000   function! b.get_group(i) dict
                                      let bufnum = get(self.buffers, a:i, -1)
                                      if bufnum == -1
                                        return ''
                                      endif
                                      let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                      if bufnum == bufnr('%')
                                        let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                      endif
                                      return group
                                    endfunction
                                  
   21                 0.000101000   if has("tablineat")
                                      function! b.get_pretitle(i) dict
                                        let bufnum = get(self.buffers, a:i, -1)
                                        return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                      endfunction
                                  
                                      function! b.get_posttitle(i) dict
                                        return '%X'
                                      endfunction
   21                 0.000014000   endif
                                  
   21                 0.000021000   function! b.get_title(i) dict
                                      let bufnum = get(self.buffers, a:i, -1)
                                      let group = self.get_group(a:i)
                                      let pgroup = self.get_group(a:i - 1)
                                      " always add a space when powerline_fonts are used
                                      " or for the very first item
                                      if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                        let space = s:spc
                                      else
                                        let space= (pgroup == group ? s:spc : '')
                                      endif
                                  
                                      if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                        if len(s:number_map) > 0
                                          return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                        else
                                          return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                        endif
                                      else
                                        return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                      endif
                                    endfunction
                                  
   21                 0.000131000   let current_buffer = max([index(b.buffers, cur), 0])
   21                 0.000058000   let last_buffer = len(b.buffers) - 1
   21   0.000526000   0.000105000   call b.insert_titles(current_buffer, 0, last_buffer)
                                  
   21   0.000158000   0.000074000   call b.add_section('airline_tabfill', '')
   21   0.000124000   0.000042000   call b.split()
   21   0.000125000   0.000052000   call b.add_section('airline_tabfill', '')
   21                 0.000031000   if !show_buf_label_first
   21   0.000651000   0.000120000     call airline#extensions#tabline#add_label(b, 'buffers', 1)
   21                 0.000016000   endif
                                  
   21   0.000508000   0.000100000   call airline#extensions#tabline#add_tab_label(b)
                                  
   21                 0.000041000   let s:current_bufnr = cur
   21                 0.000045000   let s:column_width = &columns
   21   0.202597000   0.000145000   let s:current_tabline = b.build()
   21                 0.000071000   let s:current_visible_buffers = copy(b.buffers)
                                    " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                                    "if b._right_title <= last_buffer
                                    "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                                    "endif
                                    "if b._left_title > 0
                                    "  call remove(s:current_visible_buffers, 0, b._left_title)
                                    "endif
   21                 0.000026000   return s:current_tabline

FUNCTION  <SNR>51_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 21 times
Total time:   0.003679000
 Self time:   0.000419000

count     total (s)      self (s)
   21   0.003657000   0.000397000   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>192_function()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:270
Called 1 time
Total time:   0.000007000
 Self time:   0.000007000

count     total (s)      self (s)
    1                 0.000006000     return function(a:name)

FUNCTION  fzf#vim#with_preview()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:152
Called 1 time
Total time:   0.002029000
 Self time:   0.000266000

count     total (s)      self (s)
                                    " Default spec
    1                 0.000005000   let spec = {}
    1                 0.000002000   let window = ''
                                  
    1                 0.000009000   let args = copy(a:000)
                                  
                                    " Spec to wrap
    1                 0.000013000   if len(args) && type(args[0]) == s:TYPE.dict
    1                 0.000008000     let spec = copy(args[0])
    1                 0.000008000     call remove(args, 0)
    1                 0.000002000   endif
                                  
    1   0.001643000   0.000048000   if !executable(s:bash())
                                      return spec
    1                 0.000001000   endif
                                  
                                    " Placeholder expression (TODO/TBD: undocumented)
    1                 0.000006000   let placeholder = get(spec, 'placeholder', '{}')
                                  
                                    " g:fzf_preview_window
    1                 0.000002000   if empty(args)
    1   0.000021000   0.000008000     let preview_args = s:conf('preview_window', ['', 'ctrl-/'])
    1                 0.000003000     if empty(preview_args)
                                        let args = ['hidden']
    1                 0.000001000     else
                                        " For backward-compatiblity
    1                 0.000007000       let args = type(preview_args) == type('') ? [preview_args] : copy(preview_args)
    1                 0.000001000     endif
    1                 0.000001000   endif
                                  
    1                 0.000006000   if len(args) && type(args[0]) == s:TYPE.string
    1                 0.000004000     if len(args[0]) && args[0] !~# '^\(up\|down\|left\|right\|hidden\)'
                                        throw 'invalid preview window: '.args[0]
    1                 0.000001000     endif
    1                 0.000003000     let window = args[0]
    1                 0.000004000     call remove(args, 0)
    1                 0.000001000   endif
                                  
    1                 0.000001000   let preview = []
    1                 0.000002000   if len(window)
                                      let preview += ['--preview-window', window]
    1                 0.000000000   endif
    1                 0.000001000   if s:is_win
                                      if empty($MSWINHOME)
                                        let $MSWINHOME = $HOME
                                      endif
                                      if s:is_wsl_bash && $WSLENV !~# '[:]\?MSWINHOME\(\/[^:]*\)\?\(:\|$\)'
                                        let $WSLENV = 'MSWINHOME/u:'.$WSLENV
                                      endif
    1                 0.000000000   endif
    1   0.000132000   0.000032000   let preview_cmd = s:bash() . ' ' . s:escape_for_bash(s:bin.preview)
    1                 0.000002000   if len(placeholder)
    1                 0.000006000     let preview += ['--preview', preview_cmd.' '.placeholder]
    1                 0.000001000   end
    1                 0.000003000   if &ambiwidth ==# 'double'
                                      let preview += ['--no-unicode']
    1                 0.000001000   end
                                  
    1                 0.000002000   if len(args)
    1                 0.000013000     call extend(preview, ['--bind', join(map(args, 'v:val.":toggle-preview"'), ',')])
    1                 0.000001000   endif
    1   0.000065000   0.000010000   call s:merge_opts(spec, preview)
    1                 0.000001000   return spec

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:145
Called 277 times
Total time:   0.002254000
 Self time:   0.002254000

count     total (s)      self (s)
  277                 0.000902000   if !exists("s:has_fugitive")
                                      let s:has_fugitive = exists('*FugitiveHead')
  277                 0.000146000   endif
  277                 0.000348000   return s:has_fugitive

FUNCTION  <SNR>72_register()
    Defined: ~/.vim/plugged/vim-go/plugin/go.vim:251
Called 17 times
Total time:   0.000575000
 Self time:   0.000546000

count     total (s)      self (s)
   17                 0.000034000   if !(&modifiable && expand('<amatch>') ==# 'go')
    9                 0.000002000     return
    8                 0.000002000   endif
                                  
                                    " Resolve any symlinks in <afile> so that the filename will match what Vim
                                    " will ultimately and usually produce.
    8   0.000514000   0.000485000   call go#lsp#DidOpen(resolve(expand('<afile>:p')))

FUNCTION  airline#highlighter#add_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:180
Called 31 times
Total time:   0.000154000
 Self time:   0.000154000

count     total (s)      self (s)
   31                 0.000129000     let s:accents[a:accent] = 1

FUNCTION  <SNR>117_get_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 538 times
Total time:   0.517995000
 Self time:   0.006151000

count     total (s)      self (s)
  538   0.177814000   0.002353000   if airline#builder#should_change_group(a:prev_group, a:group)
  496   0.339172000   0.002789000     return s:get_transitioned_separator(a:self, a:prev_group, a:group, a:side)
   42                 0.000023000   else
   42                 0.000102000     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                                    endif

FUNCTION  <SNR>192_bash()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:49
Called 2 times
Total time:   0.001601000
 Self time:   0.001581000

count     total (s)      self (s)
    2                 0.000009000   if exists('s:bash')
    1                 0.000002000     return s:bash
    1                 0.000001000   endif
                                  
    1   0.000033000   0.000013000   let custom_bash = s:conf('preview_bash', '')
    1                 0.000003000   let git_bash = 'C:\Program Files\Git\bin\bash.exe'
    1                 0.000021000   let candidates = filter(s:is_win ? [custom_bash, 'bash', git_bash] : [custom_bash, 'bash'], 'len(v:val)')
                                  
    1                 0.001489000   let found = filter(map(copy(candidates), 'exepath(v:val)'), 'len(v:val)')
    1                 0.000005000   if empty(found)
                                      if !s:warned
                                        call s:warn(printf('Preview window not supported (%s not found)', join(candidates, ', ')))
                                        let s:warned = 1
                                      endif
                                      let s:bash = ''
                                      return s:bash
    1                 0.000000000   endif
                                  
    1                 0.000005000   let s:bash = found[0]
                                  
                                    " Make 8.3 filename via cmd.exe
    1                 0.000002000   if s:is_win
                                      let s:bash = s:winpath(s:bash)
    1                 0.000001000   endif
                                  
    1                 0.000002000   return s:bash

FUNCTION  <SNR>124_tabline_evaluated_length()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:223
Called 181 times
Total time:   0.022147000
 Self time:   0.001057000

count     total (s)      self (s)
  181   0.022092000   0.001002000   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  fzf#vim#buffers()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:814
Called 1 time
Total time:   0.448878000
 Self time:   0.000128000

count     total (s)      self (s)
    1                 0.000010000   let [query, args] = (a:0 && type(a:1) == type('')) ? [a:1, a:000[1:]] : ['', a:000]
    1                 0.000005000   if len(args) && type(args[0]) == s:TYPE.list
                                      let [buffers; args] = args
    1                 0.000001000   else
    1   0.000061000   0.000008000     let buffers = s:buflisted()
    1                 0.000001000   endif
    1   0.000094000   0.000022000   let sorted = sort(buffers, 's:sort_buffers')
    1                 0.000008000   let header_lines = '--header-lines=' . (bufnr('') == get(sorted, 0, 0) ? 1 : 0)
    1                 0.000007000   let tabstop = len(max(sorted)) >= 4 ? 9 : 8
    1   0.448684000   0.000059000   return s:fzf('buffers', { 'source':  map(sorted, 'fzf#vim#_format_buffer(v:val)'), 'sink*':   s:function('s:bufopen'), 'options': ['+m', '-x', '--tiebreak=index', header_lines, '--ansi', '-d', '\t', '--with-nth', '3..', '-n', '2,1..2', '--prompt', 'Buf> ', '--query', query, '--preview-window', '+{2}-/2', '--tabstop', tabstop]}, args)

FUNCTION  369()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 4 times
Total time:   0.000253000
 Self time:   0.000081000

count     total (s)      self (s)
    4                 0.000006000     let bufnum = get(self.buffers, a:i, -1)
    4   0.000095000   0.000007000     let group = self.get_group(a:i)
    4   0.000092000   0.000008000     let pgroup = self.get_group(a:i - 1)
                                      " always add a space when powerline_fonts are used
                                      " or for the very first item
    4                 0.000005000     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1                 0.000001000       let space = s:spc
    3                 0.000000000     else
    3                 0.000006000       let space= (pgroup == group ? s:spc : '')
    4                 0.000000000     endif
                                  
    4                 0.000005000     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                        if len(s:number_map) > 0
                                          return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                        else
                                          return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                        endif
    4                 0.000001000     else
    4                 0.000009000       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                      endif

FUNCTION  <SNR>62_cmd()
    Defined: ~/.fzf/plugin/fzf.vim:1073
Called 1 time
Total time:   0.090952000
 Self time:   0.000827000

count     total (s)      self (s)
    1                 0.000027000   let args = copy(a:000)
    1                 0.000014000   let opts = { 'options': ['--multi'] }
    1                 0.000652000   if len(args) && isdirectory(expand(args[-1]))
                                      let opts.dir = substitute(substitute(remove(args, -1), '\\\(["'']\)', '\1', 'g'), '[/\\]*$', '/', '')
                                      if s:is_win && !&shellslash
                                        let opts.dir = substitute(opts.dir, '/', '\\', 'g')
                                      endif
                                      let prompt = opts.dir
    1                 0.000002000   else
    1   0.000314000   0.000023000     let prompt = s:shortpath()
    1                 0.000002000   endif
    1                 0.000018000   let prompt = strwidth(prompt) < &columns - 20 ? prompt : '> '
    1                 0.000013000   call extend(opts.options, ['--prompt', prompt])
    1                 0.000006000   call extend(opts.options, args)
    1   0.089859000   0.000025000   call fzf#run(fzf#wrap('FZF', opts, a:bang))

FUNCTION  <SNR>172_is_modified_and_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:285
Called 11 times
Total time:   0.000024000
 Self time:   0.000024000

count     total (s)      self (s)
   11                 0.000019000   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:239
Called 22 times
Total time:   0.004093000
 Self time:   0.004093000

count     total (s)      self (s)
   22                 0.003268000   let p = resolve(expand('#'.a:bufnr.':p'))
   22                 0.000524000   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
   22                 0.000129000   if !empty(ml) && !empty(ml[1])
                                      return ml[1].'^'
   22                 0.000020000   endif
   22                 0.000051000   return g:gitgutter_diff_base

FUNCTION  fzf#wrap()
    Defined: ~/.fzf/plugin/fzf.vim:387
Called 2 times
Total time:   0.002577000
 Self time:   0.000759000

count     total (s)      self (s)
    2                 0.000012000   let args = ['', {}, 0]
    2                 0.000047000   let expects = map(copy(args), 'type(v:val)')
    2                 0.000005000   let tidx = 0
    8                 0.000028000   for arg in copy(a:000)
    6                 0.000062000     let tidx = index(expects, type(arg) == 6 ? type(0) : type(arg), tidx)
    6                 0.000013000     if tidx < 0
                                        throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
    6                 0.000008000     endif
    6                 0.000028000     let args[tidx] = arg
    6                 0.000017000     let tidx += 1
    6                 0.000027000     unlet arg
    8                 0.000014000   endfor
    2                 0.000009000   let [name, opts, bang] = args
                                  
    2                 0.000007000   if len(name)
    2                 0.000017000     let opts.name = name
    2                 0.000003000   end
                                  
                                    " Layout: g:fzf_layout (and deprecated g:fzf_height)
    2                 0.000004000   if bang
                                      for key in s:layout_keys
                                        if has_key(opts, key)
                                          call remove(opts, key)
                                        endif
                                      endfor
    2   0.000184000   0.000040000   elseif !s:has_any(opts, s:layout_keys)
    2                 0.000017000     if !exists('g:fzf_layout') && exists('g:fzf_height')
                                        let opts.down = g:fzf_height
    2                 0.000003000     else
    2   0.000241000   0.000051000       let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout())))
    2                 0.000002000     endif
    2                 0.000002000   endif
                                  
                                    " Colors: g:fzf_colors
    2   0.001449000   0.000047000   let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                                  
                                    " History: g:fzf_history_dir
    2                 0.000016000   if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                      let dir = s:fzf_expand(g:fzf_history_dir)
                                      if !isdirectory(dir)
                                        call mkdir(dir, 'p')
                                      endif
                                      let history = fzf#shellescape(dir.'/'.name)
                                      let opts.options = join(['--history', history, opts.options])
    2                 0.000003000   endif
                                  
                                    " Action: g:fzf_action
    2   0.000098000   0.000016000   if !s:has_any(opts, ['sink', 'sinklist', 'sink*'])
    2                 0.000014000     let opts._action = get(g:, 'fzf_action', s:default_action)
    2                 0.000024000     let opts.options .= ' --expect='.join(keys(opts._action), ',')
    2                 0.000017000     function! opts.sinklist(lines) abort
                                        return s:common_sink(self._action, a:lines)
                                      endfunction
    2                 0.000011000     let opts['sink*'] = opts.sinklist " For backward compatibility
    2                 0.000003000   endif
                                  
    2                 0.000004000   return opts

FUNCTION  airline#add_statusline_func()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:16
Called 4 times
Total time:   0.000064000
 Self time:   0.000027000

count     total (s)      self (s)
    4                 0.000009000   let warn = get(a:, 1, 1)
    4   0.000055000   0.000018000   call airline#add_statusline_funcref(function(a:name), warn)

FUNCTION  airline#async#vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:57
Called 20 times
Total time:   0.015879000
 Self time:   0.000869000

count     total (s)      self (s)
   20                 0.000038000   if g:airline#init#vim_async
                                      " Vim 8 with async support
   20   0.015640000   0.000630000     noa call airline#async#vim_vcs_untracked(a:config, a:file)
                                    else
                                      " nvim async or vim without job-feature
                                      noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
   20                 0.000004000   endif

FUNCTION  <SNR>62_present()
    Defined: ~/.fzf/plugin/fzf.vim:562
Called 8 times
Total time:   0.000244000
 Self time:   0.000244000

count     total (s)      self (s)
   18                 0.000051000   for key in a:000
   16                 0.000099000     if !empty(get(a:dict, key, ''))
    6                 0.000017000       return 1
   10                 0.000011000     endif
   12                 0.000015000   endfor
    2                 0.000003000   return 0

FUNCTION  go#config#HighlightFormatStrings()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:447
Called 16 times
Total time:   0.000037000
 Self time:   0.000037000

count     total (s)      self (s)
   16                 0.000032000   return get(g:, 'go_highlight_format_strings', 1)

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:172
Called 154 times
Total time:   0.001036000
 Self time:   0.001036000

count     total (s)      self (s)
  154                 0.000424000   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                      return toupper(b:keymap_name)
  154                 0.000079000   endif
  154                 0.000117000   return ''

FUNCTION  <SNR>76_GetVar()
    Defined: ~/.vim/plugged/vim-auto-save/plugin/AutoSave.vim:111
Called 53 times
Total time:   0.000802000
 Self time:   0.000802000

count     total (s)      self (s)
   53                 0.000116000   let varName = a:1
                                  
   53                 0.000158000   if exists('w:' . varName)
                                      return w:{varName}
   53                 0.000118000   elseif exists('b:' . varName)
                                      return b:{varName}
   53                 0.000122000   elseif exists('g:' . varName)
   53                 0.000101000     return g:{varName}
                                    else
                                      return exists('a:2') ? a:2 : ''
                                    endif

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 409 times
Total time:   0.009092000
 Self time:   0.003253000

count     total (s)      self (s)
  409   0.008756000   0.002917000   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:301
Called 669 times
Total time:   0.010133000
 Self time:   0.010133000

count     total (s)      self (s)
  669                 0.006251000   if get(g:, 'airline_statusline_ontop', 0)
                                      call airline#extensions#tabline#redraw()
  669                 0.000611000   endif

FUNCTION  <SNR>41_SaveGlobalFocus()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:285
Called 2 times
Total time:   0.000068000
 Self time:   0.000029000

count     total (s)      self (s)
    2   0.000066000   0.000027000   let s:is_nerdtree_globally_focused = s:IsCurrentWindowNERDTree()

FUNCTION  <SNR>50_on_buffilepre()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:268
Called 2 times
Total time:   0.000128000
 Self time:   0.000067000

count     total (s)      self (s)
    2                 0.000011000   if !exists('s:renaming')
    2                 0.000009000     let s:renaming = []
    2   0.000089000   0.000028000     let s:gitgutter_was_enabled = gitgutter#utility#getbufvar(a:bufnr, 'enabled')
    2                 0.000001000   endif
                                  
    2                 0.000010000   let s:renaming += [a:bufnr]

FUNCTION  <SNR>124_get_separator_change_with_end()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:76
Called 129 times
Total time:   0.044852000
 Self time:   0.002815000

count     total (s)      self (s)
  129                 0.000161000   let sep_change = 0
  129                 0.000232000   if !empty(a:new_end_group) " Separator between title and the end
  104   0.026203000   0.000547000     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
  129                 0.000073000   endif
  129                 0.000242000   if !empty(a:old_group) " Separator between the title and the one adjacent
   51   0.008913000   0.000219000     let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
   51                 0.000089000     if !empty(a:old_end_group) " Remove mis-predicted separator
   51   0.007910000   0.000223000       let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
   51                 0.000025000     endif
  129                 0.000051000   endif
  129                 0.000142000   return sep_change

FUNCTION  <SNR>124_get_separator_change()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:68
Called 103 times
Total time:   0.034065000
 Self time:   0.000685000

count     total (s)      self (s)
  103   0.034021000   0.000641000   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  <SNR>114_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:140
Called 200 times
Total time:   0.021729000
 Self time:   0.021729000

count     total (s)      self (s)
                                      " a:list needs to have 5 items!
  200                 0.000236000     let res = ''
  200                 0.000205000     let i = -1
 1200                 0.001124000     while i < 4
 1000                 0.001068000       let i += 1
 1000                 0.002186000       let item = get(a:list, i, '')
 1000                 0.001106000       if item is ''
  162                 0.000122000         continue
  838                 0.000457000       endif
  838                 0.000748000       if i == 0
  200                 0.000407000         let res .= ' guifg='.item
  638                 0.000554000       elseif i == 1
  200                 0.000338000         let res .= ' guibg='.item
  438                 0.000355000       elseif i == 2
  200                 0.000370000         let res .= ' ctermfg='.item
  238                 0.000219000       elseif i == 3
  200                 0.000367000         let res .= ' ctermbg='.item
   38                 0.000034000       elseif i == 4
   38                 0.000165000         let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  838                 0.000471000       endif
 1038                 0.000732000     endwhile
  200                 0.000188000     return res

FUNCTION  <SNR>172_is_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:273
Called 77 times
Total time:   0.000095000
 Self time:   0.000095000

count     total (s)      self (s)
   77                 0.000084000   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>143_on_exit_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:121
Called 10 times
Total time:   0.000210000
 Self time:   0.000101000

count     total (s)      self (s)
   10   0.000154000   0.000045000     call s:untracked_output(self, self.buf)
   10                 0.000015000     if has_key(s:untracked_jobs, self.file)
    9                 0.000014000       call remove(s:untracked_jobs, self.file)
   10                 0.000004000     endif

FUNCTION  <SNR>41_IsNERDTreeOpenInCurrentTab()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:355
Called 2 times
Total time:   0.000013000
 Self time:   0.000013000

count     total (s)      self (s)
    2                 0.000013000   return exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1

FUNCTION  go#util#IsUsingCygwinShell()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:56
Called 17 times
Total time:   0.000217000
 Self time:   0.000140000

count     total (s)      self (s)
   17   0.000195000   0.000118000   return go#util#IsWin() && executable('cygpath') && &shell =~ '.*sh.*'

FUNCTION  go#util#HasDebug()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:513
Called 22 times
Total time:   0.000372000
 Self time:   0.000257000

count     total (s)      self (s)
   22   0.000350000   0.000235000   return index(go#config#Debug(), a:flag) >= 0

FUNCTION  <SNR>103_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:68
Called 110 times
Total time:   0.001270000
 Self time:   0.000858000

count     total (s)      self (s)
                                    " Use the new ALE statusline API function if it is available.
  110                 0.000322000   if exists("*ale#statusline#FirstProblem")
  110   0.000833000   0.000421000     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                                    endif
                                  
                                    return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  <SNR>55_Unmap()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim:183
Called 15 times
Total time:   0.005921000
 Self time:   0.004712000

count     total (s)      self (s)
   15   0.001384000   0.000415000   let imaps = s:get('right_delims', []) + s:get('left_delims', []) + s:get('quotes_list', []) + s:get('apostrophes_list', []) + ['<BS>', '<C-h>', '<S-BS>', '<Del>', '<CR>', '<Space>', '<S-Tab>', '<Esc>'] + ['<Up>', '<Down>', '<Left>', '<Right>', '<LeftMouse>', '<RightMouse>'] + ['<C-Left>', '<C-Right>'] + ['<Home>', '<End>', '<PageUp>', '<PageDown>', '<S-Down>', '<S-Up>', '<C-G>g']
                                  
  495                 0.000259000   for map in imaps
  480                 0.001992000     if maparg(map, "i") =~# '^<Plug>delimitMate'
  206                 0.000146000       if map == '|'
                                          let map = '<Bar>'
  206                 0.000069000       endif
  206                 0.000573000       exec 'silent! iunmap <buffer> ' . map
  480                 0.000148000     endif
  495                 0.000187000   endfor
   15   0.000318000   0.000078000   silent! doautocmd <nomodeline> User delimitMate_unmap
   15                 0.000035000   let b:delimitMate_enabled = 0

FUNCTION  <SNR>192_csi()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:295
Called 5 times
Total time:   0.000095000
 Self time:   0.000095000

count     total (s)      self (s)
    5                 0.000014000   let prefix = a:fg ? '38;' : '48;'
    5                 0.000018000   if a:color[0] == '#'
                                      return prefix.'2;'.join(map([a:color[1:2], a:color[3:4], a:color[5:6]], 'str2nr(v:val, 16)'), ';')
    5                 0.000005000   endif
    5                 0.000015000   return prefix.'5;'.a:color

FUNCTION  go#config#FoldEnable()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:479
Called 192 times
Total time:   0.001559000
 Self time:   0.000983000

count     total (s)      self (s)
  192                 0.000165000   if a:0 > 0
   96                 0.000142000     return index(go#config#FoldEnable(), a:1) > -1
   96                 0.000029000   endif
   96                 0.000267000   return get(g:, 'go_fold_enable', ['block', 'import', 'varconst', 'package_comment'])

FUNCTION  296()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:9
Called 24 times
Total time:   0.000373000
 Self time:   0.000373000

count     total (s)      self (s)
   24                 0.000246000   if empty(get(self, 'current', {})) || empty(get(self.current, 'job', {}))
                                      let self.current = s:newlsp()
   24                 0.000019000   endif
                                  
   24                 0.000026000   return self.current

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:51
Called 25 times
Total time:   0.000955000
 Self time:   0.000955000

count     total (s)      self (s)
                                      " Apply pattern options if the variable is set.
   25                 0.000162000     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                          call ale#pattern_options#SetOptions(a:buffer)
   25                 0.000013000     endif
                                  
                                      " When entering a buffer, we are no longer quitting it.
   25                 0.000109000     call setbufvar(a:buffer, 'ale_quitting', 0)
   25                 0.000092000     let l:filetype = getbufvar(a:buffer, '&filetype')
   25                 0.000246000     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                                  
                                      " If the file changed outside of Vim, check it on BufEnter,BufRead
   25                 0.000065000     if getbufvar(a:buffer, 'ale_file_changed')
                                          call ale#events#LintOnEnter(a:buffer)
   25                 0.000017000     endif

FUNCTION  <SNR>143_on_stdout()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:113
Called 28 times
Total time:   0.000120000
 Self time:   0.000120000

count     total (s)      self (s)
   28                 0.000108000     let self.buf .= a:msg

FUNCTION  go#util#Shelljoin()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:300
Called 9 times
Total time:   0.001702000
 Self time:   0.001621000

count     total (s)      self (s)
                                    " Preserve original shell. This needs to be kept in sync with how s:system
                                    " sets shell.
    9                 0.000058000   let l:shell = &shell
                                  
    9                 0.000015000   try
    9   0.000586000   0.000545000     if !go#util#IsWin() && executable('/bin/sh')
    9                 0.000202000         set shell=/bin/sh
    9                 0.000010000     endif
                                  
    9   0.000079000   0.000039000     if go#util#IsWin()
                                        if executable($COMSPEC)
                                          let &shell = $COMSPEC
                                        endif
    9                 0.000008000     endif
                                  
    9                 0.000026000     let ssl_save = &shellslash
    9                 0.000015000     set noshellslash
    9                 0.000017000     if a:0
                                        return join(map(copy(a:arglist), 'shellescape(v:val, ' . a:1 . ')'), ' ')
    9                 0.000008000     endif
                                  
    9                 0.000356000     return join(map(copy(a:arglist), 'shellescape(v:val)'), ' ')
    9                 0.000025000   finally
                                      " Restore original values
    9                 0.000034000     let &shellslash = ssl_save
    9                 0.000047000     let &shell = l:shell
    9                 0.000018000   endtry

FUNCTION  <SNR>44_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:51
Called 63 times
Total time:   0.547796000
 Self time:   0.002693000

count     total (s)      self (s)
                                    " don't trigger for Vim popup windows
   63                 0.000148000   if &buftype is# 'popup'
                                      return
   63                 0.000028000   endif
                                  
   63                 0.000192000   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                      " do not trigger for previewwindows
                                      return
   63                 0.000030000   endif
   63                 0.000229000   let s:active_winnr = winnr()
                                    " Handle each window only once, since we might come here several times for
                                    " different autocommands.
   63                 0.000462000   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
   63                 0.000498000   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                      " fugitive is special, it changes names and filetypes several times,
                                      " make sure the caching does not get into its way
   21                 0.000013000     return
   42                 0.000020000   endif
   42                 0.000168000   let g:airline_last_window_changed = l:key
   42   0.000399000   0.000158000   call s:init()
   42   0.545098000   0.000236000   call airline#update_statusline()

FUNCTION  302()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:222
Called 6 times
Total time:   0.009642000
 Self time:   0.000148000

count     total (s)      self (s)
                                        " TODO(bc): handle more notifications (e.g. window/showMessage).
    6                 0.000030000       if a:req.method == 'textDocument/publishDiagnostics'
    6   0.009541000   0.000047000         call self.handleDiagnostics(a:req.params)
                                        elseif a:req.method == 'window/showMessage'
                                          call self.showMessage(a:req.params)
    6                 0.000006000       endif

FUNCTION  <SNR>135_SetTagbar()
    Defined: ~/.vim/plugged/vim-go/ftplugin/go/tagbar.vim:21
Called 1 time
Total time:   0.001118000
 Self time:   0.000023000

count     total (s)      self (s)
    1   0.001102000   0.000007000   let bin_path = go#path#CheckBinPath(g:go_gotags_bin)
    1                 0.000002000   if empty(bin_path)
                                      return
    1                 0.000001000   endif
                                  
    1                 0.000003000   if !exists("g:tagbar_type_go")
                                      let g:tagbar_type_go = { 'ctagstype' : 'go', 'kinds'     : [ 'p:package', 'i:imports', 'c:constants', 'v:variables', 't:types', 'n:interfaces', 'w:fields', 'e:embedded', 'm:methods', 'r:constructor', 'f:functions' ], 'sro' : '.', 'kind2scope' : { 't' : 'ctype', 'n' : 'ntype' }, 'scope2kind' : { 'ctype' : 't', 'ntype' : 'n' }, 'ctagsbin'  : bin_path, 'ctagsargs' : '-sort -silent' }
    1                 0.000000000   endif

FUNCTION  308()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:394
Called 9 times
Total time:   0.000118000
 Self time:   0.000118000

count     total (s)      self (s)
    9                 0.000032000     let l:msg = { 'method': a:data.method, 'jsonrpc': '2.0', }
                                  
    9                 0.000006000     if !a:data.notification
                                        let self.last_request_id += 1
                                        let l:msg.id = self.last_request_id
    9                 0.000002000     endif
                                  
    9                 0.000011000     if has_key(a:data, 'params')
    9                 0.000012000       let l:msg.params = a:data.params
    9                 0.000004000     endif
                                  
    9                 0.000006000     return l:msg

FUNCTION  <SNR>37_handleLeftClick()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:352
Called 1 time
Total time:   0.001351000
 Self time:   0.000055000

count     total (s)      self (s)
    1   0.001302000   0.000006000     let currentNode = g:NERDTreeFileNode.GetSelected()
    1                 0.000001000     if currentNode !=# {}
                                  
                                          "the dir arrows are multibyte chars, and vim's string functions only
                                          "deal with single bytes - so split the line up with the hack below and
                                          "take the line substring manually
    1                 0.000007000         let line = split(getline(line('.')), '\zs')
    1                 0.000000000         let startToCur = ''
   14                 0.000006000         for i in range(0,len(line)-1)
   13                 0.000012000             let startToCur .= line[i]
   14                 0.000004000         endfor
                                  
    1                 0.000001000         if currentNode.path.isDirectory
                                              if startToCur =~# g:NERDTreeUI.MarkupReg() && startToCur =~# '[+~'.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \?$'
                                                  call currentNode.activate()
                                                  return
                                              endif
    1                 0.000000000         endif
                                  
    1                 0.000002000         if (g:NERDTreeMouseMode ==# 2 && currentNode.path.isDirectory) || g:NERDTreeMouseMode ==# 3
                                              let char = strpart(startToCur, strlen(startToCur)-1, 1)
                                              if char !~# g:NERDTreeUI.MarkupReg()
                                                  if currentNode.path.isDirectory
                                                      call currentNode.activate()
                                                  else
                                                      call currentNode.activate({'reuse': 'all', 'where': 'p', 'keepopen':!nerdtree#closeTreeOnOpen()})
                                                  endif
                                                  return
                                              endif
    1                 0.000000000         endif
    1                 0.000000000     endif

FUNCTION  <SNR>144_Init()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:209
Called 75 times
Total time:   0.000462000
 Self time:   0.000462000

count     total (s)      self (s)
   75                 0.000258000     if s:checked_ctags == 2 && a:silent
   75                 0.000081000         return 0
                                      elseif s:checked_ctags != 1
                                          if !s:CheckForExCtags(a:silent)
                                              return 0
                                          endif
                                      endif
                                  
                                      if !s:type_init_done
                                          call s:InitTypes()
                                      endif
                                  
                                      if !s:autocommands_done
                                          call s:CreateAutocommands()
                                          call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                      endif
                                  
                                      let s:init_done = 1
                                      return 1

FUNCTION  FugitiveActualDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:273
Called 272 times
Total time:   0.023129000
 Self time:   0.006570000

count     total (s)      self (s)
  272   0.018232000   0.001673000   let dir = call('FugitiveGitDir', a:000)
  272                 0.000539000   if empty(dir)
                                      return ''
  272                 0.000165000   endif
  272                 0.001033000   if !has_key(s:resolved_git_dirs, dir)
                                      let s:resolved_git_dirs[dir] = s:ResolveGitDir(dir)
  272                 0.000151000   endif
  272                 0.001455000   return empty(s:resolved_git_dirs[dir]) ? dir : s:resolved_git_dirs[dir]

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:114
Called 21 times
Total time:   0.000770000
 Self time:   0.000255000

count     total (s)      self (s)
   21   0.000745000   0.000230000   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:39
Called 454 times
Total time:   0.011810000
 Self time:   0.008942000

count     total (s)      self (s)
  454                 0.001270000   if exists('s:current_buffer_list')
  429                 0.000541000     return s:current_buffer_list
   25                 0.000010000   endif
                                  
   25                 0.000081000   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
   25                 0.000080000   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
   25                 0.000069000   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                                  
   25                 0.000155000   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                                  
   25                 0.000027000   let buffers = []
                                    " If this is too slow, we can switch to a different algorithm.
                                    " Basically branch 535 already does it, but since it relies on
                                    " BufAdd autocommand, I'd like to avoid this if possible.
  277                 0.000261000   for nr in list
  252                 0.000412000     if buflisted(nr)
                                        " Do not add to the bufferlist, if either
                                        " 1) bufnr is exclude_buffers list
                                        " 2) buffername matches one of exclude_paths patterns
                                        " 3) buffer is a quickfix buffer
                                        " 4) when excluding preview windows:
                                        "     'bufhidden' == wipe
                                        "     'buftype' == nofile
                                        " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  
                                        " check buffer numbers first
   78                 0.000162000       if index(exclude_buffers, nr) >= 0
                                          continue
                                        " check paths second
   78                 0.000236000       elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                          continue
                                        " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
   78   0.002411000   0.000337000       elseif airline#util#ignore_buf(bufname(nr))
                                          continue
                                        " check other types last
   78   0.001100000   0.000306000       elseif s:ExcludeOther(nr, exclude_preview)
                                          continue
   78                 0.000042000       endif
                                  
   78                 0.000181000       call add(buffers, nr)
  252                 0.000129000     endif
  277                 0.000177000   endfor
                                  
   25                 0.000067000   let s:current_buffer_list = buffers
   25                 0.000030000   return buffers

FUNCTION  go#fmt#Format()
    Defined: ~/.vim/plugged/vim-go/autoload/go/fmt.vim:20
Called 9 times
Total time:  48.700323000
 Self time:   0.044142000

count     total (s)      self (s)
    9   0.000203000   0.000078000   let l:bin_name = go#config#FmtCommand()
    9                 0.000020000   if a:withGoimport == 1
                                      let l:mode = go#config#ImportsMode()
                                      if l:mode == 'gopls'
                                        if !go#config#GoplsEnabled()
                                          call go#util#EchoError("go_imports_mode is 'gopls', but gopls is disabled")
                                          return
                                        endif
                                        call go#lsp#Imports()
                                        return
                                      endif
                                  
                                      let l:bin_name = 'goimports'
    9                 0.000008000   endif
                                  
    9                 0.000018000   if l:bin_name == 'gopls'
                                      if !go#config#GoplsEnabled()
                                        call go#util#EchoError("go_fmt_command is 'gopls', but gopls is disabled")
                                        return
                                      endif
                                      call go#lsp#Format()
                                      return
    9                 0.000006000   endif
                                  
    9   0.000127000   0.000078000   if go#config#FmtExperimental()
                                      " Using winsaveview to save/restore cursor state has the problem of
                                      " closing folds on save:
                                      "   https://github.com/fatih/vim-go/issues/502
                                      " One fix is to use mkview instead. Unfortunately, this sometimes causes
                                      " other bad side effects:
                                      "   https://github.com/fatih/vim-go/issues/728
                                      " and still closes all folds if foldlevel>0:
                                      "   https://github.com/fatih/vim-go/issues/732
                                      let l:curw = {}
                                      try
                                        mkview!
                                      catch
                                        let l:curw = winsaveview()
                                      endtry
                                  
                                      " save our undo file to be restored after we are done. This is needed to
                                      " prevent an additional undo jump due to BufWritePre auto command and also
                                      " restore 'redo' history because it's getting being destroyed every
                                      " BufWritePre
                                      let tmpundofile = tempname()
                                      exe 'wundo! ' . tmpundofile
    9                 0.000009000   else
                                      " Save cursor position and many other things.
    9                 0.000062000     let l:curw = winsaveview()
    9                 0.000009000   endif
                                  
                                    " Write current unsaved buffer to a temp file
    9                 0.000284000   let l:tmpname = tempname() . '.go'
    9   0.040750000   0.040236000   call writefile(go#util#GetLines(), l:tmpname)
    9   0.000681000   0.000350000   if go#util#IsWin()
                                      let l:tmpname = tr(l:tmpname, '\', '/')
    9                 0.000021000   endif
                                  
    9                 0.000077000   let current_col = col('.')
    9  48.519927000   0.000273000   let [l:out, l:err] = go#fmt#run(l:bin_name, l:tmpname, expand('%'))
    9                 0.000818000   let line_offset = len(readfile(l:tmpname)) - line('$')
    9                 0.000055000   let l:orig_line = getline('.')
                                  
    9                 0.000024000   if l:err == 0
    8   0.135561000   0.000092000     call go#fmt#update_file(l:tmpname, expand('%'))
    1   0.000053000   0.000044000   elseif !go#config#FmtFailSilently()
                                      let l:errors = s:replace_filename(expand('%'), out)
                                      call go#fmt#ShowErrors(l:errors)
    9                 0.000005000   endif
                                  
                                    " We didn't use the temp file, so clean up
    9                 0.000269000   call delete(l:tmpname)
                                  
    9   0.000053000   0.000023000   if go#config#FmtExperimental()
                                      " restore our undo history
                                      silent! exe 'rundo ' . tmpundofile
                                      call delete(tmpundofile)
                                  
                                      " Restore our cursor/windows positions, folds, etc.
                                      if empty(l:curw)
                                        silent! loadview
                                      else
                                        call winrestview(l:curw)
                                      endif
    9                 0.000003000   else
                                      " Restore our cursor/windows positions.
    9                 0.000182000     call winrestview(l:curw)
    9                 0.000004000   endif
                                  
                                    " be smart and jump to the line the new statement was added/removed and
                                    " adjust the column within the line
    9                 0.000026000   let l:lineno = line('.') + line_offset
    9                 0.000052000   call cursor(l:lineno, current_col + (len(getline(l:lineno)) - len(l:orig_line)))
                                  
                                    " Syntax highlighting breaks less often.
    9                 0.000030000   syntax sync fromstart

FUNCTION  14()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:282
Called 719 times
Total time:   0.015174000
 Self time:   0.011547000

count     total (s)      self (s)
  719   0.005291000   0.001664000     if nerdtree#runningWindows()
                                          if a:fullpath =~# '^\(\\\\\|\/\/\)'
                                              "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                              let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                              let self.drive = substitute(self.drive, '/', '\', 'g')
                                          else
                                              let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                          endif
  719                 0.000387000     else
  719                 0.001210000         let self.drive = ''
  719                 0.000410000     endif
                                  

FUNCTION  <SNR>37_toggleShowHidden()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:702
Called 6 times
Total time:   0.179689000
 Self time:   0.000055000

count     total (s)      self (s)
    6   0.179680000   0.000046000     call b:NERDTree.ui.toggleShowHidden()

FUNCTION  18()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:333
Called 21 times
Total time:   0.002768000
 Self time:   0.000188000

count     total (s)      self (s)
   21   0.000112000   0.000048000     if nerdtree#runningWindows()
                                          let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
   21                 0.000009000     else
   21                 0.000054000         let path = '/'. join(self.pathSegments[0:-2], '/')
   21                 0.000004000     endif
                                  
   21   0.002545000   0.000029000     return s:Path.New(path)

FUNCTION  19()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:350
Called 22182 times
Total time:   0.176952000
 Self time:   0.176952000

count     total (s)      self (s)
22182                 0.035617000     if empty(self.pathSegments)
                                          return ''
22182                 0.009128000     endif
22182                 0.034778000     let toReturn = self.pathSegments[-1]
22182                 0.023289000     if a:dirSlash && self.isDirectory
  455                 0.000438000         let toReturn = toReturn . '/'
22182                 0.009164000     endif
22182                 0.017528000     return toReturn

FUNCTION  380()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 9 times
Total time:   0.000386000
 Self time:   0.000165000

count     total (s)      self (s)
    9                 0.000027000     let bufnum = get(self.buffers, a:i, -1)
    9                 0.000010000     if bufnum == -1
                                        return ''
    9                 0.000007000     endif
    9   0.000268000   0.000047000     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    9                 0.000018000     if bufnum == bufnr('%')
    3                 0.000010000       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    9                 0.000006000     endif
    9                 0.000009000     return group

FUNCTION  <SNR>41_TabEnterHandler()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:537
Called 2 times
Total time:   0.000282000
 Self time:   0.000095000

count     total (s)      self (s)
    2                 0.000006000   if s:disable_handlers_for_tabdo
                                      return
    2                 0.000001000   endif
                                  
    2                 0.000011000   if g:nerdtree_tabs_open_on_new_tab && s:nerdtree_globally_active && !s:IsNERDTreeOpenInCurrentTab()
                                      call s:NERDTreeMirrorOrCreate()
                                  
                                      " move focus to the previous window
                                      wincmd p
                                  
                                      " Turn on the 'NewTabCreated' flag
                                      let s:NewTabCreated = 1
    2                 0.000002000   endif
                                  
    2                 0.000005000   if g:nerdtree_tabs_synchronize_view
    2   0.000147000   0.000015000     call s:RestoreNERDTreeViewIfPossible()
    2                 0.000001000   endif
                                  
    2                 0.000005000   if g:nerdtree_tabs_focus_on_files
    2   0.000065000   0.000010000     call s:NERDTreeUnfocus()
                                    " Do not restore focus on newly created tab here
                                    elseif !s:NewTabCreated
                                      call s:NERDTreeRestoreFocus()
    2                 0.000002000   endif

FUNCTION  airline#builder#get_next_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:49
Called 26 times
Total time:   0.000529000
 Self time:   0.000529000

count     total (s)      self (s)
   26                 0.000040000   let x = a:i + 1
   26                 0.000051000   let l = len(a:sections)
   52                 0.000062000   while x < l
   52                 0.000133000     let group = a:sections[x][0]
   52                 0.000086000     if group != '' && group != '|'
   26                 0.000025000       return group
   26                 0.000016000     endif
   26                 0.000028000     let x = x + 1
   26                 0.000016000   endwhile
                                    return ''

FUNCTION  go#uri#Decode()
    Defined: ~/.vim/plugged/vim-go/autoload/go/uri.vim:26
Called 6 times
Total time:   0.000145000
 Self time:   0.000145000

count     total (s)      self (s)
    6                 0.000134000     return substitute(   a:value,   '%\(\x\x\)',   '\=s:decodehex(submatch(1))',   'g')

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:29
Called 438 times
Total time:   0.035785000
 Self time:   0.032048000

count     total (s)      self (s)
                                      " The checks are split into separate if statements to make it possible to
                                      " profile each check individually with Vim's profiling tools.
                                      "
                                      " Do nothing if ALE is disabled.
  438                 0.004039000     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                          return 1
  438                 0.000341000     endif
                                  
                                      " Don't perform any checks when newer NeoVim versions are exiting.
  438                 0.002601000     if get(v:, 'exiting', v:null) isnot v:null
                                          return 1
  438                 0.000294000     endif
                                  
  438                 0.002938000     let l:filetype = getbufvar(a:buffer, '&filetype')
                                  
                                      " Do nothing when there's no filetype.
  438                 0.001034000     if l:filetype is# ''
   10                 0.000006000         return 1
  428                 0.000315000     endif
                                  
                                      " Do nothing for diff buffers.
  428                 0.001847000     if getbufvar(a:buffer, '&diff')
                                          return 1
  428                 0.000282000     endif
                                  
                                      " Do nothing for blacklisted files.
  428                 0.003598000     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
  248                 0.000336000         return 1
  180                 0.000128000     endif
                                  
                                      " Do nothing if running from command mode.
  180                 0.001050000     if s:getcmdwintype_exists && !empty(getcmdwintype())
  100                 0.000171000         return 1
   80                 0.000065000     endif
                                  
   80                 0.000487000     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                                  
                                      " Do nothing for directories.
   80                 0.000139000     if l:filename is# '.'
                                          return 1
   80                 0.000047000     endif
                                  
                                      " Don't start linting and so on when an operator is pending.
   80   0.001162000   0.000600000     if ale#util#Mode(1) is# 'no'
                                          return 1
   80                 0.000059000     endif
                                  
                                      " Do nothing if running in the sandbox.
   80   0.002387000   0.000348000     if ale#util#InSandbox()
                                          return 1
   80                 0.000048000     endif
                                  
                                      " Do nothing if the file is too large.
   80   0.001512000   0.000376000     if ale#FileTooLarge(a:buffer)
                                          return 1
   80                 0.000051000     endif
                                  
                                      " Do nothing from CtrlP buffers with CtrlP-funky.
   80                 0.001461000     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                          return 1
   80                 0.000052000     endif
                                  
   80                 0.000081000     return 0

FUNCTION  310()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:422
Called 9 times
Total time:   0.000563000
 Self time:   0.000386000

count     total (s)      self (s)
    9                 0.000024000     if empty(get(self, 'job', {}))
                                        return
    9                 0.000004000     endif
                                  
    9                 0.000087000     let l:body = json_encode(a:msg)
    9                 0.000034000     let l:data = 'Content-Length: ' . strlen(l:body) . "\r\n\r\n" . l:body
                                  
    9   0.000216000   0.000039000     call s:debug('sent', l:data)
                                  
    9                 0.000021000     if has('nvim')
                                        call chansend(self.job, l:data)
                                        return
    9                 0.000001000     endif
                                  
    9                 0.000007000     try
    9                 0.000103000       call ch_sendraw(self.job, l:data)
                                      catch
                                        call go#util#EchoError(printf('could not send message: %s', v:exception))
    9                 0.000007000     endtry

FUNCTION  airline#extensions#ale#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:116
Called 55 times
Total time:   0.005755000
 Self time:   0.000264000

count     total (s)      self (s)
   55   0.005725000   0.000234000   return airline#extensions#ale#get('error')

FUNCTION  xolox#misc#cursorhold#autocmd()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/cursorhold.vim:48
Called 1 time
Total time:   0.000501000
 Self time:   0.000351000

count     total (s)      self (s)
                                    " The 'top level event handler' that's called by Vim whenever the
                                    " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                                    " event handlers registered using `xolox#misc#cursorhold#register()` and
                                    " calls each event handler at the appropriate interval, keeping track of
                                    " the time when each event handler was last run.
    2                 0.000039000   for handler in g:xolox#misc#cursorhold#handlers
    1                 0.000007000     let function = handler['function']
    1                 0.000009000     let last_run = get(handler, 'last_run', 0)
    1                 0.000007000     let interval = get(handler, 'interval', 4)
    1   0.000090000   0.000053000     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                      " Rate limit in case &updatetime is set (very) low.
    1                 0.000012000     let time_until_next_run = (last_run + interval) - localtime()
    1                 0.000004000     if time_until_next_run > 0
                                        call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
    1                 0.000002000     else
    1   0.000051000   0.000026000       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
    1   0.000139000   0.000051000       call call(function, get(handler, 'arguments', []))
    1                 0.000034000       let handler['last_run'] = localtime()
    1                 0.000002000     endif
    2                 0.000007000   endfor

FUNCTION  <SNR>192_buflisted()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:317
Called 1 time
Total time:   0.000053000
 Self time:   0.000053000

count     total (s)      self (s)
    1                 0.000053000   return filter(range(1, bufnr('$')), 'buflisted(v:val) && getbufvar(v:val, "&filetype") != "qf"')

FUNCTION  go#config#CodeCompletionEnabled()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:490
Called 8 times
Total time:   0.000040000
 Self time:   0.000040000

count     total (s)      self (s)
    8                 0.000034000   return get(g:, "go_code_completion_enabled", 1)

FUNCTION  go#fmt#update_file()
    Defined: ~/.vim/plugged/vim-go/autoload/go/fmt.vim:120
Called 8 times
Total time:   0.135469000
 Self time:   0.012298000

count     total (s)      self (s)
                                    " remove undo point caused via BufWritePre
    8                 0.000130000   try | silent undojoin | catch | endtry
                                  
    8                 0.000020000   let old_fileformat = &fileformat
    8                 0.000018000   if exists("*getfperm")
                                      " save file permissions
    8                 0.000071000     let original_fperm = getfperm(a:target)
    8                 0.000005000   endif
                                  
    8                 0.002603000   call rename(a:source, a:target)
                                  
                                    " restore file permissions
    8                 0.000038000   if exists("*setfperm") && original_fperm != ''
    8                 0.000206000     call setfperm(a:target , original_fperm)
    8                 0.000005000   endif
                                  
                                    " reload buffer to reflect latest changes
    8   0.109533000   0.008567000   silent edit!
                                  
    8   0.003172000   0.000420000   call go#lsp#DidChange(expand(a:target, ':p'))
                                  
    8                 0.000111000   let &fileformat = old_fileformat
    8   0.019031000   0.000028000   let &syntax = &syntax
                                  
    8   0.000472000   0.000022000   call go#fmt#CleanErrors()

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/po.vim:64
Called 72 times
Total time:   0.000580000
 Self time:   0.000580000

count     total (s)      self (s)
   72                 0.000097000   if &ft ==# 'po'
                                      call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                      " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                      autocmd airline BufWritePost * call s:autocmd_handler()
                                      autocmd airline WinEnter * call airline#extensions#po#on_winenter()
   72                 0.000046000   endif

FUNCTION  20()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:363
Called 449 times
Total time:   0.052973000
 Self time:   0.033143000

count     total (s)      self (s)
  449                 0.000486000     let i = 0
 2349                 0.004296000     while i < len(g:NERDTreeSortOrder)
 2068   0.038421000   0.018591000         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
  168                 0.000099000             return i
 1900                 0.001097000         endif
 1900                 0.002261000         let i = i + 1
 2181                 0.001380000     endwhile
                                  
  281                 0.000768000     return index(g:NERDTreeSortOrder, '*')

FUNCTION  24()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:451
Called 835 times
Total time:   0.007715000
 Self time:   0.002362000

count     total (s)      self (s)
  835   0.007557000   0.002204000     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  26()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:472
Called 2520 times
Total time:   0.687904000
 Self time:   0.136818000

count     total (s)      self (s)
                                      "filter out the user specified paths to ignore
 2520   0.007291000   0.004313000     if a:nerdtree.ui.isIgnoreFilterEnabled()
20160                 0.013973000         for i in g:NERDTreeIgnore
17640   0.557982000   0.034276000             if self._ignorePatternMatches(i)
                                                  return 1
17640                 0.007672000             endif
20160                 0.009237000         endfor
                                  
 2520   0.016916000   0.005265000         for l:Callback in g:NERDTree.PathFilters()
                                              let l:Callback = type(l:Callback) ==# type(function('tr')) ? l:Callback : function(l:Callback)
                                              if l:Callback({'path': self, 'nerdtree': a:nerdtree})
                                                 return 1
                                              endif
 2520                 0.001542000         endfor
 2520                 0.001009000     endif
                                  
                                      "dont show hidden files unless instructed to
 2520   0.017027000   0.006610000     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
  315                 0.000168000         return 1
 2205                 0.000944000     endif
                                  
 2205   0.007414000   0.005080000     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                          return 1
 2205                 0.000931000     endif
                                  
 2205                 0.001510000     return 0

FUNCTION  27()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:503
Called 17640 times
Total time:   0.523706000
 Self time:   0.388309000

count     total (s)      self (s)
17640                 0.018506000     let pat = a:pattern
17640                 0.043605000     if strpart(pat,len(pat)-8) ==# '[[path]]'
                                          let pat = strpart(pat,0, len(pat)-8)
                                          return self.str() =~# pat
17640                 0.038910000     elseif strpart(pat,len(pat)-7) ==# '[[dir]]'
                                          if !self.isDirectory
                                              return 0
                                          endif
                                          let pat = strpart(pat,0, len(pat)-7)
17640                 0.041372000     elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                          if self.isDirectory
                                              return 0
                                          endif
                                          let pat = strpart(pat,0, len(pat)-8)
17640                 0.007065000     endif
                                  
17640   0.191313000   0.055916000     return self.getLastPathComponent(0) =~# pat

FUNCTION  29()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:533
Called 9 times
Total time:   0.000515000
 Self time:   0.000286000

count     total (s)      self (s)
    9                 0.000011000     if a:parent.isDirectory ==# 0
                                          return 0
    9                 0.000004000     endif
    9   0.000058000   0.000018000     if nerdtree#runningWindows() && a:parent.drive !=# self.drive
                                          return 0
    9                 0.000002000     endif
    9                 0.000017000     let l:this_count = len(self.pathSegments)
    9                 0.000006000     if l:this_count ==# 0
                                          return 0
    9                 0.000006000     endif
    9                 0.000014000     let l:that_count = len(a:parent.pathSegments)
    9                 0.000008000     if l:that_count ==# 0
                                          return 1
    9                 0.000005000     endif
    9                 0.000008000     if l:that_count >= l:this_count
    1                 0.000001000         return 0
    8                 0.000002000     endif
   30                 0.000027000     for i in range(0, l:that_count-1)
   22   0.000252000   0.000063000         if !nerdtree#pathEquals(self.pathSegments[i], a:parent.pathSegments[i])
                                              return 0
   22                 0.000008000         endif
   30                 0.000011000     endfor
    8                 0.000003000     return 1

FUNCTION  ale#Var()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:194
Called 471 times
Total time:   0.012096000
 Self time:   0.012096000

count     total (s)      self (s)
  471                 0.002226000     let l:full_name = 'ale_' . a:variable_name
  471                 0.006283000     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                                  
  471                 0.002636000     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>62_writefile()
    Defined: ~/.fzf/plugin/fzf.vim:460
Called 1 time
Total time:   0.004340000
 Self time:   0.004340000

count     total (s)      self (s)
    1                 0.004329000   if call('writefile', a:000) == -1
                                      throw 'Failed to write temporary file. Check if you can write to the path tempname() returns.'
    1                 0.000002000   endif

FUNCTION  <SNR>104_check_mixed_indent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:17
Called 15 times
Total time:   0.002065000
 Self time:   0.002065000

count     total (s)      self (s)
   15                 0.000042000   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
   15                 0.000015000   if indent_algo == 1
                                      " [<tab>]<space><tab>
                                      " spaces before or between tabs are not allowed
                                      let t_s_t = '(^\t* +\t\s*\S)'
                                      " <tab>(<space> x count)
                                      " count of spaces at the end of tabs should be less than tabstop value
                                      let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                      return search('\v' . t_s_t . '|' . t_l_s, 'nw')
   15                 0.000012000   elseif indent_algo == 2
                                      return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
   15                 0.000008000   else
   15                 0.001866000     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                                    endif

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:207
Called 13 times
Total time:   0.003465000
 Self time:   0.000313000

count     total (s)      self (s)
   13   0.001852000   0.000195000   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
   13   0.001591000   0.000096000   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>62_border_opt()
    Defined: ~/.fzf/plugin/fzf.vim:773
Called 2 times
Total time:   0.000410000
 Self time:   0.000140000

count     total (s)      self (s)
    2                 0.000015000   if type(a:window) != type({})
                                      return ''
    2                 0.000002000   endif
                                  
                                    " Border style
    2                 0.000017000   let style = tolower(get(a:window, 'border', ''))
    2                 0.000012000   if !has_key(a:window, 'border') && has_key(a:window, 'rounded')
                                      let style = a:window.rounded ? 'rounded' : 'sharp'
    2                 0.000003000   endif
    2                 0.000010000   if style == 'none' || style == 'no'
                                      return ''
    2                 0.000001000   endif
                                  
                                    " For --border styles, we need fzf 0.24.0 or above
    2   0.000283000   0.000013000   call fzf#exec('0.24.0')
    2                 0.000008000   let opt = ' --border ' . style
    2                 0.000008000   if has_key(a:window, 'highlight')
                                      let color = s:get_color('fg', a:window.highlight)
                                      if len(color)
                                        let opt .= ' --color=border:' . color
                                      endif
    2                 0.000002000   endif
    2                 0.000004000   return opt

FUNCTION  111()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:88
Called 804 times
Total time:   0.014842000
 Self time:   0.002857000

count     total (s)      self (s)
  804   0.014674000   0.002689000     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  112()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:102
Called 874 times
Total time:   0.091649000
 Self time:   0.003250000

count     total (s)      self (s)
  874   0.091429000   0.003030000     return self.path.str() ==# a:treenode.path.str()

FUNCTION  113()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:112
Called 55 times
Total time:   0.007488000
 Self time:   0.000232000

count     total (s)      self (s)
   55   0.007376000   0.000120000     if a:path.equals(self.path)
    8                 0.000009000         return self
   47                 0.000020000     endif
   47                 0.000028000     return {}

FUNCTION  115()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:157
Called 4147 times
Total time:   0.004318000
 Self time:   0.004318000

count     total (s)      self (s)
 4147                 0.003397000     return self._nerdtree

FUNCTION  118()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:191
Called 6 times
Total time:   0.003651000
 Self time:   0.000068000

count     total (s)      self (s)
    6   0.003645000   0.000062000     return !self.path.ignore(self.getNerdtree())

FUNCTION  119()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:196
Called 874 times
Total time:   0.099401000
 Self time:   0.005421000

count     total (s)      self (s)
  874   0.002951000   0.001401000     if !g:NERDTree.ExistsForBuf()
                                          throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
  874                 0.000267000     endif
                                  
  874   0.095132000   0.002702000     return self.equals(self.getNerdtree().root)

FUNCTION  gitgutter#sign#clear_signs()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:38
Called 2 times
Total time:   0.000045000
 Self time:   0.000045000

count     total (s)      self (s)
    2                 0.000012000   if exists('*sign_unplace')
    2                 0.000023000     call sign_unplace('gitgutter', {'buffer': a:bufnr})
    2                 0.000002000     return
                                    endif
                                  
                                  
                                    call s:find_current_signs(a:bufnr)
                                  
                                    let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
                                    call s:remove_signs(a:bufnr, sign_ids, 1)
                                    call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})

FUNCTION  nerdtree#compareNodes()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:102
Called 1745 times
Total time:   0.191235000
 Self time:   0.004530000

count     total (s)      self (s)
 1745   0.190918000   0.004213000     return nerdtree#compareNodePaths(a:n1.path, a:n2.path)

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:19
Called 3284 times
Total time:   0.035990000
 Self time:   0.035990000

count     total (s)      self (s)
 3284                 0.008862000   let nr = get(a:000, 0, 0)
                                    " When statusline is on top, or using global statusline for Neovim
                                    " always return the number of columns
 3284                 0.009675000   if get(g:, 'airline_statusline_ontop', 0) || &laststatus > 2
                                      return &columns
 3284                 0.002137000   else
 3284                 0.006334000     return winwidth(nr)
                                    endif

FUNCTION  373()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 3 times
Total time:   0.000373000
 Self time:   0.000119000

count     total (s)      self (s)
    3                 0.000009000     let bufnum = get(self.buffers, a:i, -1)
    3   0.000141000   0.000012000     let group = self.get_group(a:i)
    3   0.000135000   0.000010000     let pgroup = self.get_group(a:i - 1)
                                      " always add a space when powerline_fonts are used
                                      " or for the very first item
    3                 0.000011000     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1                 0.000002000       let space = s:spc
    2                 0.000002000     else
    2                 0.000006000       let space= (pgroup == group ? s:spc : '')
    3                 0.000002000     endif
                                  
    3                 0.000008000     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                        if len(s:number_map) > 0
                                          return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                        else
                                          return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                        endif
    3                 0.000003000     else
    3                 0.000016000       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                      endif

FUNCTION  <SNR>118_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 745 times
Total time:   0.055981000
 Self time:   0.018955000

count     total (s)      self (s)
  745                 0.003214000     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                      " i have no idea why the warning section needs special treatment, but it's
                                      " needed to prevent separators from showing up
  745   0.008505000   0.003707000     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    8                 0.000006000       return
  737                 0.000583000     endif
  737                 0.000707000     if condition
                                        call a:builder.add_raw('%(')
  737                 0.000369000     endif
  737   0.036980000   0.004752000     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  737                 0.000752000     if condition
                                        call a:builder.add_raw('%)')
  737                 0.000392000     endif

FUNCTION  161()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:571
Called 20 times
Total time:   0.674131000
 Self time:   0.014433000

count     total (s)      self (s)
   20   0.016188000   0.000219000     call self.path.refresh(self.getNerdtree())
                                  
                                      "if this node was ever opened, refresh its children
   20                 0.000078000     if self.isOpen || !empty(self.children)
   20   0.026473000   0.000403000         let files = self._glob('*', 1) + self._glob('.*', 0)
   20                 0.000042000         let newChildNodes = []
   20                 0.000040000         let invalidFilesFound = 0
   20                 0.000078000         let invalidFiles = []
  220                 0.000338000         for i in files
  200                 0.000167000             try
                                                  "create a new path and see if it exists in this nodes children
  200   0.099273000   0.003406000                 let path = g:NERDTreePath.New(i)
  200   0.289461000   0.001001000                 let newNode = self.getChild(path)
  200   0.041454000   0.001796000                 if newNode !=# {} && path.str() ==# newNode.path.str()
  200   0.123233000   0.000999000                     call newNode.refresh()
  200                 0.000688000                     call add(newChildNodes, newNode)
                                  
                                                  "the node doesnt exist so create it
                                                  else
                                                      let newNode = g:NERDTreeFileNode.New(path, self.getNerdtree())
                                                      let newNode.parent = self
                                                      call add(newChildNodes, newNode)
  200                 0.000155000                 endif
                                              catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                                  let invalidFilesFound += 1
                                                  let invalidFiles += [i]
  200                 0.000228000             endtry
  220                 0.000204000         endfor
                                  
                                          "swap this nodes children out for the children we just read/refreshed
   20                 0.000057000         let self.children = newChildNodes
   20   0.071558000   0.000118000         call self.sortChildren()
                                  
   20                 0.000032000         if invalidFilesFound
                                              call nerdtree#echoWarning(invalidFilesFound . ' Invalid file(s): ' . join(invalidFiles, ', '))
   20                 0.000019000         endif
   20                 0.000011000     endif

FUNCTION  <SNR>90_SetConcealOption()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:101
Called 18 times
Total time:   0.000464000
 Self time:   0.000464000

count     total (s)      self (s)
   18                 0.000048000     if !g:indentLine_setConceal
                                          return
   18                 0.000011000     endif
   18                 0.000075000     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
   10                 0.000015000         let b:indentLine_ConcealOptionSet = 1
   10                 0.000022000         let b:indentLine_original_concealcursor = &l:concealcursor
   10                 0.000018000         let b:indentLine_original_conceallevel = &l:conceallevel
   10                 0.000049000         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
   10                 0.000058000         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
   18                 0.000013000     endif

FUNCTION  go#config#FmtCommand()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:339
Called 18 times
Total time:   0.000193000
 Self time:   0.000133000

count     total (s)      self (s)
   18   0.000177000   0.000117000   return get(g:, "go_fmt_command", go#config#GoplsEnabled() ? 'gopls' : 'gofmt')

FUNCTION  305()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:250
Called 6 times
Total time:   0.009358000
 Self time:   0.005101000

count     total (s)      self (s)
    6   0.000221000   0.000094000     let l:level = go#config#DiagnosticsLevel()
                                  
   12                 0.000029000     for l:data in self.diagnosticsQueue
    6                 0.000036000       call remove(self.diagnosticsQueue, 0)
                                  
    6                 0.000005000       try
    6                 0.000016000         let l:diagnostics = []
    6                 0.000015000         let l:errorMatches = []
    6                 0.000014000         let l:warningMatches = []
    6   0.000635000   0.000106000         let l:fname = go#path#FromURI(l:data.uri)
                                  
                                          " get the buffer name relative to the current directory, because
                                          " Vim says that a buffer name can't be an absolute path.
    6                 0.001387000         let l:bufname = fnamemodify(l:fname, ':.')
                                  
    6                 0.000174000         if len(l:data.diagnostics) > 0 && (l:level > 0 || bufnr(l:bufname) == bufnr(''))
                                            " make sure the buffer is listed and loaded before calling getbufline() on it
    6                 0.000810000           if !bufexists(l:bufname)
                                              call bufadd(l:bufname)
    6                 0.000007000           endif
                                  
    6                 0.000572000           if !bufloaded(l:bufname)
                                              call bufload(l:bufname)
    6                 0.000008000           endif
                                  
   12                 0.000034000           for l:diag in l:data.diagnostics
    6                 0.000019000             if l:level < l:diag.severity
    6                 0.000014000               continue
                                              endif
                                              let [l:diagnostic, l:matchpos] = s:processDiagnostic(l:diag, l:bufname, l:fname)
                                              let l:diagnostics = add(l:diagnostics, l:diagnostic)
                                  
                                              if empty(l:matchpos)
                                                continue
                                              endif
                                  
                                              if l:diag.severity == 1
                                                let l:errorMatches = add(l:errorMatches, l:matchpos)
                                              elseif l:diag.severity == 2
                                                let l:warningMatches = add(l:warningMatches, l:matchpos)
                                              endif
    6                 0.000013000           endfor
    6                 0.000008000         endif
                                  
    6                 0.000074000         if bufnr(l:bufname) == bufnr('')
                                            " only apply highlighting when the diagnostics are for the current
                                            " version.
    6   0.000251000   0.000074000           let l:lsp = s:lspfactory.get()
    6                 0.000039000           let l:version = get(l:lsp.fileVersions, l:fname, 0)
                                            " it's tempting to only highlight matches when they are for the
                                            " current version of the buffer, but that causes problems when the
                                            " version number has been updated and the content has not. In such a
                                            " case, the diagnostics may not be sent for later versions.
    6   0.003530000   0.000106000           call s:highlightMatches(l:errorMatches, l:warningMatches)
    6                 0.000007000         endif
                                  
    6                 0.000051000         let self.diagnostics[l:fname] = l:diagnostics
    6                 0.000073000         if has_key(self.notificationQueue, l:fname) && len(self.notificationQueue[l:fname]) > 0
                                            call call(self.notificationQueue[l:fname][0], copy(l:diagnostics))
                                            call remove(self.notificationQueue[l:fname], 0)
    6                 0.000007000         endif
                                        catch
                                          "call go#util#EchoError(printf('%s: %s', v:throwpoint, v:exception))
    6                 0.000011000       endtry
   12                 0.000034000     endfor

FUNCTION  <SNR>113_create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:17
Called 31 times
Total time:   0.006668000
 Self time:   0.005809000

count     total (s)      self (s)
   31                 0.000107000   let _ = ''
   62                 0.000236000   for idx in range(len(a:parts))
   31   0.000575000   0.000345000     let part = airline#parts#get(a:parts[idx])
   31                 0.000042000     let val = ''
   31                 0.000090000     let add_sep = get(l:, 'add_sep', 0)
                                  
   31                 0.000100000     if exists('part.function')
   31                 0.000068000       let func = (part.function).'()'
                                      elseif exists('part.text')
                                        let func = '"'.(part.text).'"'
                                      else
                                        if a:append > 0 && idx != 0
                                          let val .= s:spc.g:airline_left_alt_sep.s:spc
                                        endif
                                        if a:append < 0 && idx != 0
                                          let t = ''
                                          if !add_sep
                                            let t = s:spc.g:airline_right_alt_sep.s:spc
                                          endif
                                          let val = t.val
                                        endif
                                        if exists('part.raw')
                                          let _ .= s:wrap_accent(part, val.(part.raw))
                                          continue
                                        else
                                          let _ .= s:wrap_accent(part, val.a:parts[idx])
                                          continue
                                        endif
   31                 0.000019000     endif
                                  
   31                 0.000092000     let minwidth = get(part, 'minwidth', 0)
                                  
   31                 0.000061000     if a:append > 0 && idx != 0
                                        let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                        " will add an extra separator, if minwidth is zero
                                        let add_sep = (minwidth == 0)
   31                 0.000101000     elseif a:append < 0 && idx != len(a:parts) - 1
                                        let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                        " will add an extra separator, if minwidth is zero
                                        let add_sep = (minwidth == 0)
   31                 0.000024000     else
   31                 0.000201000       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
   31                 0.000045000       let add_sep = 0
   31                 0.000017000     endif
                                  
   31                 0.000086000     if exists('part.condition')
                                        let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                        let partval = substitute(partval, '}', ' : ""}', '')
   31                 0.000014000     endif
                                  
   31   0.000819000   0.000190000     let val .= s:wrap_accent(part, partval)
   31                 0.000060000     let _ .= val
   62                 0.000135000   endfor
   31                 0.000038000   return _

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:178
Called 115 times
Total time:   0.011195000
 Self time:   0.002793000

count     total (s)      self (s)
  115                 0.000453000   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                      " airline disabled
                                      return
  115                 0.000058000   endif
  115                 0.000084000   try
  115   0.009943000   0.001541000     exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)
                                    catch /^Vim\%((\a\+)\)\=:E48:/
                                      " Catch: Sandbox mode
                                      " no-op
  115                 0.000099000   endtry

FUNCTION  <SNR>184_run_syntax_fold()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/ruby.vim:58
Called 157 times
Total time:   0.006066000
 Self time:   0.005330000

count     total (s)      self (s)
  157                 0.003000000   let [_0, _1, groups, cmd; _] = matchlist(a:args, '\(["'']\)\(.\{-}\)\1\s\+\(.*\)')
  157   0.001364000   0.000628000   if call('s:foldable', split(groups))
  157                 0.000156000     let cmd .= ' fold'
  157                 0.000058000   endif
  157                 0.001422000   exe cmd

FUNCTION  307()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:342
Called 9 times
Total time:   0.001129000
 Self time:   0.000410000

count     total (s)      self (s)
    9                 0.000013000     if !self.last_request_id
                                        let l:wd = go#util#ModuleRoot()
                                        if l:wd == -1
                                          call go#util#EchoError('could not determine appropriate working directory for gopls')
                                          return -1
                                        endif
                                  
                                        if l:wd == ''
                                          let l:wd = getcwd()
                                        endif
                                        let self.wd = l:wd
                                  
                                        if go#config#EchoCommandInfo()
                                          call go#util#EchoProgress("initializing gopls")
                                        endif
                                  
                                        let l:status = { 'desc': '', 'type': 'gopls', 'state': 'initializing', }
                                        call go#statusline#Update(l:wd, l:status)
                                  
                                        let self.workspaceDirectories = add(self.workspaceDirectories, l:wd)
                                        let l:msg = self.newMessage(go#lsp#message#Initialize(l:wd))
                                  
                                        let l:state = s:newHandlerState('')
                                        let l:state.handleResult = funcref('self.handleInitializeResult', [], l:self)
                                  
                                        let self.handlers[l:msg.id] = l:state
                                  
                                        call l:state.start()
                                        call self.write(l:msg)
    9                 0.000002000     endif
                                  
    9                 0.000007000     if !self.ready
                                        call add(self.queue, {'data': a:data, 'handler': a:handler})
                                        return
    9                 0.000003000     endif
                                  
    9   0.000153000   0.000035000     let l:msg = self.newMessage(a:data)
    9                 0.000012000     if has_key(l:msg, 'id')
                                        let self.handlers[l:msg.id] = a:handler
    9                 0.000004000     endif
                                  
    9   0.000055000   0.000017000     call a:handler.start()
    9   0.000584000   0.000021000     call self.write(l:msg)

FUNCTION  31()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:575
Called 752 times
Total time:   0.168389000
 Self time:   0.007259000

count     total (s)      self (s)
  752   0.167970000   0.006840000     return nerdtree#pathEquals(self.str(), a:path.str())

FUNCTION  32()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:580
Called 499 times
Total time:   0.158939000
 Self time:   0.014709000

count     total (s)      self (s)
  499                 0.008289000     let l:newPath = copy(self)
                                  
  499   0.143497000   0.002681000     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                                  
  499                 0.000798000     let l:newPath.cachedDisplayString = ''
  499   0.005215000   0.001801000     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                                  
  499                 0.000508000     return l:newPath

FUNCTION  33()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:596
Called 1442 times
Total time:   0.034912000
 Self time:   0.034912000

count     total (s)      self (s)
 1442                 0.015509000     let tmp = resolve(a:path)
 1442                 0.018773000     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  34()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:605
Called 719 times
Total time:   0.174536000
 Self time:   0.105193000

count     total (s)      self (s)
  719   0.017548000   0.002374000     call self.extractDriveLetter(a:fullpath)
                                  
  719   0.009237000   0.002718000     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                                  
  719                 0.011389000     if getftype(fullpath) ==# 'fifo'
                                          throw 'NERDTree.InvalidFiletypeError: Cant handle FIFO files: ' . a:fullpath
  719                 0.000430000     endif
                                  
  719                 0.010379000     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                                  
  719                 0.001151000     let self.isReadOnly = 0
  719                 0.004296000     if isdirectory(a:fullpath)
  205                 0.000238000         let self.isDirectory = 1
  514                 0.025301000     elseif filereadable(a:fullpath)
  514                 0.001268000         let self.isDirectory = 0
  514                 0.012342000         let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                      else
                                          throw 'NERDTree.InvalidArgumentsError: Invalid path = ' . a:fullpath
  719                 0.000401000     endif
                                  
  719                 0.001221000     let self.isExecutable = 0
  719                 0.000814000     if !self.isDirectory
  514                 0.003608000         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
  719                 0.000478000     endif
                                  
                                      "grab the last part of the path (minus the trailing slash)
  719   0.011649000   0.003135000     let lastPathComponent = self.getLastPathComponent(0)
                                  
                                      "get the path to the new node with the parent dir fully resolved
  719   0.026698000   0.004495000     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                                  
                                      "if  the last part of the path is a symlink then flag it as such
  719   0.020056000   0.003123000     let self.isSymLink = (s:Path.Resolve(hardPath) !=# hardPath)
  719                 0.000815000     if self.isSymLink
                                          let self.symLinkDest = s:Path.Resolve(fullpath)
                                  
                                          "if the link is a dir then slap a / on the end of its dest
                                          if isdirectory(self.symLinkDest)
                                  
                                              "we always wanna treat MS windows shortcuts as files for
                                              "simplicity
                                              if hardPath !~# '\.lnk$'
                                  
                                                  let self.symLinkDest = self.symLinkDest . '/'
                                              endif
                                          endif
  719                 0.000369000     endif

FUNCTION  35()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:656
Called 220 times
Total time:   0.136284000
 Self time:   0.004337000

count     total (s)      self (s)
  220   0.099449000   0.001678000     call self.readInfoFromDisk(self.str())
  220   0.013335000   0.001616000     call g:NERDTreePathNotifier.NotifyListeners('refresh', self, a:nerdtree, {})
  220   0.023285000   0.000828000     call self.cacheDisplayString()

FUNCTION  38()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:713
Called 6281 times
Total time:   0.533552000
 Self time:   0.290283000

count     total (s)      self (s)
 6281                 0.014280000     let options = a:0 ? a:1 : {}
 6281                 0.007766000     let toReturn = ''
                                  
 6281                 0.012846000     if has_key(options, 'format')
  113                 0.000216000         let format = options['format']
  113                 0.000317000         if has_key(self, '_strFor' . format)
  113   0.003159000   0.000709000             exec 'let toReturn = self._strFor' . format . '()'
                                          else
                                              throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
  113                 0.000067000         endif
 6168                 0.003813000     else
 6168   0.237329000   0.019820000         let toReturn = self._str()
 6281                 0.003838000     endif
                                  
 6281   0.042464000   0.019669000     if nerdtree#has_opt(options, 'escape')
                                          let toReturn = shellescape(toReturn)
 6281                 0.003720000     endif
                                  
 6281                 0.012288000     if has_key(options, 'truncateTo')
   41                 0.000081000         let limit = options['truncateTo']
   41                 0.000192000         if strdisplaywidth(toReturn) > limit-1
                                              while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
                                                  let toReturn = substitute(toReturn, '^.', '', '')
                                              endwhile
                                              if len(split(toReturn, '/')) > 1
                                                  let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                              else
                                                  let toReturn = '<' . toReturn
                                              endif
   41                 0.000023000         endif
 6281                 0.003485000     endif
                                  
 6281                 0.006749000     return toReturn

FUNCTION  39()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:750
Called 94 times
Total time:   0.001108000
 Self time:   0.001108000

count     total (s)      self (s)
   94                 0.000470000     let toReturn = '/' . join(self.pathSegments, '/')
   94                 0.000214000     if self.isDirectory && toReturn !=# '/'
   90                 0.000162000         let toReturn  = toReturn . '/'
   94                 0.000052000     endif
   94                 0.000100000     return toReturn

FUNCTION  <SNR>142_TempReadPre()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3272
Called 1 time
Total time:   0.000121000
 Self time:   0.000042000

count     total (s)      self (s)
    1   0.000098000   0.000019000   let key = s:cpath(s:AbsoluteVimPath(a:file))
    1                 0.000003000   if has_key(s:temp_files, key)
                                      let dict = s:temp_files[key]
                                      setlocal nomodeline
                                      if empty(&bufhidden)
                                        setlocal bufhidden=delete
                                      endif
                                      setlocal buftype=nowrite
                                      setlocal nomodifiable
                                      call s:InitializeBuffer(dict)
                                      if len(dict.git_dir)
                                        call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                      endif
    1                 0.000001000   endif
    1                 0.000001000   return ''

FUNCTION  tagbar#currenttag()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:3936
Called 75 times
Total time:   0.004322000
 Self time:   0.003860000

count     total (s)      self (s)
                                      " Indicate that the statusline functionality is being used. This prevents
                                      " the CloseWindow() function from removing the autocommands.
   75                 0.000437000     let s:statusline_in_use = 1
                                  
   75                 0.000116000     if a:0 >= 1
                                          " also test for non-zero value for backwards compatibility
   75                 0.000647000         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   75                 0.000222000         let fullpath  = a:1 =~# 'f'
   75                 0.000193000         let prototype = a:1 =~# 'p'
   75                 0.000102000         if a:0 >= 2
   75                 0.000158000             let search_method = a:2
                                          else
                                              let search_method = g:tagbar_highlight_method
   75                 0.000051000         endif
                                      else
                                          let longsig   = 0
                                          let fullpath  = 0
                                          let prototype = 0
                                          let search_method = g:tagbar_highlight_method
   75                 0.000052000     endif
                                  
   75   0.001037000   0.000575000     if !s:Init(1)
   75                 0.000106000         return a:default
                                      endif
                                  
                                      let tag = s:GetNearbyTag(search_method, 1)
                                  
                                      if !empty(tag)
                                          if prototype
                                              return tag.getPrototype(1)
                                          else
                                              return printf(a:fmt, tag.str(longsig, fullpath))
                                          endif
                                      else
                                          return a:default
                                      endif

FUNCTION  120()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:210
Called 251 times
Total time:   0.004240000
 Self time:   0.001614000

count     total (s)      self (s)
  251                 0.000181000     if a:path.isDirectory
  145   0.002953000   0.000327000         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
  106                 0.000030000     else
  106                 0.000491000         let newTreeNode = copy(self)
  106                 0.000099000         let newTreeNode.path = a:path
  106                 0.000099000         let newTreeNode.parent = {}
  106                 0.000095000         let newTreeNode._nerdtree = a:nerdtree
  106                 0.000053000         return newTreeNode
                                      endif

FUNCTION  126()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:262
Called 21 times
Total time:   0.021645000
 Self time:   0.000451000

count     total (s)      self (s)
   21   0.021287000   0.000093000     let ln = self.getNerdtree().ui.getLineNum(self)
   21                 0.000020000     if ln != -1
   21                 0.000017000         if a:isJump
    2                 0.000002000             mark '
   21                 0.000007000         endif
   21                 0.000056000         call cursor(ln, col('.'))
                                      else
                                          if a:recurseUpward
                                              let node = self
                                              while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                                  let node = node.parent
                                                  call node.open()
                                              endwhile
                                              call self._nerdtree.render()
                                              call node.putCursorHere(a:isJump, 0)
                                          endif
   21                 0.000005000     endif

FUNCTION  127()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:283
Called 200 times
Total time:   0.122234000
 Self time:   0.001417000

count     total (s)      self (s)
  200   0.122111000   0.001294000     call self.path.refresh(self.getNerdtree())

FUNCTION  xolox#misc#msg#debug()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/msg.vim:48
Called 2 times
Total time:   0.000062000
 Self time:   0.000062000

count     total (s)      self (s)
                                    " Show a formatted debugging message to the user, *if the user has enabled
                                    " increased verbosity by setting Vim's ['verbose'] [] option to one
                                    " (1) or higher*.
                                    "
                                    " This function has the same argument handling as the
                                    " `xolox#misc#msg#info()` function.
                                    "
                                    " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                                    " provides lazy evaluation in the sense that complex data structures are
                                    " only converted to strings when the user has enabled increased verbosity.
                                    "
                                    " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
    2                 0.000013000   if &vbs >= 1
                                      call s:show_message('Question', a:000)
    2                 0.000004000   endif

FUNCTION  FugitiveIsGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:317
Called 254 times
Total time:   0.011215000
 Self time:   0.011215000

count     total (s)      self (s)
  254                 0.001060000   if !a:0 || type(a:1) !=# type('')
                                      return !empty(call('FugitiveGitDir', a:000))
  254                 0.000184000   endif
  254                 0.002911000   let path = substitute(a:1, '[\/]$', '', '') . '/'
  254                 0.005925000   return len(path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>153_on_stderr_vim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:83
Called 2 times
Total time:   0.000039000
 Self time:   0.000010000

count     total (s)      self (s)
    2   0.000038000   0.000009000   call self.handler.err(self.buffer)

FUNCTION  airline#extensions#tabline#tabws#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/tabws.vim:26
Called 2 times
Total time:   0.000018000
 Self time:   0.000018000

count     total (s)      self (s)
    2                 0.000005000   if exists('#airline')
    2                 0.000005000     let s:current_bufnr = -1
    2                 0.000004000     let s:current_tabnr = -1
    2                 0.000001000   endif

FUNCTION  ale#linter#PreProcess()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:90
Called 3 times
Total time:   0.000372000
 Self time:   0.000355000

count     total (s)      self (s)
    3                 0.000005000     if type(a:linter) isnot v:t_dict
                                          throw 'The linter object must be a Dictionary'
    3                 0.000001000     endif
                                  
    3                 0.000016000     let l:obj = {   'name': get(a:linter, 'name'),   'lsp': get(a:linter, 'lsp', ''),}
                                  
    3                 0.000005000     if type(l:obj.name) isnot v:t_string
                                          throw '`name` must be defined to name the linter'
    3                 0.000003000     endif
                                  
    3                 0.000004000     let l:needs_address = l:obj.lsp is# 'socket'
    3                 0.000004000     let l:needs_executable = l:obj.lsp isnot# 'socket'
    3                 0.000003000     let l:needs_command = l:obj.lsp isnot# 'socket'
    3                 0.000006000     let l:needs_lsp_details = !empty(l:obj.lsp)
                                  
    3                 0.000003000     if empty(l:obj.lsp)
    2                 0.000004000         let l:obj.callback = get(a:linter, 'callback')
                                  
    2   0.000013000   0.000008000         if !s:IsCallback(l:obj.callback)
                                              throw '`callback` must be defined with a callback to accept output'
    2                 0.000001000         endif
    3                 0.000002000     endif
                                  
    3                 0.000007000     if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                          throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
    3                 0.000000000     endif
                                  
    3                 0.000003000     if !l:needs_executable
                                          if has_key(a:linter, 'executable')
                                              throw '`executable` cannot be used when lsp == ''socket'''
                                          endif
    3                 0.000004000     elseif has_key(a:linter, 'executable')
    3                 0.000003000         let l:obj.executable = a:linter.executable
                                  
    3                 0.000006000         if type(l:obj.executable) isnot v:t_string&& type(l:obj.executable) isnot v:t_func
                                              throw '`executable` must be a String or Function if defined'
    3                 0.000000000         endif
                                      else
                                          throw '`executable` must be defined'
    3                 0.000002000     endif
                                  
    3                 0.000000000     if !l:needs_command
                                          if has_key(a:linter, 'command')
                                              throw '`command` cannot be used when lsp == ''socket'''
                                          endif
    3                 0.000004000     elseif has_key(a:linter, 'command')
    3                 0.000003000         let l:obj.command = a:linter.command
                                  
    3                 0.000006000         if type(l:obj.command) isnot v:t_string&& type(l:obj.command) isnot v:t_func
                                              throw '`command` must be a String or Function if defined'
    3                 0.000000000         endif
                                      else
                                          throw '`command` must be defined'
    3                 0.000001000     endif
                                  
    3                 0.000000000     if !l:needs_address
    3                 0.000003000         if has_key(a:linter, 'address')
                                              throw '`address` cannot be used when lsp != ''socket'''
    3                 0.000000000         endif
                                      elseif has_key(a:linter, 'address')
                                          if type(a:linter.address) isnot v:t_string&& type(a:linter.address) isnot v:t_func
                                              throw '`address` must be a String or Function if defined'
                                          endif
                                  
                                          let l:obj.address = a:linter.address
                                  
                                          if has_key(a:linter, 'cwd')
                                              throw '`cwd` makes no sense for socket LSP connections'
                                          endif
                                      else
                                          throw '`address` must be defined for getting the LSP address'
    3                 0.000002000     endif
                                  
    3                 0.000003000     if has_key(a:linter, 'cwd')
    1                 0.000001000         let l:obj.cwd = a:linter.cwd
                                  
    1                 0.000003000         if type(l:obj.cwd) isnot v:t_string&& type(l:obj.cwd) isnot v:t_func
                                              throw '`cwd` must be a String or Function if defined'
    1                 0.000001000         endif
    3                 0.000001000     endif
                                  
    3                 0.000001000     if l:needs_lsp_details
                                          " Default to using the filetype as the language.
    1                 0.000002000         let l:obj.language = get(a:linter, 'language', a:filetype)
                                  
    1                 0.000002000         if type(l:obj.language) isnot v:t_string&& type(l:obj.language) isnot v:t_func
                                              throw '`language` must be a String or Function if defined'
    1                 0.000000000         endif
                                  
    1                 0.000001000         if has_key(a:linter, 'project_root')
    1                 0.000001000             let l:obj.project_root = a:linter.project_root
                                  
    1                 0.000003000             if type(l:obj.project_root) isnot v:t_string&& type(l:obj.project_root) isnot v:t_func
                                                  throw '`project_root` must be a String or Function'
    1                 0.000001000             endif
                                          else
                                              throw '`project_root` must be defined for LSP linters'
    1                 0.000000000         endif
                                  
    1                 0.000001000         if has_key(a:linter, 'completion_filter')
                                              let l:obj.completion_filter = a:linter.completion_filter
                                  
                                              if !s:IsCallback(l:obj.completion_filter)
                                                  throw '`completion_filter` must be a callback'
                                              endif
    1                 0.000000000         endif
                                  
    1                 0.000001000         if has_key(a:linter, 'initialization_options')
                                              let l:obj.initialization_options = a:linter.initialization_options
                                  
                                              if type(l:obj.initialization_options) isnot v:t_dict&& type(l:obj.initialization_options) isnot v:t_func
                                                  throw '`initialization_options` must be a Dictionary or Function if defined'
                                              endif
    1                 0.000001000         endif
                                  
    1                 0.000001000         if has_key(a:linter, 'lsp_config')
    1                 0.000002000             if type(a:linter.lsp_config) isnot v:t_dict&& type(a:linter.lsp_config) isnot v:t_func
                                                  throw '`lsp_config` must be a Dictionary or Function if defined'
    1                 0.000001000             endif
                                  
    1                 0.000001000             let l:obj.lsp_config = a:linter.lsp_config
    1                 0.000000000         endif
    3                 0.000002000     endif
                                  
    3                 0.000005000     let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                                  
    3                 0.000011000     if type(l:obj.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                          throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
    3                 0.000000000     endif
                                  
                                      " An option indicating that this linter should only be run against the
                                      " file on disk.
    3                 0.000005000     let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                                  
    3   0.000016000   0.000010000     if !s:IsBoolean(l:obj.lint_file) && type(l:obj.lint_file) isnot v:t_func
                                          throw '`lint_file` must be `0`, `1`, or a Function'
    3                 0.000002000     endif
                                  
                                      " An option indicating that the buffer should be read.
    3                 0.000006000     let l:obj.read_buffer = get(a:linter, 'read_buffer', 1)
                                  
    3   0.000009000   0.000003000     if !s:IsBoolean(l:obj.read_buffer)
                                          throw '`read_buffer` must be `0` or `1`'
    3                 0.000000000     endif
                                  
    3                 0.000006000     let l:obj.aliases = get(a:linter, 'aliases', [])
                                  
    3                 0.000013000     if type(l:obj.aliases) isnot v:t_list|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                          throw '`aliases` must be a List of String values'
    3                 0.000000000     endif
                                  
    3                 0.000003000     return l:obj

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:61
Called 24 times
Total time:   0.000504000
 Self time:   0.000504000

count     total (s)      self (s)
   24                 0.000450000     if !isdirectory(a:dir)
   24                 0.000024000         return
                                      endif
                                  
                                      if s:reuseWin(a:dir)
                                          return
                                      endif
                                  
                                      call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  go#util#env()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:73
Called 17 times
Total time:   0.000258000
 Self time:   0.000258000

count     total (s)      self (s)
   17                 0.000073000   let l:key = tolower(a:key)
   17                 0.000074000   if has_key(s:env_cache, l:key)
   17                 0.000045000     return s:env_cache[l:key]
                                    endif
                                  
                                    if executable('go')
                                      let l:var = call('go#util#'.l:key, [])
                                      if go#util#ShellError() != 0
                                        call go#util#EchoError(printf("'go env %s' failed", toupper(l:key)))
                                        return ''
                                      endif
                                    else
                                      let l:var = eval("$".toupper(a:key))
                                    endif
                                  
                                    let s:env_cache[l:key] = l:var
                                    return l:var

FUNCTION  go#config#HighlightFunctions()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:418
Called 16 times
Total time:   0.000034000
 Self time:   0.000034000

count     total (s)      self (s)
   16                 0.000029000   return get(g:, 'go_highlight_functions', 0)

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 1281 times
Total time:   0.013526000
 Self time:   0.013526000

count     total (s)      self (s)
 1281                 0.001949000   let x = a:i - 1
 1429                 0.001683000   while x >= 0
 1206                 0.002864000     let group = a:sections[x][0]
 1206                 0.002173000     if group != '' && group != '|'
 1058                 0.001073000       return group
  148                 0.000080000     endif
  148                 0.000395000     let x = x - 1
  371                 0.000329000   endwhile
  223                 0.000188000   return ''

FUNCTION  40()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:761
Called 3 times
Total time:   0.000366000
 Self time:   0.000048000

count     total (s)      self (s)
    3   0.000365000   0.000047000     return fnameescape(self.str())

FUNCTION  42()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:789
Called 16 times
Total time:   0.001342000
 Self time:   0.000474000

count     total (s)      self (s)
   16   0.000353000   0.000045000     let lead = nerdtree#slash()
                                  
                                      "if we are running windows then slap a drive letter on the front
   16   0.000114000   0.000033000     if nerdtree#runningWindows()
                                          let lead = self.drive . '\'
   16                 0.000006000     endif
                                  
   16   0.000282000   0.000076000     let toReturn = lead . join(self.pathSegments, nerdtree#slash())
                                  
   16   0.000116000   0.000035000     if !nerdtree#runningWindows()
   16   0.000373000   0.000181000         let toReturn = escape(toReturn, self._escChars())
   16                 0.000005000     endif
   16                 0.000018000     return toReturn

FUNCTION  43()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:808
Called 6168 times
Total time:   0.217509000
 Self time:   0.089923000

count     total (s)      self (s)
 6168   0.112871000   0.019472000     let l:separator = nerdtree#slash()
 6168                 0.010687000     let l:leader = l:separator
                                  
 6168   0.048648000   0.014461000     if nerdtree#runningWindows()
                                          let l:leader = self.drive . l:separator
 6168                 0.003749000     endif
                                  
 6168                 0.025209000     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  44()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:821
Called 719 times
Total time:   0.004358000
 Self time:   0.004358000

count     total (s)      self (s)
  719                 0.004070000     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  <SNR>114_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:32
Called 2031 times
Total time:   0.011627000
 Self time:   0.011627000

count     total (s)      self (s)
 2031                 0.005058000     if index(a:list, a:name) == -1
 2031                 0.004080000       call add(a:list, a:name)
 2031                 0.001505000       return 1
                                      else
                                        if &vbs
                                          echomsg printf("airline: group: %s already done, skipping", a:name)
                                        endif
                                        return 0
                                      endif

FUNCTION  go#path#ToURI()
    Defined: ~/.vim/plugged/vim-go/autoload/go/path.vim:158
Called 9 times
Total time:   0.000390000
 Self time:   0.000171000

count     total (s)      self (s)
    9   0.000050000   0.000032000   let l:absolute = !go#util#IsWin() && a:path[0] is# '/'
    9                 0.000010000   let l:prefix = ''
    9                 0.000008000   let l:path = a:path
                                  
    9   0.000031000   0.000017000   if go#util#IsWin() && l:path[1:2] is# ':\'
                                      let l:absolute = 1
                                      let l:prefix = '/' . l:path[0:1]
                                      let l:path = l:path[2:]
    9                 0.000005000   endif
                                  
    9   0.000254000   0.000067000   return substitute(   (l:absolute ? 'file://' : '') . l:prefix . go#uri#EncodePath(l:path),   '\\',   '/',   'g',)

FUNCTION  go#config#HighlightSpaceTabError()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:406
Called 16 times
Total time:   0.000033000
 Self time:   0.000033000

count     total (s)      self (s)
   16                 0.000028000   return get(g:, 'go_highlight_space_tab_error', 0)

FUNCTION  <SNR>101_update_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:183
Called 257 times
Total time:   0.215842000
 Self time:   0.015184000

count     total (s)      self (s)
  771                 0.002066000   for vcs in keys(s:vcs_config)
  514   0.204913000   0.004255000     call {s:vcs_config[vcs].update_branch}()
  514                 0.002638000     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    6                 0.000017000       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    6                 0.000014000       unlet! b:airline_head
  514                 0.000367000     endif
  771                 0.000710000   endfor

FUNCTION  <SNR>153_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 13 times
Total time:   0.000104000
 Self time:   0.000104000

count     total (s)      self (s)
   13                 0.000032000   if has('unix')
   13                 0.000051000     return ['sh', '-c', a:cmd]
                                    endif
                                  
                                    if has('win32')
                                      return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                                    endif
                                  
                                    throw 'unknown os'

FUNCTION  go#config#FmtOptions()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:347
Called 9 times
Total time:   0.000173000
 Self time:   0.000173000

count     total (s)      self (s)
    9                 0.000159000   return get(b:, "go_fmt_options", get(g:, "go_fmt_options", {}))

FUNCTION  <SNR>148_highlightMatches()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:1551
Called 6 times
Total time:   0.003424000
 Self time:   0.002629000

count     total (s)      self (s)
                                    " set buffer variables for errors and warnings to zero values
    6                 0.000114000   let b:go_diagnostic_matches = {'errors': [], 'warnings': []}
                                  
    6                 0.000168000   if hlexists('goDiagnosticError')
                                      " clear the old matches just before adding the new ones to keep flicker
                                      " to a minimum and clear before checking the level so that if the user
                                      " changed the level since the last highlighting, the highlighting will be
                                      " be properly cleared.
    6   0.000458000   0.000092000     call go#util#ClearHighlights('goDiagnosticError')
    6   0.000128000   0.000028000     if go#config#DiagnosticsLevel() >= 2
                                        let b:go_diagnostic_matches.errors = copy(a:errorMatches)
                                        if go#config#HighlightDiagnosticErrors()
                                          call go#util#HighlightPositions('goDiagnosticError', a:errorMatches)
                                        endif
    6                 0.000005000     endif
    6                 0.000006000   endif
                                  
    6                 0.000063000   if hlexists('goDiagnosticWarning')
                                      " clear the old matches just before adding the new ones to keep flicker
                                      " to a minimum and clear before checking the level so that if the user
                                      " changed the level since the last highlighting, the highlighting will be
                                      " be properly cleared.
    6   0.000272000   0.000033000     call go#util#ClearHighlights('goDiagnosticWarning')
    6   0.000118000   0.000028000     if go#config#DiagnosticsLevel() >= 2
                                        let b:go_diagnostic_matches.warnings = copy(a:warningMatches)
                                        if go#config#HighlightDiagnosticWarnings()
                                          call go#util#HighlightPositions('goDiagnosticWarning', a:warningMatches)
                                        endif
    6                 0.000005000     endif
    6                 0.000005000   endif
                                  
                                    " re-apply matches at the time the buffer is displayed in a new window or
                                    " redisplayed in an existing window: e.g. :edit,
    6                 0.000058000   augroup vim-go-diagnostics
    6                 0.001601000     autocmd! * <buffer>
    6                 0.000069000     autocmd BufDelete <buffer> autocmd! vim-go-diagnostics * <buffer=abuf>
    6                 0.000033000     if has('textprop')
    6                 0.000033000       autocmd BufReadPost <buffer> nested call s:highlightMatches(b:go_diagnostic_matches.errors, b:go_diagnostic_matches.warnings)
                                      else
                                        autocmd BufWinEnter <buffer> nested call s:highlightMatches(b:go_diagnostic_matches.errors, b:go_diagnostic_matches.warnings)
    6                 0.000005000     endif
    6                 0.000008000   augroup end

FUNCTION  130()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:310
Called 41 times
Total time:   0.844813000
 Self time:   0.000275000

count     total (s)      self (s)
   41   0.844772000   0.000234000     return self._renderToString(0, 0)

FUNCTION  131()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:319
Called 1598 times
Total time:   1.288206000
 Self time:   1.092225000

count     total (s)      self (s)
 1598                 0.001298000     let output = ''
 1598                 0.001186000     if a:drawText ==# 1
                                  
 1555                 0.002491000         let treeParts = repeat('  ', a:depth - 1)
 1555                 0.003712000         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                                  
 1555   0.220384000   0.003771000         let line = treeParts . self.displayString()
 1555                 0.001944000         let output = output . line . "\n"
 1598                 0.000623000     endif
                                  
                                      " if the node is an open dir, draw its children
 1598                 0.001855000     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                                  
   63   0.541616000   0.000226000         let childNodesToDraw = self.getVisibleChildren()
                                  
   63   0.044397000   0.000172000         if self.isCascadable() && a:depth > 0
                                  
    2                 0.000005000             let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                                  
   61                 0.000099000         elseif len(childNodesToDraw) > 0
 1616                 0.001254000             for i in childNodesToDraw
 1555                 0.003642000                 let output = output . i._renderToString(a:depth + 1, 1)
 1616                 0.000696000             endfor
   63                 0.000022000         endif
 1598                 0.000520000     endif
                                  
 1598                 0.001073000     return output

FUNCTION  133()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:24
Called 10 times
Total time:   0.648058000
 Self time:   0.000298000

count     total (s)      self (s)
   10                 0.000033000     let l:options = (a:0 > 0) ? a:1 : {}
                                  
   10   0.111077000   0.000082000     call self.toggleOpen(l:options)
                                  
                                      " Note that we only re-render the NERDTree for this node if we did NOT
                                      " create a new node and render it in a new window or tab.  In the latter
                                      " case, rendering the NERDTree for this node could overwrite the text of
                                      " the new NERDTree!
   10                 0.000046000     if !has_key(l:options, 'where') || empty(l:options['where'])
   10   0.523666000   0.000055000         call self.getNerdtree().render()
   10   0.013182000   0.000028000         call self.putCursorHere(0, 0)
   10                 0.000003000     endif

FUNCTION  134()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:45
Called 251 times
Total time:   0.001212000
 Self time:   0.001212000

count     total (s)      self (s)
  251                 0.000349000     call add(self.children, a:treenode)
  251                 0.000247000     let a:treenode.parent = self
                                  
  251                 0.000154000     if a:inOrder
                                          call self.sortChildren()
  251                 0.000084000     endif

FUNCTION  135()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:56
Called 5 times
Total time:   0.022102000
 Self time:   0.000100000

count     total (s)      self (s)
                                  
                                      " Close all directories in this directory node's cascade. This is
                                      " necessary to ensure consistency when cascades are rendered.
   10   0.022050000   0.000048000     for l:dirNode in self.getCascade()
    5                 0.000013000         let l:dirNode.isOpen = 0
   10                 0.000008000     endfor

FUNCTION  137()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:86
Called 251 times
Total time:   0.007136000
 Self time:   0.001478000

count     total (s)      self (s)
  251   0.005247000   0.000801000     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
  251   0.001664000   0.000452000     call self.addChild(newTreeNode, a:inOrder)
  251                 0.000150000     return newTreeNode

FUNCTION  138()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:95
Called 751 times
Total time:   0.201771000
 Self time:   0.017808000

count     total (s)      self (s)
  751                 0.000562000     let l:result = ''
                                  
                                      " Build a label that identifies this TreeDirNode.
  751                 0.000545000     let l:label = ''
  751   0.172505000   0.001624000     let l:cascade = self.getCascade()
 1504                 0.001171000     for l:dirNode in l:cascade
  753   0.010257000   0.001761000         let l:next = l:dirNode.path.displayString()
  753                 0.001825000         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
 1504                 0.000692000     endfor
                                  
                                      " Select the appropriate open/closed status indicator symbol.
  751                 0.001789000     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
  751                 0.001243000     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
  751   0.006704000   0.002118000     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                                  
  751                 0.000969000     return l:symbol . l:flags . l:label

FUNCTION  139()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:120
Called 683 times
Total time:   0.644801000
 Self time:   0.307225000

count     total (s)      self (s)
  683   0.162987000   0.003008000     if a:path.equals(self.path)
   42                 0.000047000         return self
  641                 0.000448000     endif
  641   0.007315000   0.001883000     if nerdtree#caseSensitiveFS()
                                          if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                              return {}
                                          endif
  641                 0.000459000     else
  641   0.132662000   0.006879000         if stridx(tolower(a:path.str()), tolower(self.path.str()), 0) ==# -1
  596                 0.000818000             return {}
   45                 0.000031000         endif
   45                 0.000033000     endif
                                  
   45                 0.000072000     if self.path.isDirectory
  689                 0.001370000         for i in self.children
  688   0.010159000   0.002671000             let retVal = i.findNode(a:path)
  688                 0.001236000             if retVal !=# {}
   44                 0.000061000                 return retVal
  644                 0.000489000             endif
  645                 0.000562000         endfor
    1                 0.000000000     endif
    1                 0.000000000     return {}

FUNCTION  <SNR>174_fmt_cmd()
    Defined: ~/.vim/plugged/vim-go/autoload/go/fmt.vim:159
Called 9 times
Total time:   0.000931000
 Self time:   0.000758000

count     total (s)      self (s)
    9                 0.000050000   let l:cmd = [a:bin_name, '-w']
                                  
                                    " add the options for binary (if any). go_fmt_options was by default of type
                                    " string, however to allow customization it's now a dictionary of binary
                                    " name mapping to options.
    9   0.000264000   0.000091000   let opts = go#config#FmtOptions()
    9                 0.000077000   if type(opts) == type({})
    9                 0.000079000     let opts = has_key(opts, a:bin_name) ? opts[a:bin_name] : ""
    9                 0.000012000   endif
    9                 0.000205000   call extend(cmd, split(opts, " "))
    9                 0.000029000   if a:bin_name is# 'goimports'
    9                 0.000051000     call extend(cmd, ["-srcdir", a:target])
    9                 0.000007000   endif
                                  
    9                 0.000042000   call add(cmd, a:source)
    9                 0.000014000   return cmd

FUNCTION  379()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 4 times
Total time:   0.000222000
 Self time:   0.000070000

count     total (s)      self (s)
    4                 0.000005000     let bufnum = get(self.buffers, a:i, -1)
    4   0.000085000   0.000008000     let group = self.get_group(a:i)
    4   0.000082000   0.000007000     let pgroup = self.get_group(a:i - 1)
                                      " always add a space when powerline_fonts are used
                                      " or for the very first item
    4                 0.000006000     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1                 0.000001000       let space = s:spc
    3                 0.000001000     else
    3                 0.000005000       let space= (pgroup == group ? s:spc : '')
    4                 0.000000000     endif
                                  
    4                 0.000006000     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                        if len(s:number_map) > 0
                                          return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                        else
                                          return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                        endif
    4                 0.000000000     else
    4                 0.000008000       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                      endif

FUNCTION  <SNR>148_newHandlerState()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:527
Called 9 times
Total time:   0.000365000
 Self time:   0.000365000

count     total (s)      self (s)
    9                 0.000267000   let l:state = { 'winid': win_getid(winnr()), 'statustype': a:statustype, 'jobdir': getcwd(), 'handleResult': funcref('s:noop'), }
                                  
                                    " explicitly bind requestComplete to state so that within it, self will
                                    " always refer to state. See :help Partial for more information.
    9                 0.000037000   let l:state.requestComplete = funcref('s:requestComplete', [], l:state)
                                  
                                    " explicitly bind start to state so that within it, self will
                                    " always refer to state. See :help Partial for more information.
    9                 0.000037000   let l:state.start = funcref('s:start', [], l:state)
                                  
    9                 0.000006000   return l:state

FUNCTION  <SNR>153_on_stdout_vim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:79
Called 77 times
Total time:   0.000249000
 Self time:   0.000249000

count     total (s)      self (s)
   77                 0.000219000   call add(self.stdoutbuffer, a:data)

FUNCTION  ale#linter#Define()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:258
Called 3 times
Total time:   0.000420000
 Self time:   0.000048000

count     total (s)      self (s)
                                      " This command will throw from the sandbox.
    3                 0.000007000     let &l:equalprg=&l:equalprg
                                  
    3   0.000388000   0.000016000     let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                                  
    3                 0.000004000     if !has_key(s:linters, a:filetype)
    1                 0.000001000         let s:linters[a:filetype] = []
    3                 0.000001000     endif
                                  
                                      " Remove previously defined linters with the same name.
    3                 0.000008000     call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
    3                 0.000006000     call add(s:linters[a:filetype], l:new_linter)

FUNCTION  <SNR>37_chRoot()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:189
Called 1 time
Total time:   0.017086000
 Self time:   0.000008000

count     total (s)      self (s)
    1   0.017085000   0.000007000     call b:NERDTree.changeRoot(a:node)

FUNCTION  303()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:231
Called 6 times
Total time:   0.009494000
 Self time:   0.000136000

count     total (s)      self (s)
    6                 0.000078000     let self.diagnosticsQueue = add(self.diagnosticsQueue, a:data)
    6   0.009409000   0.000051000     call self.updateDiagnostics()

FUNCTION  12()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:263
Called 1557 times
Total time:   0.015593000
 Self time:   0.005824000

count     total (s)      self (s)
 1557                 0.001828000     if self.cachedDisplayString ==# ''
  251   0.010051000   0.000282000         call self.cacheDisplayString()
 1557                 0.000577000     endif
                                  
 1557                 0.001089000     return self.cachedDisplayString

FUNCTION  ale#events#QuitEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:14
Called 1 time
Total time:   0.000027000
 Self time:   0.000016000

count     total (s)      self (s)
                                      " Remember when ALE is quitting for BufWrite, etc.
    1   0.000025000   0.000014000     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  nerdtree#compareNodePaths()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:107
Called 2325 times
Total time:   0.377761000
 Self time:   0.092043000

count     total (s)      self (s)
 2325   0.201078000   0.005563000     let sortKey1 = a:p1.getSortKey()
 2325   0.095720000   0.005517000     let sortKey2 = a:p2.getSortKey()
 2325                 0.001971000     let i = 0
 4618                 0.015518000     while i < min([len(sortKey1), len(sortKey2)])
                                          " Compare chunks upto common length.
                                          " If chunks have different type, the one which has
                                          " integer type is the lesser.
 4418                 0.012612000         if type(sortKey1[i]) == type(sortKey2[i])
 4418                 0.007612000             if sortKey1[i] <# sortKey2[i]
 1219                 0.000827000                 return - 1
 3199                 0.005420000             elseif sortKey1[i] ># sortKey2[i]
  906                 0.000550000                 return 1
 2293                 0.001173000             endif
                                          elseif type(sortKey1[i]) == type(0)
                                              return -1
                                          elseif type(sortKey2[i]) == type(0)
                                              return 1
 2293                 0.001034000         endif
 2293                 0.002356000         let i += 1
 2493                 0.001558000     endwhile
                                  
                                      " Keys are identical upto common length.
                                      " The key which has smaller chunks is the lesser one.
  200                 0.000551000     if len(sortKey1) < len(sortKey2)
                                          return -1
  200                 0.000533000     elseif len(sortKey1) > len(sortKey2)
                                          return 1
  200                 0.000131000     else
  200                 0.000190000         return 0
                                      endif

FUNCTION  142()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:186
Called 210 times
Total time:   0.000649000
 Self time:   0.000649000

count     total (s)      self (s)
  210                 0.000532000     return len(self.children)

FUNCTION  143()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:198
Called 200 times
Total time:   0.288460000
 Self time:   0.004616000

count     total (s)      self (s)
  200   0.041245000   0.001689000     if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                          return {}
  200                 0.000148000     endif
                                  
  200   0.245350000   0.001062000     let index = self.getChildIndex(a:path)
  200                 0.000273000     if index ==# -1
                                          return {}
  200                 0.000135000     else
  200                 0.000443000         return self.children[index]
                                      endif
                                  

FUNCTION  144()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:219
Called 2 times
Total time:   0.000786000
 Self time:   0.000024000

count     total (s)      self (s)
    2   0.000772000   0.000010000     let array_to_search = a:visible? self.getVisibleChildren() : self.children
    2                 0.000004000     if a:indx > len(array_to_search)
                                          throw 'NERDTree.InvalidArgumentsError: Index is out of bounds.'
    2                 0.000002000     endif
    2                 0.000004000     return array_to_search[a:indx]

FUNCTION  145()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:235
Called 200 times
Total time:   0.244288000
 Self time:   0.015156000

count     total (s)      self (s)
  200   0.038920000   0.001471000     if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                          return -1
  200                 0.000136000     endif
                                  
                                      "do a binary search for the child
  200                 0.000297000     let a = 0
  200   0.001360000   0.000733000     let z = self.getChildCount()
  580                 0.000872000     while a < z
  580                 0.001226000         let mid = (a+z)/2
  580   0.195602000   0.004546000         let diff = nerdtree#compareNodePaths(a:path, self.children[mid].path)
                                  
  580                 0.000802000         if diff ==# -1
  240                 0.000359000             let z = mid
  340                 0.000404000         elseif diff ==# 1
  140                 0.000193000             let a = mid+1
  200                 0.000142000         else
  200                 0.000222000             return mid
  380                 0.000298000         endif
  380                 0.000263000     endwhile
                                      return -1

FUNCTION  147()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:278
Called 60 times
Total time:   0.052496000
 Self time:   0.044011000

count     total (s)      self (s)
                                  
                                      " Construct a path specification such that globpath() will return
                                      " relative pathnames, if possible.
   60   0.014221000   0.008113000     if self.path.str() ==# getcwd()
   44                 0.000157000         let l:pathSpec = ','
   16                 0.000010000     else
   16   0.003168000   0.000951000         let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
                                  
   16   0.000134000   0.000051000         if nerdtree#runningWindows()
                                              let l:pathSpec = substitute(l:pathSpec, "\\[\\(.*\\]\\)", "[[]\\1", "g")
   16                 0.000010000         endif
                                  
                                          " On Windows, the drive letter may be removed by "fnamemodify()".
   16   0.000133000   0.000056000         if nerdtree#runningWindows() && l:pathSpec[0] == nerdtree#slash()
                                              let l:pathSpec = self.path.drive . l:pathSpec
   16                 0.000007000         endif
   60                 0.000040000     endif
                                  
   60                 0.000098000     let l:globList = []
                                  
                                      " See ':h version7.txt' and ':h version8.txt' for details on the
                                      " development of the glob() and globpath() functions.
   60                 0.000218000     if v:version > 704 || (v:version ==# 704 && has('patch654'))
   60                 0.027667000         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
                                      elseif v:version ==# 704 && has('patch279')
                                          let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
                                      elseif v:version > 702 || (v:version ==# 702 && has('patch051'))
                                          let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
                                          let l:globList = split(l:globString, "\n")
                                      else
                                          let l:globString = globpath(l:pathSpec, a:pattern)
                                          let l:globList = split(l:globString, "\n")
   60                 0.000049000     endif
                                  
                                      " If a:all is false, filter '.' and '..' from the output.
   60                 0.000100000     if !a:all
   30                 0.000052000         let l:toRemove = []
                                  
   60                 0.000127000         for l:file in l:globList
   60                 0.000309000             let l:tail = fnamemodify(l:file, ':t')
                                  
                                              " If l:file has a trailing slash, then its :tail will be ''. Use
                                              " :h to drop the slash and the empty string after it; then use :t
                                              " to get the directory name.
   60                 0.000092000             if l:tail ==# ''
                                                  let l:tail = fnamemodify(l:file, ':h:t')
   60                 0.000053000             endif
                                  
   60                 0.000146000             if l:tail ==# '.' || l:tail ==# '..'
   60                 0.000215000                 call add(l:toRemove, l:file)
   60                 0.000217000                 if len(l:toRemove) ==# 2
   30                 0.000032000                     break
   30                 0.000032000                 endif
   30                 0.000023000             endif
   60                 0.000076000         endfor
                                  
   90                 0.000119000         for l:file in l:toRemove
   60                 0.000347000             call remove(l:globList, index(l:globList, l:file))
   90                 0.000076000         endfor
   60                 0.000039000     endif
                                  
   60                 0.000095000     return l:globList

FUNCTION  149()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:359
Called 5 times
Total time:   0.013784000
 Self time:   0.000029000

count     total (s)      self (s)
    5   0.013778000   0.000023000     return len(self.getVisibleChildren())

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:227
Called 11 times
Total time:   0.007177000
 Self time:   0.000382000

count     total (s)      self (s)
   11                 0.000017000   let modified_lines = []
   88                 0.000042000   for hunk in a:hunks
   77   0.007040000   0.000245000     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   88                 0.000037000   endfor
   11                 0.000005000   return modified_lines

FUNCTION  airline#extensions#tabline#tabs#map_keys()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/tabs.vim:111
Called 26 times
Total time:   0.001115000
 Self time:   0.001115000

count     total (s)      self (s)
   26                 0.000841000   if maparg('<Plug>AirlineSelectTab1', 'n') is# ':1tabn<CR>'
   25                 0.000013000     return
    1                 0.000001000   endif
    1                 0.000003000   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    1                 0.000002000   if bidx_mode == 1
   11                 0.000012000     for i in range(1, 10)
   10                 0.000154000       exe printf('noremap <silent> <Plug>AirlineSelectTab%d :%dtabn<CR>', i%10, i)
   11                 0.000005000     endfor
                                    else
                                        for i in range(11, 99)
                                          exe printf('noremap <silent> <Plug>AirlineSelectTab%d :%dtabn<CR>', i, i-10)
                                        endfor
    1                 0.000000000     endif
    1                 0.000010000   noremap <silent> <Plug>AirlineSelectPrevTab gT
                                    " tabn {count} goes to count tab does not go {count} tab pages forward!
    1                 0.000016000   noremap <silent> <Plug>AirlineSelectNextTab :<C-U>exe repeat(':tabn\|', v:count1)<cr>

FUNCTION  <SNR>112_search_term()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:20
Called 115 times
Total time:   0.009443000
 Self time:   0.003630000

count     total (s)      self (s)
  115                 0.000655000   let show_search_term = get(g:, 'airline#extensions#searchcount#show_search_term', 1)
  115                 0.000565000   let search_term_limit = get(g:, 'airline#extensions#searchcount#search_term_limit', 8)
                                  
  115                 0.000223000   if show_search_term == 0
                                      return ''
  115                 0.000096000   endif
                                    " shorten for all width smaller than 300 (this is just a guess)
                                    " this uses a non-breaking space, because it looks like
                                    " a leading space is stripped :/
  115   0.007142000   0.001329000   return "\ua0" .  '/' . airline#util#shorten(getreg('/'), 300, search_term_limit)

FUNCTION  <SNR>101_update_hg_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:148
Called 257 times
Total time:   0.015278000
 Self time:   0.012894000

count     total (s)      self (s)
  257   0.003384000   0.001000000   if airline#util#has_lawrencium()
                                      let cmd='LC_ALL=C hg qtop'
                                      let stl=lawrencium#statusline()
                                      let file=expand('%:p')
                                      if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                        if g:airline#init#vim_async
                                          noa call airline#async#get_mq_async(cmd, file)
                                        elseif has("nvim")
                                          noa call airline#async#nvim_get_mq_async(cmd, file)
                                        else
                                          " remove \n at the end of the command
                                          let output=system(cmd)[0:-2]
                                          noa call airline#async#mq_output(output, file)
                                        endif
                                      endif
                                      " do not do mq check anymore
                                      let b:airline_do_mq_check = 0
                                      if exists("b:mq") && !empty(b:mq)
                                        if stl is# 'default'
                                          " Shorten default a bit
                                          let stl='def'
                                        endif
                                        let stl.=' ['.b:mq.']'
                                      endif
                                      let s:vcs_config['mercurial'].branch = stl
  257                 0.000184000   else
  257                 0.000732000     let s:vcs_config['mercurial'].branch = ''
  257                 0.000162000   endif

FUNCTION  <SNR>62_default_layout()
    Defined: ~/.fzf/plugin/fzf.vim:141
Called 2 times
Total time:   0.000106000
 Self time:   0.000059000

count     total (s)      self (s)
    2   0.000101000   0.000054000   return s:popup_support() ? { 'window' : { 'width': 0.9, 'height': 0.6 } } : { 'down': '~40%' }

FUNCTION  airline#extensions#tabline#formatters#tabnr#format()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/tabnr.vim:6
Called 10 times
Total time:   0.000099000
 Self time:   0.000099000

count     total (s)      self (s)
   10                 0.000020000   let spc=g:airline_symbols.space
   10                 0.000028000   let tab_nr_type = get(g:, 'airline#extensions#tabline#tab_nr_type', 0)
   10                 0.000012000   if tab_nr_type == 0 " nr of splits
   10                 0.000034000     return spc. len(tabpagebuflist(a:tab_nr))
                                    elseif tab_nr_type == 1 " tab number
                                      " Return only the current tab number
                                      return spc. a:tab_nr
                                    else " tab_nr_type == 2 splits and tab number
                                      " return the tab number followed by the number of buffers (in the tab)
                                      return spc. a:tab_nr. spc. len(tabpagebuflist(a:tab_nr))
                                    endif

FUNCTION  airline#extensions#tabline#ctrlspace#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/ctrlspace.vim:26
Called 2 times
Total time:   0.000020000
 Self time:   0.000020000

count     total (s)      self (s)
    2                 0.000005000   if !exists('#airline')
                                      return
    2                 0.000001000   endif
    2                 0.000004000   let s:current_bufnr = -1
    2                 0.000003000   let s:current_tabnr = -1

FUNCTION  gitgutter#utility#filename()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:343
Called 2 times
Total time:   0.000091000
 Self time:   0.000008000

count     total (s)      self (s)
    2   0.000090000   0.000007000   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  ale#events#EmulateInsertLeave()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:103
Called 19 times
Total time:   0.001078000
 Self time:   0.001078000

count     total (s)      self (s)
   19                 0.000580000     if mode() is# 'n'
                                          call timer_stop(s:insert_leave_timer)
                                          call ale#Queue(0, '', a:buffer)
   19                 0.000057000     endif

FUNCTION  airline#extensions#tabline#new_builder()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:237
Called 26 times
Total time:   0.002137000
 Self time:   0.001063000

count     total (s)      self (s)
   26                 0.000331000     let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
   26                 0.000059000     if get(g:, 'airline_powerline_fonts', 0)
                                        let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                        let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
   26                 0.000021000     else
   26                 0.000116000       let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
   26                 0.000117000       let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
   26                 0.000017000     endif
                                  
   26   0.001234000   0.000160000     return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  <SNR>37_customOpenDir()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:98
Called 10 times
Total time:   0.651434000
 Self time:   0.000157000

count     total (s)      self (s)
   10   0.651423000   0.000146000     call s:activateDirNode(a:node, s:initCustomOpenArgs().dir)

FUNCTION  go#lsp#message#DidChange()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp/message.vim:180
Called 9 times
Total time:   0.000485000
 Self time:   0.000095000

count     total (s)      self (s)
    9   0.000479000   0.000089000   return { 'notification': 1, 'method': 'textDocument/didChange', 'params': {     'textDocument': {         'uri': go#path#ToURI(a:file),         'version': a:version,     },     'contentChanges': [       {         'text': a:content,       }     ] } }

FUNCTION  go#config#HighlightFunctionCalls()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:427
Called 16 times
Total time:   0.000030000
 Self time:   0.000030000

count     total (s)      self (s)
   16                 0.000027000   return get(g:, 'go_highlight_function_calls', 0)

FUNCTION  airline#section#create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:74
Called 31 times
Total time:   0.006929000
 Self time:   0.000261000

count     total (s)      self (s)
   31   0.006886000   0.000218000   return s:create(a:parts, 0)

FUNCTION  go#util#ClearHighlights()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:606
Called 12 times
Total time:   0.000605000
 Self time:   0.000605000

count     total (s)      self (s)
   12                 0.000089000   if has('textprop')
                                      " the property type may not exist when syntax highlighting is not enabled.
   12                 0.000103000     if empty(prop_type_get(a:group))
                                        return
   12                 0.000011000     endif
   12                 0.000080000     if !has('patch-8.1.1035')
                                        return prop_remove({'type': a:group, 'all': 1}, 1, line('$'))
   12                 0.000010000     endif
   12                 0.000161000     return prop_remove({'type': a:group, 'all': 1})
                                    endif
                                  
                                    if exists("*matchaddpos")
                                      return s:clear_group_from_matches(a:group)
                                    endif

FUNCTION  150()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:368
Called 864 times
Total time:   0.711938000
 Self time:   0.025041000

count     total (s)      self (s)
  864                 0.000707000     let toReturn = []
 3378                 0.003473000     for i in self.children
 2514   0.697027000   0.010130000         if i.path.ignore(self.getNerdtree()) ==# 0
 2199                 0.003584000             call add(toReturn, i)
 2514                 0.001071000         endif
 3378                 0.001500000     endfor
  864                 0.000494000     return toReturn

FUNCTION  152()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:392
Called 832 times
Total time:   0.261538000
 Self time:   0.012045000

count     total (s)      self (s)
  832                 0.000802000     if g:NERDTreeCascadeSingleChildDir ==# 0
                                          return 0
  832                 0.000287000     endif
                                  
  832   0.093976000   0.001361000     if self.isRoot()
   42                 0.000040000         return 0
  790                 0.000264000     endif
                                  
  790                 0.000677000     if self.path.isSymLink
                                          return 0
  790                 0.000246000     endif
                                  
  790   0.004348000   0.001432000     for i in g:NERDTreeBookmark.Bookmarks()
                                          if i.path.equals(self.path)
                                              return 0
                                          endif
  790                 0.000383000     endfor
                                  
  790   0.155440000   0.001478000     let c = self.getVisibleChildren()
  790                 0.001213000     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  154()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:463
Called 147 times
Total time:   0.002750000
 Self time:   0.002750000

count     total (s)      self (s)
  147                 0.000144000     if a:path.isDirectory !=# 1
                                          throw 'NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object.'
  147                 0.000062000     endif
                                  
  147                 0.001359000     let newTreeNode = copy(self)
  147                 0.000156000     let newTreeNode.path = a:path
                                  
  147                 0.000143000     let newTreeNode.isOpen = 0
  147                 0.000139000     let newTreeNode.children = []
                                  
  147                 0.000207000     let newTreeNode.parent = {}
  147                 0.000147000     let newTreeNode._nerdtree = a:nerdtree
                                  
  147                 0.000095000     return newTreeNode

FUNCTION  155()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:484
Called 13 times
Total time:   0.342059000
 Self time:   0.000625000

count     total (s)      self (s)
   13                 0.000030000     let l:options = a:0 ? a:1 : {}
                                  
                                      " If special options were specified, process them and return.
   13                 0.000042000     if has_key(l:options, 'where') && !empty(l:options['where'])
                                          let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                          call l:opener.open(self)
                                          return 0
   13                 0.000007000     endif
                                  
                                      " Open any ancestors of this node that render within the same cascade.
   13                 0.000019000     let l:parent = self.parent
   15   0.001899000   0.000060000     while !empty(l:parent) && !l:parent.isRoot()
    9   0.028811000   0.000136000         if index(l:parent.getCascade(), self) >= 0
    2                 0.000003000             let l:parent.isOpen = 1
    2                 0.000002000             let l:parent = l:parent.parent
    7                 0.000005000         else
    7                 0.000006000             break
    2                 0.000001000         endif
   15                 0.000011000     endwhile
                                  
   13                 0.000016000     let self.isOpen = 1
                                  
   13                 0.000016000     let l:numChildrenCached = 0
   13                 0.000023000     if empty(self.children)
   10   0.310983000   0.000063000         let l:numChildrenCached = self._initChildren(0)
   13                 0.000005000     endif
                                  
   13                 0.000013000     return l:numChildrenCached

FUNCTION  156()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:519
Called 5 times
Total time:   0.088659000
 Self time:   0.000192000

count     total (s)      self (s)
    5                 0.000011000     let opts = a:0 ? a:1 : {}
    5                 0.000008000     let level = 0
                                  
    5                 0.000008000     let node = self
    7                 0.000013000     while node.path.isDirectory
    5   0.073934000   0.000037000         call node.open(opts)
    5                 0.000010000         let level += 1
    5   0.013807000   0.000023000         if node.getVisibleChildCount() ==# 1
    2   0.000799000   0.000013000             let node = node.getChildByIndex(0, 1)
    3                 0.000003000         else
    3                 0.000003000             break
    2                 0.000000000         endif
    7                 0.000009000     endwhile
    5                 0.000005000     return level

FUNCTION  go#util#Exec()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:223
Called 9 times
Total time:  48.518355000
 Self time:   0.000717000

count     total (s)      self (s)
    9                 0.000046000   if len(a:cmd) == 0
                                      call go#util#EchoError("go#util#Exec() called with empty a:cmd")
                                      return ['', 1]
    9                 0.000008000   endif
                                  
    9                 0.000070000   let l:bin = a:cmd[0]
                                  
                                    " Lookup the full path, respecting settings such as 'go_bin_path'. On errors,
                                    " CheckBinPath will show a warning for us.
    9   0.026429000   0.000127000   let l:bin = go#path#CheckBinPath(l:bin)
    9                 0.000032000   if empty(l:bin)
                                      return ['', 1]
    9                 0.000009000   endif
                                  
                                    " Finally execute the command using the full, resolved path. Do not pass the
                                    " unmodified command as the correct program might not exist in $PATH.
    9  48.491608000   0.000272000   return call('s:exec', [[l:bin] + a:cmd[1:]] + a:000)

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 150 times
Total time:   0.082288000
 Self time:   0.006893000

count     total (s)      self (s)
  150                 0.000295000   let winnr = a:context.winnr
  150                 0.000248000   let active = a:context.active
                                  
  150   0.001386000   0.000828000   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
  113   0.028245000   0.000949000     call s:build_sections(a:builder, a:context, s:layout[0])
   37                 0.000025000   else
   37   0.003253000   0.000336000     let text = !empty(s:get_section(winnr, 'c')) ? s:get_section(winnr, 'c') : ' %f%m '
   37   0.000376000   0.000201000     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
  150                 0.000083000   endif
                                  
  150   0.006911000   0.000977000   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                                  
  150   0.000924000   0.000489000   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   96   0.038636000   0.000556000     call s:build_sections(a:builder, a:context, s:layout[1])
  150                 0.000074000   endif
                                  
  150                 0.000160000   return 1

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:21
Called 80 times
Total time:   0.001136000
 Self time:   0.001136000

count     total (s)      self (s)
   80                 0.000530000     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                                  
   80                 0.000402000     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  368()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 12 times
Total time:   0.000263000
 Self time:   0.000108000

count     total (s)      self (s)
   12                 0.000016000     let bufnum = get(self.buffers, a:i, -1)
   12                 0.000009000     if bufnum == -1
                                        return ''
   12                 0.000005000     endif
   12   0.000181000   0.000026000     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
   12                 0.000013000     if bufnum == bufnr('%')
    3                 0.000005000       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
   12                 0.000006000     endif
   12                 0.000005000     return group

FUNCTION  <SNR>142_TempState()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3232
Called 38 times
Total time:   0.004982000
 Self time:   0.000501000

count     total (s)      self (s)
   38   0.004952000   0.000471000   return get(s:temp_files, s:cpath(s:AbsoluteVimPath(a:0 ? a:1 : -1)), {})

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:196
Called 226 times
Total time:   0.007288000
 Self time:   0.004659000

count     total (s)      self (s)
                                    " setting the statusline is disabled,
                                    " either globally, per window, or per buffer
                                    " w:airline_disabled is deprecated!
  226   0.006553000   0.003924000   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  airline#remove_statusline_func()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:38
Called 4 times
Total time:   0.000156000
 Self time:   0.000156000

count     total (s)      self (s)
    4                 0.000087000   let i = index(g:airline_statusline_funcrefs, function(a:name))
    4                 0.000020000   if i > -1
    4                 0.000026000     call remove(g:airline_statusline_funcrefs, i)
    4                 0.000007000   endif

FUNCTION  <SNR>192_sort_buffers()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:803
Called 3 times
Total time:   0.000072000
 Self time:   0.000072000

count     total (s)      self (s)
    3                 0.000061000   let [b1, b2] = map(copy(a:000), 'get(g:fzf#vim#buffers, v:val, v:val)')
                                    " Using minus between a float and a number in a sort function causes an error
    3                 0.000007000   return b1 < b2 ? 1 : -1

FUNCTION  go#list#Type()
    Defined: ~/.vim/plugged/vim-go/autoload/go/list.vim:173
Called 8 times
Total time:   0.000283000
 Self time:   0.000149000

count     total (s)      self (s)
    8   0.000183000   0.000065000   let l:listtype = s:listtype(get(s:default_list_type_commands, a:for))
    8                 0.000008000   if l:listtype == "0"
                                      call go#util#EchoError(printf( "unknown list type command value found ('%s'). Please open a bug report in the vim-go repo.", a:for))
                                      let l:listtype = "quickfix"
    8                 0.000004000   endif
                                  
    8   0.000051000   0.000035000   return get(go#config#ListTypeCommands(), a:for, l:listtype)

FUNCTION  71()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim:30
Called 73 times
Total time:   0.000538000
 Self time:   0.000538000

count     total (s)      self (s)
   73                 0.000482000     return get(s:keyMaps, a:key . a:scope, {})

FUNCTION  72()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim:35
Called 2 times
Total time:   0.002786000
 Self time:   0.000306000

count     total (s)      self (s)
  116                 0.000084000     for i in values(s:keyMaps)
  114   0.002635000   0.000155000         call i.bind()
  116                 0.000049000     endfor

FUNCTION  73()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim:42
Called 114 times
Total time:   0.002480000
 Self time:   0.002480000

count     total (s)      self (s)
                                      " If the key sequence we're trying to map contains any '<>' notation, we
                                      " must replace each of the '<' characters with '<lt>' to ensure the string
                                      " is not translated into its corresponding keycode during the later part
                                      " of the map command below
                                      " :he <>
  114                 0.000126000     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
  114                 0.000262000     if self.key =~# specialNotationRegex
   28                 0.000151000         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
   86                 0.000030000     else
   86                 0.000093000         let keymapInvokeString = self.key
  114                 0.000044000     endif
  114                 0.000177000     let keymapInvokeString = escape(keymapInvokeString, '\"')
                                  
  114                 0.000150000     let premap = self.key ==# '<LeftRelease>' ? ' <LeftRelease>' : ' '
                                  
  114                 0.001056000     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  75()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim:68
Called 38 times
Total time:   1.846786000
 Self time:   0.001264000

count     total (s)      self (s)
   38                 0.000699000     let l:Callback = type(self.callback) ==# type(function('tr')) ? self.callback : function(self.callback)
   38                 0.000049000     if a:0
   31   1.664706000   0.000224000         call l:Callback(a:1)
    7                 0.000004000     else
    7   0.181090000   0.000050000         call l:Callback()
   38                 0.000015000     endif

FUNCTION  76()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim:87
Called 38 times
Total time:   2.176269000
 Self time:   0.003988000

count     total (s)      self (s)
                                  
                                      "required because clicking the command window below another window still
                                      "invokes the <LeftRelease> mapping - but changes the window cursor
                                      "is in first
                                      "
                                      "TODO: remove this check when the vim bug is fixed
   38   0.000924000   0.000417000     if !g:NERDTree.ExistsForBuf()
                                          return {}
   38                 0.000034000     endif
                                  
   38   0.325141000   0.000893000     let node = g:NERDTreeFileNode.GetSelected()
   38                 0.000109000     if !empty(node)
                                  
                                          "try file node
   38                 0.000150000         if !node.path.isDirectory
    3   0.000039000   0.000021000             let km = s:KeyMap.FindFor(a:key, 'FileNode')
    3                 0.000004000             if !empty(km)
                                                  return km.invoke(node)
    3                 0.000003000             endif
   38                 0.000027000         endif
                                  
                                          "try dir node
   38                 0.000054000         if node.path.isDirectory
   35   0.000630000   0.000350000             let km = s:KeyMap.FindFor(a:key, 'DirNode')
   35                 0.000091000             if !empty(km)
   10   0.651825000   0.000097000                 return km.invoke(node)
   25                 0.000023000             endif
   28                 0.000018000         endif
                                  
                                          "try generic node
   28   0.000322000   0.000120000         let km = s:KeyMap.FindFor(a:key, 'Node')
   28                 0.000054000         if !empty(km)
   21   1.014004000   0.000196000             return km.invoke(node)
    7                 0.000002000         endif
                                  
    7                 0.000005000     endif
                                  
                                      "try bookmark
    7   0.000260000   0.000058000     let bm = g:NERDTreeBookmark.GetSelected()
    7                 0.000011000     if !empty(bm)
                                          let km = s:KeyMap.FindFor(a:key, 'Bookmark')
                                          if !empty(km)
                                              return km.invoke(bm)
                                          endif
    7                 0.000003000     endif
                                  
                                      "try all
    7   0.000065000   0.000027000     let km = s:KeyMap.FindFor(a:key, 'all')
    7                 0.000012000     if !empty(km)
    7   0.181298000   0.000048000         return km.invoke()
                                      endif

FUNCTION  go#config#FmtAutosave()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:291
Called 18 times
Total time:   0.000109000
 Self time:   0.000109000

count     total (s)      self (s)
   18                 0.000090000 	return get(g:, "go_fmt_autosave", 1)

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:101
Called 110 times
Total time:   0.001634000
 Self time:   0.001634000

count     total (s)      self (s)
  110                 0.000955000     let l:info = get(g:ale_buffer_info, a:buffer, {})
                                  
  110                 0.000577000     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  gitgutter#git()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:121
Called 24 times
Total time:   0.000151000
 Self time:   0.000151000

count     total (s)      self (s)
   24                 0.000082000   if empty(g:gitgutter_git_args)
   24                 0.000044000     return g:gitgutter_git_executable
                                    else
                                      return g:gitgutter_git_executable.' '.g:gitgutter_git_args
                                    endif

FUNCTION  164()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:629
Called 5 times
Total time:   0.152288000
 Self time:   0.014591000

count     total (s)      self (s)
    5                 0.000005000     let opts = a:0 ? a:1 : {}
                                  
    5   0.000239000   0.000007000     if !a:path.isUnder(self.path)
                                          throw 'NERDTree.InvalidArgumentsError: ' . a:path.str() . ' should be under ' . self.path.str()
    5                 0.000001000     endif
                                  
    5   0.048427000   0.000010000     call self.open()
                                  
    5   0.001113000   0.000031000     if self.path.equals(a:path.getParent())
    2   0.010818000   0.000005000         let n = self.findNode(a:path)
                                          " We may be looking for a newly-saved file that isn't in the tree yet.
    2                 0.000006000         if n ==# {}
                                              call self.refresh()
                                              let n = self.findNode(a:path)
    2                 0.000001000         endif
    2                 0.000002000         if has_key(opts, 'open')
                                              call n.open()
    2                 0.000000000         endif
    2                 0.000006000         return n
    3                 0.000002000     endif
                                  
    3                 0.000002000     let p = a:path
    9   0.001775000   0.000058000     while !p.getParent().equals(self.path)
    6   0.000663000   0.000018000         let p = p.getParent()
    9                 0.000001000     endwhile
                                  
    3   0.008845000   0.000007000     let n = self.findNode(p)
    3                 0.000003000     return n.reveal(a:path, opts)

FUNCTION  166()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:679
Called 30 times
Total time:   0.193082000
 Self time:   0.001847000

count     total (s)      self (s)
   30                 0.000114000     if count(g:NERDTreeSortOrder, '*') < 1
                                          call add(g:NERDTreeSortOrder, '*')
   30                 0.000020000     endif
   30                 0.000139000     let CompareFunc = function('nerdtree#compareNodes')
   30   0.192615000   0.001380000     call sort(self.children, CompareFunc)
   30                 0.000085000     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder

FUNCTION  167()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:690
Called 10 times
Total time:   0.110995000
 Self time:   0.000234000

count     total (s)      self (s)
   10                 0.000023000     let opts = a:0 ? a:1 : {}
   10                 0.000021000     if self.isOpen ==# 1
    5   0.022136000   0.000034000         call self.close()
    5                 0.000004000     else
    5                 0.000012000         if g:NERDTreeCascadeOpenSingleChildDir ==# 0
                                              call self.open(opts)
    5                 0.000002000         else
    5   0.088694000   0.000035000             call self.openAlong(opts)
    5                 0.000003000         endif
   10                 0.000005000     endif

FUNCTION  <SNR>62_fzf_getcwd()
    Defined: ~/.fzf/plugin/fzf.vim:114
Called 8 times
Total time:   0.001105000
 Self time:   0.000053000

count     total (s)      self (s)
    8   0.001102000   0.000050000   return s:fzf_call('getcwd')

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:18
Called 565 times
Total time:   0.127860000
 Self time:   0.059048000

count     total (s)      self (s)
  565                 0.001057000   if v:version < 704
                                      return ''
  565                 0.003190000   elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
  257                 0.000687000     if exists('g:fugitive_event')
                                        return g:fugitive_event
  257                 0.000166000     endif
  257                 0.000772000     let dir = get(b:, 'git_dir', '')
  257                 0.001428000     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
  129   0.099245000   0.031834000       return FugitiveExtractGitDir(getcwd())
  128                 0.001706000     elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
    2   0.000892000   0.000013000       let b:git_dir = FugitiveExtractGitDir(bufnr(''))
    2                 0.000002000       return b:git_dir
  126                 0.000071000     endif
  126                 0.001017000     return dir =~# s:bad_git_dir ? '' : dir
  308                 0.000880000   elseif type(a:1) == type(0) && a:1 isnot# 0
   18                 0.000120000     if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                        let b:git_dir = FugitiveExtractGitDir(a:1)
   18                 0.000010000     endif
   18                 0.000031000     let dir = getbufvar(a:1, 'git_dir')
   18                 0.000078000     return dir =~# s:bad_git_dir ? '' : dir
  290                 0.000697000   elseif type(a:1) == type('')
  290   0.003549000   0.003027000     return substitute(s:Slash(a:1), '/$', '', '')
                                    elseif type(a:1) == type({})
                                      return get(a:1, 'fugitive_dir', get(a:1, 'git_dir', ''))
                                    else
                                      return ''
                                    endif

FUNCTION  370()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 9 times
Total time:   0.000423000
 Self time:   0.000205000

count     total (s)      self (s)
    9                 0.000023000     let bufnum = get(self.buffers, a:i, -1)
    9                 0.000011000     if bufnum == -1
                                        return ''
    9                 0.000002000     endif
    9   0.000294000   0.000076000     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    9                 0.000032000     if bufnum == bufnr('%')
                                        let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    9                 0.000006000     endif
    9                 0.000010000     return group

FUNCTION  372()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 9 times
Total time:   0.000402000
 Self time:   0.000169000

count     total (s)      self (s)
    9                 0.000029000     let bufnum = get(self.buffers, a:i, -1)
    9                 0.000010000     if bufnum == -1
                                        return ''
    9                 0.000006000     endif
    9   0.000278000   0.000045000     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    9                 0.000022000     if bufnum == bufnr('%')
    3                 0.000010000       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    9                 0.000005000     endif
    9                 0.000010000     return group

FUNCTION  <SNR>62_use_sh()
    Defined: ~/.fzf/plugin/fzf.vim:447
Called 4 times
Total time:   0.000222000
 Self time:   0.000208000

count     total (s)      self (s)
    4                 0.000067000   let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
    4                 0.000008000   if s:is_win
                                      set shell=cmd.exe
                                      set noshellslash
                                      let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                      let &shellxquote = has('nvim') ? '"' : '('
    4                 0.000006000   else
    4   0.000055000   0.000041000     set shell=sh
    4                 0.000006000   endif
    4                 0.000022000   return [shell, shellslash, shellcmdflag, shellxquote]

FUNCTION  375()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 4 times
Total time:   0.000211000
 Self time:   0.000066000

count     total (s)      self (s)
    4                 0.000006000     let bufnum = get(self.buffers, a:i, -1)
    4   0.000079000   0.000006000     let group = self.get_group(a:i)
    4   0.000078000   0.000006000     let pgroup = self.get_group(a:i - 1)
                                      " always add a space when powerline_fonts are used
                                      " or for the very first item
    4                 0.000006000     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1                 0.000001000       let space = s:spc
    3                 0.000001000     else
    3                 0.000003000       let space= (pgroup == group ? s:spc : '')
    4                 0.000001000     endif
                                  
    4                 0.000005000     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                        if len(s:number_map) > 0
                                          return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                        else
                                          return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                        endif
    4                 0.000000000     else
    4                 0.000008000       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                      endif

FUNCTION  376()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 9 times
Total time:   0.000387000
 Self time:   0.000166000

count     total (s)      self (s)
    9                 0.000029000     let bufnum = get(self.buffers, a:i, -1)
    9                 0.000010000     if bufnum == -1
                                        return ''
    9                 0.000008000     endif
    9   0.000267000   0.000046000     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
    9                 0.000020000     if bufnum == bufnr('%')
    3                 0.000010000       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    9                 0.000005000     endif
    9                 0.000009000     return group

FUNCTION  <SNR>141_reset_summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 13 times
Total time:   0.000227000
 Self time:   0.000062000

count     total (s)      self (s)
   13   0.000221000   0.000056000   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#extensions#tagbar#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim:23
Called 78 times
Total time:   0.000477000
 Self time:   0.000477000

count     total (s)      self (s)
   78                 0.000285000   if getwinvar(a:2.winnr, '&filetype') == 'tagbar'
                                      return -1
   78                 0.000045000   endif

FUNCTION  airline#extensions#ale#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:77
Called 110 times
Total time:   0.012335000
 Self time:   0.006212000

count     total (s)      self (s)
  110                 0.000341000   if !exists(':ALELint')
                                      return ''
  110                 0.000058000   endif
                                  
  110                 0.000319000   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
  110                 0.000362000   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
  110                 0.000277000   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
  110                 0.000296000   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                                  
  110                 0.000168000   let is_err = a:type ==# 'error'
                                  
  110   0.002255000   0.000621000   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                      return is_err ? '' : checking_symbol
  110                 0.000049000   endif
                                  
  110                 0.000219000   let symbol = is_err ? error_symbol : warning_symbol
                                  
  110   0.003600000   0.000597000   let counts = ale#statusline#Count(bufnr(''))
  110                 0.000392000   if type(counts) == type({}) && has_key(counts, 'error')
                                      " Use the current Dictionary format.
  110                 0.000204000     let errors = counts.error + counts.style_error
  110                 0.000221000     let num = is_err ? errors : counts.total - errors
                                    else
                                      " Use the old List format.
                                      let num = is_err ? counts[0] : counts[1]
  110                 0.000051000   endif
                                  
  110                 0.000135000   if show_line_numbers == 1
  110   0.002404000   0.000918000     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                                    else
                                      return s:airline_ale_count(num, symbol)
                                    endif

FUNCTION  81()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:35
Called 1345 times
Total time:   0.005725000
 Self time:   0.005725000

count     total (s)      self (s)
 1345                 0.002526000     if !exists('g:NERDTreeBookmarks')
                                          let g:NERDTreeBookmarks = []
 1345                 0.000499000     endif
 1345                 0.001078000     return g:NERDTreeBookmarks

FUNCTION  82()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:45
Called 2 times
Total time:   0.000248000
 Self time:   0.000127000

count     total (s)      self (s)
    2                 0.000004000     try
    2   0.000141000   0.000020000         call s:Bookmark.BookmarkFor(a:name)
                                          return 1
    2                 0.000087000     catch /^NERDTree.BookmarkNotFoundError/
    2                 0.000005000         return 0
    2                 0.000003000     endtry

FUNCTION  83()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:57
Called 2 times
Total time:   0.000121000
 Self time:   0.000099000

count     total (s)      self (s)
    2                 0.000006000     let l:result = {}
    2   0.000037000   0.000015000     for l:bookmark in s:Bookmark.Bookmarks()
                                          if l:bookmark.name ==# a:name
                                              let l:result = l:bookmark
                                              break
                                          endif
    2                 0.000002000     endfor
    2                 0.000006000     if empty(l:result)
    1                 2.129560000         throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
                                      endif
                                      return l:result

FUNCTION  <SNR>37_activateDirNode()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:136
Called 10 times
Total time:   0.650760000
 Self time:   0.000234000

count     total (s)      self (s)
                                  
   10   0.002534000   0.000066000     if a:directoryNode.isRoot() && a:directoryNode.isOpen
                                          call nerdtree#echo('cannot close tree root')
                                          return
   10                 0.000006000     endif
                                  
   10   0.648159000   0.000101000     call a:directoryNode.activate((a:0 > 0) ? a:1 : {})

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:44
Called 2094 times
Total time:   0.018610000
 Self time:   0.012708000

count     total (s)      self (s)
 2094   0.011905000   0.006003000   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                      return ''
 2094                 0.001228000   endif
 2094                 0.002197000   return a:text

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 24 times
Total time:   0.000949000
 Self time:   0.000949000

count     total (s)      self (s)
   24                 0.000043000   if g:gitgutter_log
                                      if s:new_log_session && gitgutter#async#available()
                                        if exists('*ch_logfile')
                                          call ch_logfile(s:channel_log, 'w')
                                        endif
                                      endif
                                  
                                      if s:new_log_session
                                        let s:start = reltime()
                                        call writefile(['', '========== start log session '.strftime('%d.%m.%Y %H:%M:%S').' =========='], s:log_file, 'a')
                                      endif
                                  
                                      let elapsed = reltimestr(reltime(s:start)).' '
                                      call writefile([''], s:log_file, 'a')
                                      " callers excluding this function
                                      call writefile([elapsed.expand('<sfile>')[:-22].':'], s:log_file, 'a')
                                      call writefile([elapsed.s:format_for_log(a:message)], s:log_file, 'a')
                                      if a:0 && !empty(a:1)
                                        for msg in a:000
                                          call writefile([elapsed.s:format_for_log(msg)], s:log_file, 'a')
                                        endfor
                                      endif
                                  
                                      let s:new_log_session = 0
   24                 0.000013000   endif

FUNCTION  ale#events#ClockMilliseconds()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:10
Called 1 time
Total time:   0.000011000
 Self time:   0.000011000

count     total (s)      self (s)
    1                 0.000009000     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  go#auto#update_autocmd()
    Defined: ~/.vim/plugged/vim-go/autoload/go/auto.vim:95
Called 9 times
Total time:   0.000321000
 Self time:   0.000234000

count     total (s)      self (s)
    9                 0.000037000   let has_timer = get(b:, 'has_timer')
    9   0.000227000   0.000140000   let should_enable = go#config#AutoTypeInfo() || go#config#AutoSameids()
    9                 0.000025000   if (!has_timer && !should_enable) || (has_timer && should_enable)
    9                 0.000005000     return
                                    endif
                                  
                                    if has_timer
                                      augroup vim-go-buffer-auto
                                        autocmd! * <buffer>
                                      augroup END
                                      let b:has_timer = 0
                                      call s:timer_stop()
                                      return
                                    endif
                                  
                                    augroup vim-go-buffer-auto
                                      autocmd! * <buffer>
                                      autocmd CursorMoved <buffer> call s:timer_restart()
                                      autocmd BufLeave <buffer> call s:timer_stop()
                                    augroup END
                                    let b:has_timer = 1
                                    call s:timer_start()

FUNCTION  nerdtree#echo()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:277
Called 54 times
Total time:   0.393496000
 Self time:   0.393496000

count     total (s)      self (s)
   54                 0.391958000     redraw
   54                 0.001474000     echomsg empty(a:msg) ? '' : ('NERDTree: ' . a:msg)

FUNCTION  <SNR>143_on_exit_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:87
Called 9 times
Total time:   0.000726000
 Self time:   0.000196000

count     total (s)      self (s)
    9                 0.000050000   let buf=self.buf
    9   0.000608000   0.000078000   call s:set_clean_variables(self.file, self.vcs, !empty(buf))
    9                 0.000027000   if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
    9                 0.000021000     call remove(s:clean_jobs[self.vcs], self.file)
    9                 0.000005000   endif

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:169
Called 109 times
Total time:   0.336557000
 Self time:   0.005725000

count     total (s)      self (s)
  109                 0.000546000     let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
  109                 0.000337000     let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                                  
  109                 0.000301000     let curtabcnt = tabpagenr('$')
  109                 0.000254000     if curtabcnt != s:current_tabcnt
    2                 0.000005000       let s:current_tabcnt = curtabcnt
    2   0.000044000   0.000025000       call airline#extensions#tabline#tabs#invalidate()
    2   0.000021000   0.000015000       call airline#extensions#tabline#buffers#invalidate()
    2   0.000036000   0.000016000       call airline#extensions#tabline#ctrlspace#invalidate()
    2   0.000033000   0.000015000       call airline#extensions#tabline#tabws#invalidate()
  109                 0.000090000     endif
                                  
  109                 0.000628000     if !exists('#airline#BufAdd#*')
                                        autocmd airline BufAdd * call <sid>update_tabline(0)
  109                 0.000057000     endif
  109                 0.000362000     if !exists('#airline#SessionLoadPost')
                                        autocmd airline SessionLoadPost * call <sid>update_tabline(1)
  109                 0.000062000     endif
  109                 0.000121000     if s:ctrlspace
                                        return airline#extensions#tabline#ctrlspace#get()
  109                 0.000125000     elseif s:tabws
                                        return airline#extensions#tabline#tabws#get()
  109                 0.000234000     elseif show_buffers && curtabcnt == 1 || !show_tabs
   83   0.241299000   0.000411000       return airline#extensions#tabline#buffers#get()
   26                 0.000016000     else
   26   0.090006000   0.000125000       return airline#extensions#tabline#tabs#get()
                                      endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:97
Called 11 times
Total time:   0.001316000
 Self time:   0.000087000

count     total (s)      self (s)
   11   0.001308000   0.000079000   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  92()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:198
Called 7 times
Total time:   0.000202000
 Self time:   0.000202000

count     total (s)      self (s)
    7                 0.000027000     let line = getline('.')
    7                 0.000084000     let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
    7                 0.000016000     if name !=# line
                                          try
                                              return s:Bookmark.BookmarkFor(name)
                                          catch /^NERDTree.BookmarkNotFoundError/
                                              return {}
                                          endtry
    7                 0.000006000     endif
    7                 0.000008000     return {}

FUNCTION  99()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:287
Called 41 times
Total time:   0.000729000
 Self time:   0.000434000

count     total (s)      self (s)
   41   0.000668000   0.000373000     call sort(s:Bookmark.Bookmarks(), s:Bookmark.CompareBookmarksByName, s:Bookmark)

FUNCTION  <SNR>55_set()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim:153
Called 621 times
Total time:   0.008212000
 Self time:   0.002005000

count     total (s)      self (s)
  621   0.008089000   0.001882000   return call('delimitMate#Set', a:000)

FUNCTION  <SNR>95_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:205
Called 150 times
Total time:   0.885006000
 Self time:   0.009073000

count     total (s)      self (s)
  150   0.004686000   0.000754000   let builder = airline#builder#new(a:context)
  150   0.139040000   0.002239000   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
  150                 0.000197000   if err == 1
  150   0.736219000   0.001019000     let a:context.line = builder.build()
  150                 0.001561000     let s:contexts[a:context.winnr] = a:context
  150                 0.000627000     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
  150                 0.002262000     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
  150                 0.000094000   endif

FUNCTION  <SNR>4_StarSetf()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/filetype.vim:48
Called 1 time
Total time:   0.042860000
 Self time:   0.000024000

count     total (s)      self (s)
    1                 0.000008000   if expand("<amatch>") !~ g:ft_ignore_pat
    1   0.042849000   0.000013000     exe 'setf ' . a:ft
    1                 0.000001000   endif

FUNCTION  184()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:15
Called 2 times
Total time:   0.002925000
 Self time:   0.000139000

count     total (s)      self (s)
    2   0.002793000   0.000007000     call g:NERDTreeKeyMap.BindAll()
                                  
    2                 0.000022000     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
    2                 0.000018000     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
    2                 0.000012000     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
    2                 0.000012000     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
    2                 0.000018000     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
    2                 0.000014000     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
    2                 0.000016000     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
    2                 0.000010000     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
    2                 0.000008000     command! -buffer -nargs=0 EditBookmarks call g:NERDTreeBookmark.Edit()

FUNCTION  185()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:30
Called 2 times
Total time:   0.000008000
 Self time:   0.000008000

count     total (s)      self (s)
    2                 0.000005000     if exists('#User#NERDTreeInit')
                                          doautocmd User NERDTreeInit
    2                 0.000001000     endif

FUNCTION  186()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:37
Called 2 times
Total time:   0.000004000
 Self time:   0.000004000

count     total (s)      self (s)
    2                 0.000002000     return 'NERD_tree_'

FUNCTION  188()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:65
Called 2 times
Total time:   0.410168000
 Self time:   0.000031000

count     total (s)      self (s)
    2   0.000082000   0.000017000     let creator = s:Creator.New()
    2   0.410083000   0.000011000     call creator.createTabTree(a:name)

FUNCTION  189()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:72
Called 2 times
Total time:   0.410072000
 Self time:   0.000140000

count     total (s)      self (s)
    2   0.001165000   0.000036000     let l:path = self._pathForString(a:name)
                                  
                                      " Abort if an exception was thrown (i.e., if the bookmark or directory
                                      " does not exist).
    2                 0.000005000     if empty(l:path)
                                          return
    2                 0.000002000     endif
                                  
                                      " Obey the user's preferences for changing the working directory.
    2                 0.000004000     if g:NERDTreeChDirMode != 0
    2   0.077751000   0.000015000         call l:path.changeToDir()
    2                 0.000002000     endif
                                  
    2   0.000022000   0.000012000     if g:NERDTree.ExistsForTab()
                                          call g:NERDTree.Close()
                                          call self._removeTreeBufForTab()
    2                 0.000002000     endif
                                  
    2   0.080305000   0.000013000     call self._createTreeWin()
    2   0.209795000   0.000010000     call self._createNERDTree(l:path, 'tab')
    2   0.040722000   0.000005000     call b:NERDTree.render()
    2   0.000261000   0.000006000     call b:NERDTree.root.putCursorHere(0, 0)
                                  
    2   0.000013000   0.000005000     call self._broadcastInitEvent()

FUNCTION  <SNR>15_SynSet()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/synload.vim:34
Called 25 times
Total time:   0.163006000
 Self time:   0.015884000

count     total (s)      self (s)
                                    " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   25                 0.000196000   syn clear
   25                 0.000051000   if exists("b:current_syntax")
                                      unlet b:current_syntax
   25                 0.000011000   endif
                                  
   25                 0.000052000   0verbose let s = expand("<amatch>")
   25                 0.000024000   if s == "ON"
                                      " :set syntax=ON
                                      if &filetype == ""
                                        echohl ErrorMsg
                                        echo "filetype unknown"
                                        echohl None
                                      endif
                                      let s = &filetype
   25                 0.000021000   elseif s == "OFF"
                                      let s = ""
   25                 0.000010000   endif
                                  
   25                 0.000020000   if s != ""
                                      " Load the syntax file(s).  When there are several, separated by dots,
                                      " load each in sequence.  Skip empty entries.
   50                 0.000124000     for name in split(s, '\.')
   25                 0.000034000       if !empty(name)
   25   0.162108000   0.014986000 	exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   25                 0.000013000       endif
   50                 0.000036000     endfor
   25                 0.000009000   endif

FUNCTION  <SNR>62_getpos()
    Defined: ~/.fzf/plugin/fzf.vim:769
Called 6 times
Total time:   0.000126000
 Self time:   0.000126000

count     total (s)      self (s)
    6                 0.000116000   return {'tab': tabpagenr(), 'win': winnr(), 'winid': win_getid(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}

FUNCTION  <SNR>143_set_clean_variables()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:67
Called 9 times
Total time:   0.000530000
 Self time:   0.000530000

count     total (s)      self (s)
    9                 0.000201000   let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
    9                 0.000157000   if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') && type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
    9                 0.000015000     let var[a:vcs].dirty=a:val
    9                 0.000006000     try
    9                 0.000094000       call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
    9                 0.000012000       unlet! b:airline_head
                                      catch
    9                 0.000009000     endtry
    9                 0.000003000   endif

FUNCTION  airline#extensions#apply_left_override()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:64
Called 31 times
Total time:   0.007549000
 Self time:   0.000620000

count     total (s)      self (s)
   31                 0.000102000   let w:airline_section_a = a:section1
   31                 0.000080000   let w:airline_section_b = a:section2
   31   0.007143000   0.000214000   let w:airline_section_c = airline#section#create(['readonly'])
   31                 0.000077000   let w:airline_render_left = 1
   31                 0.000076000   let w:airline_render_right = 0

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:84
Called 1754 times
Total time:   0.006252000
 Self time:   0.006252000

count     total (s)      self (s)
 1754                 0.005686000     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>192_check_requirements()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:109
Called 1 time
Total time:   0.371138000
 Self time:   0.000039000

count     total (s)      self (s)
    1                 0.000002000   if s:checked
                                      return
    1                 0.000001000   endif
                                  
    1                 0.000004000   if !exists('*fzf#run')
                                      throw "fzf#run function not found. You also need Vim plugin from the main fzf repository (i.e. junegunn/fzf *and* junegunn/fzf.vim)"
    1                 0.000001000   endif
    1                 0.000003000   if !exists('*fzf#exec')
                                      throw "fzf#exec function not found. You need to upgrade Vim plugin from the main fzf repository ('junegunn/fzf')"
    1                 0.000000000   endif
    1   0.371118000   0.000019000   let s:checked = !empty(fzf#exec(s:min_version))

FUNCTION  airline#extensions#tabline#buffers#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:47
Called 15 times
Total time:   0.000041000
 Self time:   0.000041000

count     total (s)      self (s)
   15                 0.000034000   let s:current_bufnr = -1

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 55 times
Total time:   0.012602000
 Self time:   0.007111000

count     total (s)      self (s)
   55                 0.000191000   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   55                 0.000387000   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                      return ''
   55                 0.000033000   endif
   55                 0.000312000   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                                  
   55                 0.000144000   if !exists('b:airline_whitespace_check')
   15                 0.000026000     let b:airline_whitespace_check = ''
   15                 0.000056000     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                                  
   15                 0.000014000     let trailing = 0
   15                 0.000013000     let check = 'trailing'
   15                 0.000074000     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   15                 0.000004000       try
   15                 0.000046000         let regexp = get(b:, 'airline_whitespace_trailing_regexp', get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$'))
   15                 0.000779000         let trailing = search(regexp, 'nw')
                                        catch
                                          call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                          echomsg v:exception
                                          return ''
   15                 0.000008000       endtry
   15                 0.000011000     endif
                                  
   15                 0.000013000     let mixed = 0
   15                 0.000014000     let check = 'indent'
   15                 0.000055000     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   15   0.002131000   0.000066000       let mixed = s:check_mixed_indent()
   15                 0.000009000     endif
                                  
   15                 0.000017000     let mixed_file = ''
   15                 0.000016000     let check = 'mixed-indent-file'
   15                 0.000071000     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   15   0.000640000   0.000063000       let mixed_file = s:check_mixed_indent_file()
   15                 0.000006000     endif
                                  
   15                 0.000014000     let long = 0
   15                 0.000026000     if index(checks, 'long') > -1 && &tw > 0
                                        let long = search('\%>'.&tw.'v.\+', 'nw')
   15                 0.000008000     endif
                                  
   15                 0.000015000     let conflicts = 0
   15                 0.000021000     if index(checks, 'conflicts') > -1
   15   0.001594000   0.000048000       let conflicts = s:conflict_marker()
   15                 0.000009000     endif
                                  
   15                 0.000049000     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                        let b:airline_whitespace_check = s:symbol
                                        if strlen(s:symbol) > 0
                                          let space = (g:airline_symbols.space)
                                        else
                                          let space = ''
                                        endif
                                  
                                        if s:show_message
                                          if trailing != 0
                                            let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                            let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                          endif
                                          if mixed != 0
                                            let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                            let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                          endif
                                          if long != 0
                                            let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                            let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                          endif
                                          if !empty(mixed_file)
                                            let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                            let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                          endif
                                          if conflicts != 0
                                            let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                            let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                          endif
                                        endif
   15                 0.000006000     endif
   55                 0.000033000   endif
   55   0.001527000   0.000224000   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  ale#statusline#Count()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:119
Called 110 times
Total time:   0.003003000
 Self time:   0.000745000

count     total (s)      self (s)
                                      " The Dictionary is copied here before exposing it to other plugins.
  110   0.002905000   0.000647000     return copy(s:GetCounts(a:buffer))

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 11 times
Total time:   0.000107000
 Self time:   0.000037000

count     total (s)      self (s)
   11   0.000104000   0.000034000   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  ale#events#InsertEnterEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:110
Called 2 times
Total time:   0.000350000
 Self time:   0.000249000

count     total (s)      self (s)
    2                 0.000024000     if g:ale_close_preview_on_insert && exists('*ale#preview#CloseIfTypeMatches')
                                          call ale#preview#CloseIfTypeMatches('ale-preview')
    2                 0.000005000     endif
                                  
                                      " Start a repeating timer if the use might not trigger InsertLeave, so we
                                      " can emulate its behavior.
    2   0.000231000   0.000130000     if ale#Var(a:buffer, 'lint_on_insert_leave')&& maparg("\<C-c>", 'i') isnot# '<Esc>'
    2                 0.000014000         call timer_stop(s:insert_leave_timer)
    2                 0.000046000         let s:insert_leave_timer = timer_start(   100,   {-> ale#events#EmulateInsertLeave(a:buffer) },   {'repeat': -1})
    2                 0.000003000     endif

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:184
Called 633 times
Total time:   0.417107000
 Self time:   0.008420000

count     total (s)      self (s)
  633                 0.003594000     let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  633   0.413205000   0.004518000     call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#extensions#tabline#title()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:199
Called 62 times
Total time:   0.015758000
 Self time:   0.002970000

count     total (s)      self (s)
   62                 0.000087000     let title = ''
   62                 0.000065000     if s:taboo
                                        let title = TabooTabTitle(a:n)
   62                 0.000031000     endif
                                  
   62                 0.000200000     if empty(title) && exists('*gettabvar')
   62                 0.000215000       let title = gettabvar(a:n, 'title')
   62                 0.000034000     endif
                                  
   62                 0.000158000     let formatter = get(g:, 'airline#extensions#tabline#tabtitle_formatter')
   62                 0.000171000     if empty(title) && formatter !=# '' && exists("*".formatter)
                                        let title = call(formatter, [a:n])
   62                 0.000035000     endif
                                  
   62                 0.000100000     if empty(title)
   62                 0.000143000       let buflist = tabpagebuflist(a:n)
   62                 0.000120000       let winnr = tabpagewinnr(a:n)
   62   0.000820000   0.000217000       let all_buffers = airline#extensions#tabline#buflist#list()
   62                 0.000373000       let curbuf = filter(buflist, 'index(all_buffers, v:val) != -1')
   62                 0.000105000       if len(curbuf) ==  0
                                          call add(curbuf, tabpagebuflist(a:n)[0])
   62                 0.000029000       endif
                                        " a:n: -> buffer number
                                        " curbuf: list of buffers in current tabpage
                                        " we need the buffername in current tab page.
   62   0.012472000   0.000287000       return airline#extensions#tabline#get_buffer_name(curbuf[0], curbuf)
                                      endif
                                  
                                      return title

FUNCTION  192()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:133
Called 2 times
Total time:   0.209785000
 Self time:   0.000027000

count     total (s)      self (s)
    2   0.000196000   0.000008000     let b:NERDTree = g:NERDTree.New(a:path, a:type)
                                  
                                      " TODO: This assignment is kept for compatibility reasons.  Many other
                                      " plugins use b:NERDTreeRoot instead of b:NERDTree.root.  Remove this
                                      " assignment in the future.
    2                 0.000003000     let b:NERDTreeRoot = b:NERDTree.root
                                  
    2   0.209580000   0.000010000     call b:NERDTree.root.open()

FUNCTION  195()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:207
Called 2 times
Total time:   0.080292000
 Self time:   0.002775000

count     total (s)      self (s)
    2                 0.000010000     let l:splitLocation = g:NERDTreeWinPos ==# 'left' || g:NERDTreeWinPos ==# 'top' ? 'topleft ' : 'botright '
    2                 0.000007000     let l:splitDirection = g:NERDTreeWinPos ==# 'left' || g:NERDTreeWinPos ==# 'right' ? 'vertical' : ''
    2                 0.000004000     let l:splitSize = g:NERDTreeWinSize
                                  
    2   0.000013000   0.000005000     if !g:NERDTree.ExistsForTab()
    2   0.000100000   0.000012000         let t:NERDTreeBufName = self._nextBufferName('tab')
    2   0.043737000   0.000307000         silent! execute l:splitLocation . l:splitDirection . ' ' . l:splitSize . ' new'
    2   0.013255000   0.002378000         silent! execute 'edit ' . t:NERDTreeBufName
    2                 0.000008000         silent! execute l:splitDirection . ' resize '. l:splitSize
                                      else
                                          silent! execute l:splitLocation . l:splitDirection . ' ' . l:splitSize . ' split'
                                          silent! execute 'buffer ' . t:NERDTreeBufName
    2                 0.000001000     endif
                                  
    2   0.000015000   0.000013000     setlocal winfixwidth
                                  
    2   0.023119000   0.000007000     call self._setCommonBufOptions()
                                  
    2                 0.000004000     if has('patch-7.4.1925')
    2                 0.000003000         clearjumps
    2                 0.000002000     endif
                                  

FUNCTION  197()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:242
Called 3 times
Total time:   0.000099000
 Self time:   0.000099000

count     total (s)      self (s)
    3                 0.000090000     let newCreator = copy(self)
    3                 0.000005000     return newCreator

FUNCTION  198()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:250
Called 2 times
Total time:   0.000088000
 Self time:   0.000049000

count     total (s)      self (s)
    2                 0.000002000     if a:0 > 0
    2                 0.000003000         let type = a:1
                                      else
                                          let type = ''
    2                 0.000002000     end
    2   0.000014000   0.000010000     let name = s:Creator.BufNamePrefix()
    2                 0.000003000     if type ==# 'tab'
    2                 0.000004000         let name = name . 'tab_'
                                      elseif type ==# 'win'
                                          let name = name . 'win_'
    2                 0.000002000     endif
    2   0.000045000   0.000010000     let name = name . self._nextBufferNumber()
    2                 0.000002000     return name

FUNCTION  199()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:268
Called 2 times
Total time:   0.000035000
 Self time:   0.000035000

count     total (s)      self (s)
    2                 0.000008000     if !exists('s:Creator._NextBufNum')
                                          let s:Creator._NextBufNum = 1
    2                 0.000002000     else
    2                 0.000018000         let s:Creator._NextBufNum += 1
    2                 0.000002000     endif
                                  
    2                 0.000002000     return s:Creator._NextBufNum

FUNCTION  airline#themes#patch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:43
Called 2 times
Total time:   0.000698000
 Self time:   0.000698000

count     total (s)      self (s)
   16                 0.000128000     for mode in keys(a:palette)
   14                 0.000026000       if mode == 'accents'
    2                 0.000004000         continue
   12                 0.000010000       endif
   12                 0.000052000       if !has_key(a:palette[mode], 'airline_warning')
                                          let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
   12                 0.000006000       endif
   12                 0.000039000       if !has_key(a:palette[mode], 'airline_error')
                                          let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
   12                 0.000004000       endif
   12                 0.000077000       if !has_key(a:palette[mode], 'airline_term')
                                          let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
   12                 0.000007000       endif
   14                 0.000011000     endfor
                                  
    2                 0.000020000     let a:palette.accents = get(a:palette, 'accents', {})
    2                 0.000053000     let a:palette.accents.none = [ '', '', '', '', '' ]
    2                 0.000008000     let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    2                 0.000017000     let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                                  
    2                 0.000007000     if !has_key(a:palette.accents, 'red')
                                        let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
    2                 0.000002000     endif
    2                 0.000006000     if !has_key(a:palette.accents, 'green')
                                        let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
    2                 0.000001000     endif
    2                 0.000005000     if !has_key(a:palette.accents, 'blue')
                                        let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
    2                 0.000002000     endif
    2                 0.000005000     if !has_key(a:palette.accents, 'yellow')
                                        let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
    2                 0.000001000     endif
    2                 0.000004000     if !has_key(a:palette.accents, 'orange')
                                        let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
    2                 0.000002000     endif
    2                 0.000004000     if !has_key(a:palette.accents, 'purple')
                                        let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
    2                 0.000000000     endif

FUNCTION  <SNR>142_BlameCursorSync()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:7288
Called 22 times
Total time:   0.004825000
 Self time:   0.000446000

count     total (s)      self (s)
   22                 0.000058000   if a:line == line('.')
    8                 0.000005000     return
   14                 0.000013000   endif
   14   0.004567000   0.000188000   if get(s:TempState(), 'origin_bufnr') == a:bufnr || get(s:TempState(a:bufnr), 'origin_bufnr') == bufnr('')
                                      if &startofline
                                        execute a:line
                                      else
                                        let pos = getpos('.')
                                        let pos[1] = a:line
                                        call setpos('.', pos)
                                      endif
   14                 0.000009000   endif

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:88
Called 299 times
Total time:   0.024705000
 Self time:   0.011156000

count     total (s)      self (s)
  299                 0.001525000   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    6                 0.000018000     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                        let b:source_func = 's:get_hunks_signify'
    6                 0.000023000     elseif exists('*GitGutterGetHunkSummary') && get(g:, 'gitgutter_enabled')
    6                 0.000012000       let b:source_func = 's:get_hunks_gitgutter'
                                      elseif exists('*changes#GetStats')
                                        let b:source_func = 's:get_hunks_changes'
                                      elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                        let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                      elseif exists(':Gitsigns')
                                        let b:source_func = 's:get_hunks_gitsigns'
                                      elseif s:coc_git_enabled()
                                        let b:source_func = 's:get_hunks_coc'
                                      else
                                        let b:source_func = 's:get_hunks_empty'
    6                 0.000003000     endif
  299                 0.000167000   endif
  299   0.015889000   0.002340000   return {b:source_func}()

FUNCTION  <SNR>119_has_fresh_changes()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:185
Called 9 times
Total time:   0.000212000
 Self time:   0.000088000

count     total (s)      self (s)
    9   0.000201000   0.000077000   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>90_Filter()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:289
Called 53 times
Total time:   0.001355000
 Self time:   0.001355000

count     total (s)      self (s)
   53                 0.000242000     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                          return 0
   53                 0.000032000     endif
                                  
   53                 0.000165000     if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                          return 0
   53                 0.000025000     endif
                                  
   53                 0.000174000     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                          return 0
   53                 0.000023000     endif
                                  
   53                 0.000102000     for name in g:indentLine_bufNameExclude
                                          if matchstr(bufname(''), name) == bufname('')
                                              return 0
                                          endif
   53                 0.000044000     endfor
                                  
   53                 0.000041000     return 1

FUNCTION  xolox#session#auto_save_periodic()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:486
Called 1 time
Total time:   0.000088000
 Self time:   0.000088000

count     total (s)      self (s)
                                    " Automatically saves the current editing session every few minutes.
                                    " Normally called by the [CursorHold] [] and [CursorHoldI] [] automatic
                                    " command events.
                                    "
                                    " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                                    " [CursorHoldI]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHoldI
    1                 0.000006000   if g:session_autosave_periodic > 0
                                      let interval = g:session_autosave_periodic * 60
                                      let next_save = s:session_last_flushed + interval
                                      if localtime() > next_save
                                        let name = xolox#session#find_current_session()
                                        if !empty(name)
                                          if xolox#session#is_tab_scoped()
                                            let function = 'xolox#session#save_tab_cmd'
                                            let arguments = [name, '', 'SaveTabSession']
                                          else
                                            let function = 'xolox#session#save_cmd'
                                            let arguments = [name, '', 'SaveSession']
                                          endif
                                          if xolox#misc#option#get('session_autosave_silent', 0)
                                            " Silence informational messages perceived as noisy.
                                            " https://github.com/xolox/vim-session/issues/120
                                            silent call call(function, arguments)
                                          else
                                            call call(function, arguments)
                                          endif
                                        endif
                                      endif
    1                 0.000002000   endif

FUNCTION  22()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:393
Called 4650 times
Total time:   0.285718000
 Self time:   0.228990000

count     total (s)      self (s)
 4650                 0.011791000     if !exists('self._sortKey') || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
                                          " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
  449                 0.000477000         let metadata = []
 3143                 0.002729000         for tag in g:NERDTreeSortOrder
 2694                 0.007287000             if tag =~? '\[\[-\?timestamp\]\]'
                                                  let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~# '-' ? -1 : 1)]
 2694                 0.006042000             elseif tag =~? '\[\[-\?size\]\]'
                                                  let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~# '-' ? -1 : 1)]
 2694                 0.006725000             elseif tag =~? '\[\[extension\]\]'
                                                  let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
                                                  let metadata += [self.isDirectory ? '' : (extension ==# '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
 2694                 0.001325000             endif
 3143                 0.001886000         endfor
                                  
  449                 0.001508000         if g:NERDTreeSortOrder[0] =~# '\[\[.*\]\]'
                                              " Apply tags' sorting first if specified first.
                                              let self._sortKey = metadata + [self.getSortOrderIndex()]
  449                 0.000272000         else
                                              " Otherwise, do regex grouping first.
  449   0.054769000   0.001796000             let self._sortKey = [self.getSortOrderIndex()] + metadata
  449                 0.000257000         endif
                                  
  449   0.004828000   0.001073000         let path = self.getLastPathComponent(0)
  449                 0.000487000         if !g:NERDTreeSortHiddenFirst
                                              let path = substitute(path, '^[._]', '', '')
  449                 0.000223000         endif
  449                 0.000450000         if !g:NERDTreeCaseSensitiveSort
  449                 0.000895000             let path = tolower(path)
  449                 0.000224000         endif
                                  
  449                 0.001961000         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
 4650                 0.002054000     endif
 4650                 0.003930000     return self._sortKey

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 44 times
Total time:   0.000883000
 Self time:   0.000227000

count     total (s)      self (s)
   44   0.000426000   0.000078000   let summary = gitgutter#hunk#summary(a:bufnr)
   44                 0.000042000   let summary[1] += a:count
   44   0.000393000   0.000085000   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  23()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:430
Called 2 times
Total time:   0.000123000
 Self time:   0.000031000

count     total (s)      self (s)
                                  
    2   0.000095000   0.000003000     if !self.isUnder(a:path)
                                          return 0
    2                 0.000000000     endif
                                  
    2                 0.000002000     let l:startIndex = len(a:path.pathSegments)
    2                 0.000006000     let l:segments = self.pathSegments[l:startIndex : ]
                                  
    6                 0.000003000     for l:segment in l:segments
                                  
    5                 0.000004000         if l:segment =~# '^\.'
    1                 0.000001000             return 1
    4                 0.000002000         endif
    5                 0.000001000     endfor
                                  
    1                 0.000000000     return 0

FUNCTION  <SNR>142_RunBufDelete()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3647
Called 10 times
Total time:   0.000881000
 Self time:   0.000278000

count     total (s)      self (s)
   10   0.000637000   0.000034000   let state = s:TempState(+a:bufnr)
   10                 0.000019000   if has_key(state, 'job')
                                      try
                                        if type(state.job) == type(0)
                                          call jobstop(state.job)
                                        else
                                          call job_stop(state.job)
                                        endif
                                      catch
                                      endtry
   10                 0.000004000   endif
   10                 0.000024000   if has_key(s:edit_jobs, a:bufnr) |
                                      call add(s:resume_queue, remove(s:edit_jobs, a:bufnr))
                                      call feedkeys("\<C-\>\<C-N>:redraw!|call delete(" . string(s:resume_queue[-1][0].file . '.edit') . ")|call fugitive#Resume()|checktime\r", 'n')
   10                 0.000005000   endif

FUNCTION  ale#Queue()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:137
Called 78 times
Total time:   0.012459000
 Self time:   0.002338000

count     total (s)      self (s)
   78                 0.000183000     if a:0 > 2
                                          throw 'too many arguments!'
   78                 0.000040000     endif
                                  
   78                 0.000253000     let l:buffer = get(a:000, 1, v:null)
                                  
   78                 0.000122000     if l:buffer is v:null
   53                 0.000114000         let l:buffer = bufnr('')
   78                 0.000031000     endif
                                  
   78                 0.000216000     if type(l:buffer) isnot v:t_number
                                          throw 'buffer_number must be a Number'
   78                 0.000034000     endif
                                  
   78   0.004507000   0.000289000     if ale#ShouldDoNothing(l:buffer)
   57                 0.000029000         return
   21                 0.000013000     endif
                                  
                                      " Default linting_flag to ''
   21                 0.000065000     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                                  
   21                 0.000025000     if s:lint_timer != -1
   11                 0.000057000         call timer_stop(s:lint_timer)
   11                 0.000020000         let s:lint_timer = -1
   21                 0.000010000     endif
                                  
   21                 0.000025000     if a:delay > 0
   11                 0.000152000         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
   10                 0.000005000     else
   10   0.005958000   0.000055000         call s:Lint(l:buffer, l:should_lint_file, 0)
   21                 0.000012000     endif

FUNCTION  <SNR>62_popup()
    Defined: ~/.fzf/plugin/fzf.vim:1033
Called 2 times
Total time:   0.000449000
 Self time:   0.000304000

count     total (s)      self (s)
    2                 0.000013000   let xoffset = get(a:opts, 'xoffset', 0.5)
    2                 0.000009000   let yoffset = get(a:opts, 'yoffset', 0.5)
    2                 0.000008000   let relative = get(a:opts, 'relative', 0)
                                  
                                    " Use current window size for positioning relatively positioned popups
    2                 0.000008000   let columns = relative ? winwidth(0) : &columns
    2                 0.000019000   let lines = relative ? winheight(0) : (&lines - has('nvim'))
                                  
                                    " Size and position
    2                 0.000034000   let width = min([max([8, a:opts.width > 1 ? a:opts.width : float2nr(columns * a:opts.width)]), columns])
    2                 0.000025000   let height = min([max([4, a:opts.height > 1 ? a:opts.height : float2nr(lines * a:opts.height)]), lines])
    2                 0.000032000   let row = float2nr(yoffset * (lines - height)) + (relative ? win_screenpos(0)[0] - 1 : 0)
    2                 0.000018000   let col = float2nr(xoffset * (columns - width)) + (relative ? win_screenpos(0)[1] - 1 : 0)
                                  
                                    " Managing the differences
    2                 0.000024000   let row = min([max([0, row]), &lines - has('nvim') - height])
    2                 0.000015000   let col = min([max([0, col]), &columns - width])
    2                 0.000013000   let row += !has('nvim')
    2                 0.000020000   let col += !has('nvim')
                                  
    2   0.000191000   0.000046000   call s:create_popup({ 'row': row, 'col': col, 'width': width, 'height': height })

FUNCTION  218()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:93
Called 12 times
Total time:   0.001932000
 Self time:   0.000254000

count     total (s)      self (s)
   12   0.000769000   0.000056000     call g:NERDTree.MustBeOpen()
   12   0.001146000   0.000181000     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)

FUNCTION  <SNR>62_evaluate_opts()
    Defined: ~/.fzf/plugin/fzf.vim:381
Called 4 times
Total time:   0.001356000
 Self time:   0.000167000

count     total (s)      self (s)
    4   0.001351000   0.000162000   return type(a:options) == type([]) ? join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options

FUNCTION  <SNR>62_compare_binary_versions()
    Defined: ~/.fzf/plugin/fzf.vim:197
Called 2 times
Total time:   0.369752000
 Self time:   0.000096000

count     total (s)      self (s)
    2   0.369749000   0.000093000   return s:compare_versions(s:get_version(a:a), s:get_version(a:b))

FUNCTION  <SNR>117_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 875 times
Total time:   0.039878000
 Self time:   0.039878000

count     total (s)      self (s)
  875                 0.001219000   if a:self._context.active
                                      " active window
  604                 0.000753000     let contents = []
  604                 0.003589000     let content_parts = split(a:contents, '__accent')
 1547                 0.001715000     for cpart in content_parts
  943                 0.005487000       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  943                 0.001940000       call add(contents, cpart)
 1547                 0.001068000     endfor
  604                 0.001608000     let line = join(contents, a:group)
  604                 0.003642000     let line = substitute(line, '__restore__', a:group, 'g')
  271                 0.000174000   else
                                      " inactive window
  271                 0.004927000     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
  271                 0.001980000     let line = substitute(line, '%#__restore__#', '', 'g')
  875                 0.000507000   endif
  875                 0.000875000   return line

FUNCTION  go#config#DiagnosticsLevel()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:564
Called 18 times
Total time:   0.000317000
 Self time:   0.000317000

count     total (s)      self (s)
   18                 0.000052000   let l:default = 0
   18                 0.000100000   if has_key(g:, 'go_diagnostics_enabled') && g:go_diagnostics_enabled
                                      let l:default = 2
   18                 0.000018000   endif
                                  
   18                 0.000077000   return get(g:, 'go_diagnostics_level', l:default)

FUNCTION  airline#highlighter#load_theme()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:165
Called 2 times
Total time:   0.112649000
 Self time:   0.000175000

count     total (s)      self (s)
    2                 0.000014000     if pumvisible()
                                        return
    2                 0.000000000     endif
    4                 0.000033000     for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
    2   0.001017000   0.000029000       call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
    4                 0.000002000     endfor
    2   0.069167000   0.000028000     call airline#highlighter#highlight(['inactive'])
    2                 0.000019000     if getbufvar( bufnr('%'), '&modified'  ) && &buftype != 'terminal'
                                        call airline#highlighter#highlight(['normal', 'modified'])
    2                 0.000001000     else
    2   0.042362000   0.000015000       call airline#highlighter#highlight(['normal'])
    2                 0.000001000     endif

FUNCTION  287()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:96
Called 26 times
Total time:   0.286390000
 Self time:   0.006997000

count     total (s)      self (s)
   26                 0.000126000   if has_key(self, '_left_position') && self._first_title <= self._last_title
   26   0.087692000   0.000259000     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                                  
   26                 0.000085000     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                                  
   26   0.001246000   0.000111000     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
   26   0.001078000   0.000098000     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                                  
   26   0.000389000   0.000114000     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
   26   0.000674000   0.000145000     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                                  
   26                 0.000107000     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
   26   0.001108000   0.000125000     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                      " Allow space for the markers before we begin filling in titles.
   26                 0.000042000     if self._left_title > self._first_title
    9   0.001699000   0.000061000       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
   26                 0.000010000     endif
   26                 0.000042000     if self._left_title < self._last_title
   17   0.007224000   0.000162000       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
   26                 0.000013000     endif
                                  
                                      " Add the current title
   26   0.001286000   0.000176000     let group = self.get_group(self._left_title)
   26                 0.000040000     if self._left_title == self._first_title
   17   0.000562000   0.000107000       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
    9                 0.000006000     else
    9   0.002466000   0.000034000       let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
   26                 0.000014000     endif
   26                 0.000034000     if self._left_title == self._last_title
    9   0.002414000   0.000035000       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
   17                 0.000010000     else
   17   0.006688000   0.000090000       let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
   26                 0.000010000     endif
   26                 0.000040000     let left_group = group
   26                 0.000038000     let right_group = group
   26   0.011099000   0.000155000     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                                  
   26                 0.000058000     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                        " always have current title first
                                        let self._left_position += 1
   26                 0.000012000     endif
                                  
   26                 0.000052000     if !center_active && self._right_title <= self._last_title
                                        " Add the title to the right
   17   0.000684000   0.000053000       let group = self.get_group(self._right_title)
   17                 0.000025000       if self._right_title == self._last_title
                                          let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
   17                 0.000009000       else
   17   0.011971000   0.000095000         let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
   17                 0.000007000       endif
   17                 0.000023000       let right_group = group
   17   0.005038000   0.000088000       let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
   26                 0.000018000     endif
                                  
   60                 0.000089000     while self._remaining_space > 0
   60                 0.000056000       let done = 0
   60                 0.000069000       if self._left_title >= self._first_title
                                          " Insert next title to the left
   17   0.000390000   0.000039000         let group = self.get_group(self._left_title)
   17                 0.000018000         if self._left_title == self._first_title
    9   0.005176000   0.000046000           let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
    8                 0.000003000         else
    8   0.001649000   0.000024000           let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
   17                 0.000006000         endif
   17                 0.000017000         let left_group = group
   17   0.003829000   0.000055000         let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
   17                 0.000014000         let self._left_title -= done
   60                 0.000030000       endif
                                        " If center_active is set, this |if| operates as an independent |if|,
                                        " otherwise as an |elif|.
   60                 0.000121000       if self._right_title <= self._last_title && (center_active || !done)
                                          " Insert next title to the right
   17   0.000722000   0.000071000         let group = self.get_group(self._right_title)
   17                 0.000025000         if self._right_title == self._last_title
   17   0.006485000   0.000143000           let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                          else
                                            let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
   17                 0.000009000         endif
   17                 0.000023000         let right_group = group
   17   0.006515000   0.000088000         let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
   17                 0.000026000         let self._right_title += done
   60                 0.000026000       endif
   60                 0.000074000       if !done
   26                 0.000014000         break
   34                 0.000029000       endif
   60                 0.000061000     endwhile
                                  
   26                 0.000035000     if self._left_title >= self._first_title
                                        if get(g:, 'airline#extensions#tabline#current_first', 0)
                                          let self._left_position -= 1
                                        endif
                                        call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                        let self._right_position += 1
   26                 0.000016000     endif
                                  
   26                 0.000025000     if self._right_title <= self._last_title
                                        call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
   26                 0.000009000     endif
   26                 0.000015000   endif
                                  
   26   0.113777000   0.000094000   return self._build()

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:179
Called 72 times
Total time:   0.364793000
 Self time:   0.006199000

count     total (s)      self (s)
   72   0.001871000   0.000250000   if airline#util#stl_disabled(winnr())
                                      return
   72                 0.000035000   endif
  150                 0.000329000   for nr in a:range
   78   0.002433000   0.000289000     if airline#util#stl_disabled(nr)
                                        continue
   78                 0.000046000     endif
   78                 0.000334000     call setwinvar(nr, 'airline_active', 0)
   78                 0.000566000     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   78                 0.000280000     if get(g:, 'airline_inactive_alt_sep', 0)
                                        call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
   78                 0.000052000     endif
   78                 0.000067000     try
   78   0.355825000   0.000996000       call s:invoke_funcrefs(context, g:airline_inactive_funcrefs)
                                      catch /^Vim\%((\a\+)\)\=:E48:/
                                        " Catch: Sandbox mode
                                        " no-op
   78                 0.000081000     endtry
  150                 0.000209000   endfor

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:202
Called 15317 times
Total time:   0.086252000
 Self time:   0.086252000

count     total (s)      self (s)
15317                 0.081381000     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>74_system()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:181
Called 9 times
Total time:  48.488685000
 Self time:   0.004011000

count     total (s)      self (s)
                                    " Preserve original shell, shellredir and shellcmdflag values
    9                 0.000025000   let l:shell = &shell
    9                 0.000028000   let l:shellredir = &shellredir
    9                 0.000025000   let l:shellcmdflag = &shellcmdflag
    9                 0.000022000   let l:shellquote = &shellquote
    9                 0.000029000   let l:shellxquote = &shellxquote
                                  
    9   0.000365000   0.000334000   if !go#util#IsWin() && executable('/bin/sh')
    9                 0.000110000       set shell=/bin/sh shellredir=>%s\ 2>&1 shellcmdflag=-c
    9                 0.000009000   endif
                                  
    9   0.000074000   0.000040000   if go#util#IsWin()
                                      if executable($COMSPEC)
                                        let &shell = $COMSPEC
                                        set shellcmdflag=/C
                                        set shellquote&
                                        set shellxquote&
                                      endif
    9                 0.000008000   endif
                                  
    9                 0.000010000   try
    9  48.487176000   0.002567000     return call('system', [a:cmd] + a:000)
    9                 0.000082000   finally
                                      " Restore original values
    9                 0.000177000     let &shell = l:shell
    9                 0.000026000     let &shellredir = l:shellredir
    9                 0.000023000     let &shellcmdflag = l:shellcmdflag
    9                 0.000027000     let &shellquote = l:shellquote
    9                 0.000024000     let &shellxquote = l:shellxquote
    9                 0.000147000   endtry

FUNCTION  ale#events#FileTypeEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:69
Called 17 times
Total time:   0.000425000
 Self time:   0.000235000

count     total (s)      self (s)
                                      " The old filetype will be set to an empty string by the BuFEnter event,
                                      " and not linting when the old filetype hasn't been set yet prevents
                                      " buffers being checked when you enter them when linting on enter is off.
   17                 0.000052000     let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                                  
   17                 0.000044000     if l:old_filetype isnot v:null&& !empty(a:new_filetype)&& a:new_filetype isnot# l:old_filetype
                                          " Remember what the new filetype is.
    6                 0.000017000         call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                                  
    6                 0.000006000         if g:ale_lint_on_filetype_changed
    6   0.000205000   0.000015000             call ale#Queue(300, 'lint_file', a:buffer)
    6                 0.000002000         endif
   17                 0.000009000     endif

FUNCTION  <SNR>114_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:108
Called 4475 times
Total time:   0.080343000
 Self time:   0.080343000

count     total (s)      self (s)
                                      " Checks, whether the definition of the colors is valid and is not empty or NONE
                                      " e.g. if the colors would expand to this:
                                      " hi airline_c ctermfg=NONE ctermbg=NONE
                                      " that means to clear that highlighting group, therefore, fallback to Normal
                                      " highlighting group for the cterm values
                                  
                                      " This only works, if the Normal highlighting group is actually defined, so
                                      " return early, if it has been cleared
 4475                 0.011532000     if !exists("g:airline#highlighter#normal_fg_hi")
                                        let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
 4475                 0.002047000     endif
 4475                 0.011262000     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                        return a:colors
 4475                 0.001871000     endif
                                  
 4475                 0.007191000     for val in a:colors
 4475                 0.008368000       if !empty(val) && val !=# 'NONE'
 4475                 0.004144000         return a:colors
                                        endif
                                      endfor
                                      " this adds the bold attribute to the term argument of the :hi command,
                                      " but at least this makes sure, the group will be defined
                                      let fg = g:airline#highlighter#normal_fg_hi
                                      let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                      if empty(bg) || bg < 0
                                        " in case there is no background color defined for Normal
                                        let bg = a:colors[3]
                                      endif
                                      return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>101_update_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:202
Called 257 times
Total time:   0.070370000
 Self time:   0.046757000

count     total (s)      self (s)
  257                 0.034021000   let file = expand("%:p")
  257                 0.002280000   if empty(file) || isdirectory(file) || !empty(&buftype)
  129                 0.000145000     return
  128                 0.000082000   endif
                                  
  128                 0.000236000   let needs_update = 1
  128                 0.000645000   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  384                 0.000683000   for vcs in keys(s:vcs_config)
  256                 0.001306000     if file =~ s:vcs_config[vcs].exclude
                                        " Skip check for files that live in the exclude directory
                                        let needs_update = 0
  256                 0.000202000     endif
  256                 0.000923000     if has_key(s:vcs_config[vcs].untracked, file)
  108                 0.000164000       let needs_update = 0
  108   0.002554000   0.000739000       call airline#extensions#branch#update_untracked_config(file, vcs)
  256                 0.000144000     endif
  384                 0.000316000   endfor
                                  
  128                 0.000163000   if !needs_update
  108                 0.000083000     return
   20                 0.000007000   endif
                                  
   60                 0.000068000   for vcs in keys(s:vcs_config)
                                      " only check, for git, if fugitive is installed
                                      " and for 'hg' if lawrencium is installed, else skip
   40   0.000184000   0.000105000     if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                        continue
   40   0.000446000   0.000162000     elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
   20                 0.000014000       continue
   20                 0.000006000     endif
   20                 0.000020000     let config = s:vcs_config[vcs]
                                      " Note that asynchronous update updates s:vcs_config only, and only
                                      " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                      " invalidated again before s:update_untracked is called, then we lose the
                                      " result of the previous call, i.e. the head string is not updated. It
                                      " doesn't happen often in practice, so we let it be.
   20                 0.000033000     if index(vcs_checks, 'untracked') > -1
   20   0.016039000   0.000160000       call airline#async#vcs_untracked(config, file, vcs)
   20                 0.000024000     endif
                                      " Check clean state of repo
   20                 0.000038000     if index(vcs_checks, 'dirty') > -1
   20   0.005730000   0.000174000       call airline#async#vcs_clean(config.dirty, file, vcs)
   20                 0.000240000     endif
   40                 0.000100000   endfor

FUNCTION  go#config#HighlightGenerateTags()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:451
Called 16 times
Total time:   0.000044000
 Self time:   0.000044000

count     total (s)      self (s)
   16                 0.000036000   return get(g:, 'go_highlight_generate_tags', 0)

FUNCTION  gitgutter#all()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 12 times
Total time:   0.119719000
 Self time:   0.008461000

count     total (s)      self (s)
   12                 0.000109000   let visible = tabpagebuflist()
                                  
  116                 0.000476000   for bufnr in range(1, bufnr('$') + 1)
  104                 0.000359000     if buflisted(bufnr)
   31                 0.004523000       let file = expand('#'.bufnr.':p')
   31                 0.000387000       if !empty(file)
   21                 0.000185000         if index(visible, bufnr) != -1
   11   0.111008000   0.000414000           call gitgutter#process_buffer(bufnr, a:force)
   10                 0.000017000         elseif a:force
    8   0.000784000   0.000120000           call s:reset_tick(bufnr)
   21                 0.000019000         endif
   31                 0.000022000       endif
  104                 0.000097000     endif
  116                 0.000251000   endfor

FUNCTION  <SNR>142_FileIgnoreCase()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:216
Called 48 times
Total time:   0.000287000
 Self time:   0.000287000

count     total (s)      self (s)
   48                 0.000264000   return (exists('+fileignorecase') && &fileignorecase) || (a:for_completion && exists('+wildignorecase') && &wildignorecase)

FUNCTION  285()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:18
Called 26 times
Total time:   0.000536000
 Self time:   0.000428000

count     total (s)      self (s)
   26                 0.000076000   let self._first_title = a:first " lowest index
   26                 0.000044000   let self._last_title = a:last " highest index
   26                 0.000041000   let self._left_title = a:current " next index to add on the left
   26                 0.000055000   let self._right_title = a:current + 1 " next index to add on the right
   26   0.000214000   0.000106000   let self._left_position = self.get_position() " left end of titles
   26                 0.000049000   let self._right_position = self._left_position " right end of the titles

FUNCTION  <SNR>142_can_diffoff()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:6444
Called 19 times
Total time:   0.000177000
 Self time:   0.000177000

count     total (s)      self (s)
   19                 0.000157000   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:39
Called 78 times
Total time:   0.002173000
 Self time:   0.002173000

count     total (s)      self (s)
   78                 0.000320000   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                      let sections = s:GetAirlineSection()
                                      let spc = g:airline_symbols.space
                                      call a:1.add_section_spaced('airline_a', sections[0])
                                      call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                      call a:1.add_section('airline_term', spc.s:termname(a:2.bufnr))
                                      call a:1.split()
                                      call a:1.add_section('airline_y', '')
                                      call a:1.add_section_spaced('airline_z', sections[1])
                                      return 1
   78                 0.000047000   endif

FUNCTION  airline#async#vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:95
Called 20 times
Total time:   0.005556000
 Self time:   0.000455000

count     total (s)      self (s)
   20                 0.000041000   if g:airline#init#vim_async
                                      " Vim 8 with async support
   20   0.005346000   0.000245000     noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
                                    elseif has("nvim")
                                      " nvim async
                                      noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                                    else
                                      " Vim pre 8 using system()
                                      call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
   20                 0.000007000   endif

FUNCTION  go#config#GoplsEnabled()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:554
Called 27 times
Total time:   0.000133000
 Self time:   0.000133000

count     total (s)      self (s)
   27                 0.000106000   return get(g:, 'go_gopls_enabled', 1)

FUNCTION  <SNR>172_process_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:236
Called 77 times
Total time:   0.006795000
 Self time:   0.002648000

count     total (s)      self (s)
   77                 0.000069000   let modifications = []
   77                 0.000081000   let from_line  = a:hunk[0]
   77                 0.000070000   let from_count = a:hunk[1]
   77                 0.000071000   let to_line    = a:hunk[2]
   77                 0.000071000   let to_count   = a:hunk[3]
                                  
   77   0.000253000   0.000151000   if s:is_added(from_count, to_count)
                                      call s:process_added(modifications, from_count, to_count, to_line)
                                      call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                                  
   77   0.000229000   0.000134000   elseif s:is_removed(from_count, to_count)
   33   0.000256000   0.000094000     call s:process_removed(modifications, from_count, to_count, to_line)
   33   0.000850000   0.000076000     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                                  
   44   0.000164000   0.000086000   elseif s:is_modified(from_count, to_count)
   11   0.000145000   0.000039000     call s:process_modified(modifications, from_count, to_count, to_line)
   11   0.000239000   0.000019000     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                  
   33   0.000127000   0.000071000   elseif s:is_modified_and_added(from_count, to_count)
   22   0.001102000   0.000070000     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
   22   0.000537000   0.000067000     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
   22   0.000470000   0.000039000     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                                  
   11   0.000050000   0.000026000   elseif s:is_modified_and_removed(from_count, to_count)
   11   0.000194000   0.000046000     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
   11   0.000262000   0.000030000     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
   11   0.000242000   0.000025000     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                                  
   77                 0.000026000   endif
   77                 0.000044000   return modifications

FUNCTION  374()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 12 times
Total time:   0.000223000
 Self time:   0.000092000

count     total (s)      self (s)
   12                 0.000015000     let bufnum = get(self.buffers, a:i, -1)
   12                 0.000006000     if bufnum == -1
                                        return ''
   12                 0.000005000     endif
   12   0.000152000   0.000021000     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
   12                 0.000012000     if bufnum == bufnr('%')
    3                 0.000004000       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
   12                 0.000003000     endif
   12                 0.000006000     return group

FUNCTION  go#config#HighlightVariableDeclarations()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:459
Called 16 times
Total time:   0.000032000
 Self time:   0.000032000

count     total (s)      self (s)
   16                 0.000029000   return get(g:, 'go_highlight_variable_declarations', 0)

FUNCTION  <SNR>142_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:593
Called 18 times
Total time:   0.000809000
 Self time:   0.000051000

count     total (s)      self (s)
   18   0.000808000   0.000050000   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  <SNR>44_on_focus_gained()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:77
Called 13 times
Total time:   0.183801000
 Self time:   0.001210000

count     total (s)      self (s)
   13                 0.000424000   if &eventignore =~? 'focusgained'
                                      return
   13                 0.000013000   endif
                                  
   13   0.000520000   0.000186000   if airline#util#try_focusgained()
   13   0.182667000   0.000410000     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
   13                 0.000007000   endif

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:255
Called 84 times
Total time:   1.472348000
 Self time:   0.160200000

count     total (s)      self (s)
   84                 0.000186000     let bufnr = a:0 ? a:1 : ''
   84                 0.000247000     let p = g:airline#themes#{g:airline_theme}#palette
                                  
                                      " draw the base mode, followed by any overrides
   84                 0.002749000     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   84                 0.000234000     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   84                 0.000124000     let airline_grouplist = []
   84                 0.000560000     let buffers_in_tabpage = sort(tabpagebuflist())
   84                 0.000210000     if exists("*uniq")
   84                 0.000257000       let buffers_in_tabpage = uniq(buffers_in_tabpage)
   84                 0.000049000     endif
                                      " mapped might be something like ['normal', 'normal_modified']
                                      " if a group is in both modes available, only define the second
                                      " that is how this was done previously overwrite the previous definition
  191                 0.000429000     for mode in reverse(mapped)
  107                 0.000509000       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   64                 0.000176000         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
 2283                 0.004150000         for kvp in items(dict)
 2219                 0.003622000           let mode_colors = kvp[1]
 2219                 0.003050000           let name = kvp[0]
 2219                 0.004573000           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
   12                 0.000012000             let name = 'airline_c'.bufnr
 2219                 0.001023000           endif
                                            " do not re-create highlighting for buffers that are no longer visible
                                            " in the current tabpage
 2219                 0.011119000           if name =~# 'airline_c\d\+'
  305                 0.002274000             let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
  305                 0.000831000             if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
  192                 0.000145000               continue
  113                 0.000058000             endif
 1914                 0.007657000           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                              " group will be redefined below at exec_separator
                                              " or is not needed for tabline with '_inactive' suffix
                                              " since active flag is 1 for builder)
 1350                 0.000888000             continue
  677                 0.000297000           endif
  677   0.006744000   0.002618000           if s:group_not_done(airline_grouplist, name.suffix)
  677   0.172322000   0.002718000             call airline#highlighter#exec(name.suffix, mode_colors)
  677                 0.000325000           endif
                                  
  677                 0.001254000           if !has_key(p, 'accents')
                                              " work around a broken installation
                                              " shouldn't actually happen, p should always contain accents
                                              continue
  677                 0.000320000           endif
                                  
 2031                 0.002934000           for accent in keys(s:accents)
 1354                 0.002754000             if !has_key(p.accents, accent)
                                                continue
 1354                 0.000592000             endif
 1354                 0.003003000             let colors = copy(mode_colors)
 1354                 0.002888000             if p.accents[accent][0] != ''
  677                 0.001580000               let colors[0] = p.accents[accent][0]
 1354                 0.000654000             endif
 1354                 0.002337000             if p.accents[accent][2] != ''
  677                 0.001377000               let colors[2] = p.accents[accent][2]
 1354                 0.000564000             endif
 1354                 0.001918000             if len(colors) >= 5
 1354                 0.003702000               let colors[4] = get(p.accents[accent], 4, '')
                                              else
                                                call add(colors, get(p.accents[accent], 4, ''))
 1354                 0.000609000             endif
 1354   0.012966000   0.005465000             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
 1354   0.337207000   0.005776000               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
 1354                 0.000695000             endif
 2031                 0.001179000           endfor
  741                 0.000525000         endfor
                                  
   64                 0.000143000         if empty(s:separators)
                                            " nothing to be done
                                            continue
   64                 0.000028000         endif
                                          " TODO: optimize this
 1765                 0.002758000         for sep in items(s:separators)
                                            " we cannot check, that the group already exists, else the separators
                                            " might not be correctly defined. But perhaps we can skip above groups
                                            " that match the '_to_' name, because they would be redefined here...
 1701   0.809741000   0.010255000           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
 1765                 0.000857000         endfor
  107                 0.000062000       endif
  191                 0.000321000     endfor

FUNCTION  <SNR>192_get_color()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:280
Called 10 times
Total time:   0.000645000
 Self time:   0.000645000

count     total (s)      self (s)
   10                 0.000066000   let gui = has('termguicolors') && &termguicolors
   10                 0.000025000   let fam = gui ? 'gui' : 'cterm'
   10                 0.000024000   let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
   15                 0.000036000   for group in a:000
   10                 0.000300000     let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
   10                 0.000087000     if code =~? pat
    5                 0.000008000       return code
    5                 0.000006000     endif
   10                 0.000013000   endfor
    5                 0.000006000   return ''

FUNCTION  117()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:173
Called 45 times
Total time:   0.367130000
 Self time:   0.001908000

count     total (s)      self (s)
                                  
   45                 0.000081000     try
   45   0.057878000   0.000707000         let l:path = b:NERDTree.ui.getPath(line('.'))
                                  
   45                 0.000137000         if empty(l:path)
                                              return {}
   45                 0.000041000         endif
                                  
   45   0.308497000   0.000446000         return b:NERDTree.root.findNode(l:path)
                                      catch
                                          return {}
   45                 0.000088000     endtry

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:198
Called 385 times
Total time:   0.008629000
 Self time:   0.008629000

count     total (s)      self (s)
  385                 0.001498000   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  385                 0.000812000   let bomb     = &bomb ? '[BOM]' : ''
  385                 0.000936000   let noeolf   = &eol ? '' : '[!EOL]'
  385                 0.001852000   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  385                 0.001308000   if expected is# &fenc.bomb.noeolf.ff
                                      return ''
  385                 0.000265000   else
  385                 0.000883000     return &fenc.bomb.noeolf.ff
                                    endif

FUNCTION  377()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 3 times
Total time:   0.000359000
 Self time:   0.000112000

count     total (s)      self (s)
    3                 0.000009000     let bufnum = get(self.buffers, a:i, -1)
    3   0.000137000   0.000010000     let group = self.get_group(a:i)
    3   0.000130000   0.000010000     let pgroup = self.get_group(a:i - 1)
                                      " always add a space when powerline_fonts are used
                                      " or for the very first item
    3                 0.000009000     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1                 0.000001000       let space = s:spc
    2                 0.000001000     else
    2                 0.000006000       let space= (pgroup == group ? s:spc : '')
    3                 0.000002000     endif
                                  
    3                 0.000008000     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                        if len(s:number_map) > 0
                                          return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                        else
                                          return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                        endif
    3                 0.000002000     else
    3                 0.000012000       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                      endif

FUNCTION  FugitiveCommonDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:285
Called 9 times
Total time:   0.000414000
 Self time:   0.000079000

count     total (s)      self (s)
    9   0.000358000   0.000023000   let dir = call('FugitiveActualDir', a:000)
    9                 0.000008000   if empty(dir)
                                      return ''
    9                 0.000003000   endif
    9                 0.000027000   if has_key(s:commondirs, dir)
    9                 0.000010000     return s:commondirs[dir]
                                    endif
                                    if getfsize(dir . '/HEAD') >= 10
                                      let cdir = get(s:ReadFile(dir . '/commondir', 1), 0, '')
                                      if cdir =~# '^/\|^\a:/'
                                        let s:commondirs[dir] = s:Slash(FugitiveVimPath(cdir))
                                      elseif len(cdir)
                                        let s:commondirs[dir] = simplify(dir . '/' . cdir)
                                      else
                                        let s:commondirs[dir] = dir
                                      endif
                                    else
                                      let s:commondirs[dir] = dir
                                    endif
                                    return s:commondirs[dir]

FUNCTION  <SNR>104_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:186
Called 10 times
Total time:   0.072359000
 Self time:   0.000233000

count     total (s)      self (s)
   10                 0.000025000   if !exists('#airline')
                                      " airline disabled
                                      return
   10                 0.000005000   endif
   10                 0.000028000   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    1                 0.000001000     return
    9                 0.000006000   endif
    9                 0.000012000   unlet! b:airline_whitespace_check
    9                 0.000026000   if get(g:, 'airline_skip_empty_sections', 0)
    9   0.072203000   0.000077000     exe ':AirlineRefresh!'
    9                 0.000002000   endif
    9                 0.000016000   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>55_get()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim:148
Called 924 times
Total time:   0.014664000
 Self time:   0.003776000

count     total (s)      self (s)
  924   0.012805000   0.001917000   let bufoptions = delimitMate#Get()
  924                 0.001601000   return get(bufoptions, a:name, a:default)

FUNCTION  <SNR>114_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:99
Called 4275 times
Total time:   0.052703000
 Self time:   0.052703000

count     total (s)      self (s)
 4275                 0.015818000     if !hlexists(a:group)
                                        return 0
 4275                 0.023476000     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                        return 0
 4275                 0.001828000     endif
 4275                 0.002730000     return 1

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:82
Called 58 times
Total time:   0.001617000
 Self time:   0.001485000

count     total (s)      self (s)
   58                 0.001125000   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   47                 0.000068000     return a:arg
   11   0.000206000   0.000074000   elseif s:winshell()
                                      return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
   11                 0.000008000   else
   11                 0.000056000     return shellescape(a:arg)
                                    endif

FUNCTION  <SNR>192_extend_opts()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:123
Called 2 times
Total time:   0.000093000
 Self time:   0.000093000

count     total (s)      self (s)
    2                 0.000006000   if empty(a:eopts)
                                      return
    2                 0.000002000   endif
    2                 0.000006000   if has_key(a:dict, 'options')
    1                 0.000007000     if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
    1                 0.000001000       if a:prepend
                                          let a:dict.options = extend(copy(a:eopts), a:dict.options)
    1                 0.000001000       else
    1                 0.000005000         call extend(a:dict.options, a:eopts)
    1                 0.000001000       endif
                                      else
                                        let all_opts = a:prepend ? [a:eopts, a:dict.options] : [a:dict.options, a:eopts]
                                        let a:dict.options = join(map(all_opts, 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
    1                 0.000001000     endif
    1                 0.000001000   else
    1                 0.000005000     let a:dict.options = a:eopts
    2                 0.000002000   endif

FUNCTION  <SNR>44_airline_refresh()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:226
Called 32 times
Total time:   0.357639000
 Self time:   0.001659000

count     total (s)      self (s)
                                    " a:1, fast refresh, do not reload the theme
   32                 0.000174000   let fast=!empty(get(a:000, 0, 0))
   32                 0.000138000   if !exists("#airline")
                                      " disabled
                                      return
   32                 0.000018000   endif
   32   0.004830000   0.000217000   call airline#util#doautocmd('AirlineBeforeRefresh')
   32   0.006096000   0.000250000   call airline#highlighter#reset_hlcache()
   32                 0.000114000   if !fast
                                      call airline#load_theme()
   32                 0.000021000   endif
   32   0.345684000   0.000320000   call airline#update_statusline()
   32   0.000253000   0.000096000   call airline#update_tabline()

FUNCTION  378()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:86
Called 12 times
Total time:   0.000232000
 Self time:   0.000097000

count     total (s)      self (s)
   12                 0.000018000     let bufnum = get(self.buffers, a:i, -1)
   12                 0.000006000     if bufnum == -1
                                        return ''
   12                 0.000002000     endif
   12   0.000161000   0.000026000     let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
   12                 0.000010000     if bufnum == bufnr('%')
    3                 0.000004000       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
   12                 0.000003000     endif
   12                 0.000006000     return group

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:138
Called 317 times
Total time:   0.009176000
 Self time:   0.009176000

count     total (s)      self (s)
  317                 0.002205000   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  317                 0.006382000   return match(a:name, pat) > -1

FUNCTION  go#config#FmtFailSilently()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:351
Called 1 time
Total time:   0.000009000
 Self time:   0.000009000

count     total (s)      self (s)
    1                 0.000007000   return get(g:, "go_fmt_fail_silently", 0)

FUNCTION  <SNR>119_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:179
Called 21 times
Total time:   0.005959000
 Self time:   0.000239000

count     total (s)      self (s)
   21   0.000927000   0.000157000   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                                  
    2   0.004999000   0.000049000   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 13 times
Total time:   0.000047000
 Self time:   0.000047000

count     total (s)      self (s)
   13                 0.000033000   return s:available

FUNCTION  <SNR>90_IndentLinesDisable()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:212
Called 10 times
Total time:   0.001229000
 Self time:   0.001116000

count     total (s)      self (s)
   10                 0.000014000     if g:indentLine_newVersion
   10                 0.000040000         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
  210                 0.000150000             for id in w:indentLine_indentLineId
  200                 0.000089000                 try
  200                 0.000304000                     call matchdelete(id)
                                                  catch /^Vim\%((\a\+)\)\=:E80[23]/
  200                 0.000095000                 endtry
  210                 0.000095000             endfor
   10                 0.000028000             let w:indentLine_indentLineId = []
   10                 0.000008000         endif
                                  
   10   0.000157000   0.000044000         call s:ResetConcealOption()
   10                 0.000003000         return
                                      endif
                                  
                                      let b:indentLine_enabled = 0
                                      try
                                          syntax clear IndentLine
                                          syntax clear IndentLineSpace
                                      catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                      endtry

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:212
Called 77 times
Total time:   0.001509000
 Self time:   0.001509000

count     total (s)      self (s)
   77                 0.000705000   let matches = matchlist(a:line, s:hunk_re)
   77                 0.000088000   if len(matches) > 0
   77                 0.000127000     let from_line  = str2nr(matches[1])
   77                 0.000165000     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   77                 0.000093000     let to_line    = str2nr(matches[3])
   77                 0.000162000     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   77                 0.000130000     return [from_line, from_count, to_line, to_count]
                                    else
                                      return []
                                    end

FUNCTION  <SNR>55_setup()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim:219
Called 27 times
Total time:   0.059336000
 Self time:   0.001399000

count     total (s)      self (s)
   27                 0.000063000   let swap = a:0 && a:1 == 2
   27                 0.000032000   let enable = a:0 && a:1
   27                 0.000032000   let disable = a:0 && !a:1
                                    " First, remove all magic, if needed:
   27                 0.000056000   if get(b:, 'delimitMate_enabled', 0)
   15   0.005966000   0.000045000     call s:Unmap()
                                      " Switch
   15                 0.000010000     if swap
                                        echo "delimitMate is disabled."
                                        return
   15                 0.000007000     endif
   27                 0.000013000   endif
   27                 0.000017000   if disable
                                      " Just disable the mappings.
                                      return
   27                 0.000006000   endif
   27                 0.000024000   if !a:0
                                      " Check if this file type is excluded:
   27                 0.000117000     if exists("g:delimitMate_excluded_ft") && index(split(g:delimitMate_excluded_ft, ','), &filetype, 0, 1) >= 0
                                        " Finish here:
                                        return 1
   27                 0.000017000     endif
                                      " Check if user tried to disable using b:loaded_delimitMate
   27                 0.000048000     if exists("b:loaded_delimitMate")
                                        return 1
   27                 0.000011000     endif
   27                 0.000015000   endif
                                    " Initialize settings:
   27   0.026372000   0.000091000   if ! s:init()
                                      " Something went wrong.
                                      return
   27                 0.000009000   endif
   27                 0.000066000   if enable || swap || !get(g:, 'delimitMate_offByDefault', 0)
                                      " Now, add magic:
   27   0.025811000   0.000076000     call s:Map()
   27                 0.000017000     if a:0
                                        echo "delimitMate is enabled."
   27                 0.000278000     endif
   27                 0.000012000   endif

FUNCTION  DoSave()
    Defined: ~/.vim/plugged/vim-auto-save/plugin/AutoSave.vim:125
Called 11 times
Total time:  48.926226000
 Self time:   0.057940000

count     total (s)      self (s)
   11                 0.000024000   if g:auto_save_write_all_buffers >= 1
                                      let current_buf = bufnr('%')
                                      silent! bufdo update
                                      execute 'buffer' . current_buf
   11                 0.000009000   else
   11  48.926078000   0.057792000     silent! update
   11                 0.000003000   endif

FUNCTION  airline#extensions#tabline#tabs#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/tabs.vim:30
Called 26 times
Total time:   0.089881000
 Self time:   0.001485000

count     total (s)      self (s)
   26                 0.000083000   let curbuf = bufnr('%')
   26                 0.000043000   let curtab = tabpagenr()
   26                 0.000025000   try
   26   0.001230000   0.000115000     call airline#extensions#tabline#tabs#map_keys()
                                    catch
                                      " no-op
   26                 0.000022000   endtry
   26                 0.000116000   if curbuf == s:current_bufnr && curtab == s:current_tabnr && &columns == s:column_width
   21                 0.000084000     if !g:airline_detect_modified || getbufvar(curbuf, '&modified') == s:current_modified
   21                 0.000050000       return s:current_tabline
                                      endif
    5                 0.000004000   endif
                                  
    5   0.001903000   0.000069000   let s:filtered_buflist =  airline#extensions#tabline#buflist#list()
                                  
    5   0.000497000   0.000029000   let b = airline#extensions#tabline#new_builder()
                                  
    5   0.000193000   0.000032000   call airline#extensions#tabline#add_label(b, 'tabs', 0)
                                  
    5                 0.000018000   function! b.get_group(i) dict
                                      let curtab = tabpagenr()
                                      let group = 'airline_tab'
                                      if a:i == curtab
                                        let group = 'airline_tabsel'
                                        if g:airline_detect_modified
                                          for bi in tabpagebuflist(curtab)
                                            if index(s:filtered_buflist,bi) != -1
                                              if getbufvar(bi, '&modified')
                                                let group = 'airline_tabmod'
                                              endif
                                            endif
                                          endfor
                                        endif
                                        let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                      endif
                                      return group
                                    endfunction
                                  
    5                 0.000008000   function! b.get_title(i) dict
                                      let val = '%('
                                  
                                      if get(g:, 'airline#extensions#tabline#show_tab_nr', 1)
                                        let val .= airline#extensions#tabline#tabs#tabnr_formatter(a:i, tabpagebuflist(a:i))
                                      endif
                                  
                                      return val.'%'.a:i.'T %{airline#extensions#tabline#title('.a:i.')} %)'
                                    endfunction
                                  
    5   0.000145000   0.000030000   call b.insert_titles(curtab, 1, tabpagenr('$'))
                                  
    5   0.000033000   0.000014000   call b.add_section('airline_tabfill', '')
    5   0.000033000   0.000010000   call b.split()
    5   0.000030000   0.000013000   call b.add_section('airline_tabfill', '')
                                  
    5                 0.000016000   if get(g:, 'airline#extensions#tabline#show_close_button', 1)
    5   0.000043000   0.000026000     call b.add_section('airline_tab_right', ' %999X'. get(g:, 'airline#extensions#tabline#close_symbol', 'X').'%X ')
    5                 0.000004000   endif
                                  
    5                 0.000013000   if get(g:, 'airline#extensions#tabline#show_splits', 1) == 1
    5                 0.000018000     let buffers = tabpagebuflist(curtab)
   14                 0.000018000     for nr in buffers
    9                 0.000021000       if index(s:filtered_buflist,nr) != -1
    8   0.000240000   0.000042000         let group = airline#extensions#tabline#group_of_bufnr(buffers, nr) . "_right"
    8   0.000138000   0.000038000         call b.add_section_spaced(group, '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)')
    9                 0.000005000       endif
   14                 0.000009000     endfor
    5                 0.000013000     if get(g:, 'airline#extensions#tabline#show_buffers', 1)
    5   0.000229000   0.000021000       call airline#extensions#tabline#add_label(b, 'buffers', 1)
    5                 0.000004000     endif
    5                 0.000002000   endif
    5   0.000210000   0.000027000   call airline#extensions#tabline#add_tab_label(b)
                                  
    5                 0.000017000   let s:current_bufnr = curbuf
    5                 0.000008000   let s:current_tabnr = curtab
    5                 0.000010000   let s:column_width = &columns
    5   0.083974000   0.000036000   let s:current_tabline = b.build()
    5                 0.000005000   return s:current_tabline

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:206
Called 257 times
Total time:   0.002320000
 Self time:   0.002320000

count     total (s)      self (s)
  257                 0.000922000   if has('win32')
                                      " Setup an ignore for platforms that trigger FocusLost on calls to
                                      " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                      let s:focusgained_ignore_time = localtime()
  257                 0.000158000   endif

FUNCTION  <SNR>142_DoAutocmd()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:280
Called 1 time
Total time:   0.000005000
 Self time:   0.000005000

count     total (s)      self (s)
    1                 0.000004000   return join(map(copy(a:000), "'doautocmd <nomodeline>' . v:val"), '|')

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 782 times
Total time:   0.004267000
 Self time:   0.004267000

count     total (s)      self (s)
  782                 0.003794000   return get(s:parts, a:key, {})

FUNCTION  delimitMate#Get()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim:262
Called 924 times
Total time:   0.010888000
 Self time:   0.002333000

count     total (s)      self (s)
  924   0.010702000   0.002147000   return call('s:get', a:000)

FUNCTION  airline#load_theme()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:56
Called 2 times
Total time:   0.133768000
 Self time:   0.000330000

count     total (s)      self (s)
    2                 0.000062000   let g:airline_theme = get(g:, 'airline_theme', 'dark')
    2                 0.000019000   if exists('*airline#themes#{g:airline_theme}#refresh')
                                      call airline#themes#{g:airline_theme}#refresh()
    2                 0.000003000   endif
                                  
    2                 0.000022000   let palette = g:airline#themes#{g:airline_theme}#palette
    2   0.000747000   0.000049000   call airline#themes#patch(palette)
                                  
    2                 0.000009000   if exists('g:airline_theme_patch_func')
                                      let Fn = function(g:airline_theme_patch_func)
                                      call Fn(palette)
    2                 0.000000000   endif
                                  
    2   0.112716000   0.000067000   call airline#highlighter#load_theme()
    2   0.004760000   0.000024000   call airline#extensions#load_theme()
    2   0.015249000   0.000005000   call airline#update_statusline()
                                  
    2   0.000115000   0.000004000   call airline#util#doautocmd('AirlineAfterTheme')

FUNCTION  <SNR>90_LeadingSpaceDisable()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:367
Called 10 times
Total time:   0.000126000
 Self time:   0.000126000

count     total (s)      self (s)
   10                 0.000015000     if g:indentLine_newVersion
   10                 0.000028000         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                              for id in w:indentLine_leadingSpaceId
                                                  try
                                                      call matchdelete(id)
                                                  catch /^Vim\%((\a\+)\)\=:E80[23]/
                                                  endtry
                                              endfor
                                              let w:indentLine_leadingSpaceId = []
   10                 0.000006000         endif
                                  
   10                 0.000007000         return
                                      endif
                                  
                                      let b:indentLine_leadingSpaceEnabled = 0
                                      try
                                          syntax clear IndentLineLeadingSpace
                                      catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                      endtry

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:65
Called 154 times
Total time:   0.000529000
 Self time:   0.000529000

count     total (s)      self (s)
  154                 0.000437000   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>13_LoadIndent()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/indent.vim:16
Called 17 times
Total time:   0.007463000
 Self time:   0.006300000

count     total (s)      self (s)
   17                 0.000034000   if exists("b:undo_indent")
                                      legacy exe b:undo_indent
                                      unlet! b:undo_indent b:did_indent
                                    endif
   17                 0.000010000   var s = expand("<amatch>")
   17                 0.000009000   if s != ""
   17                 0.000011000     if exists("b:did_indent")
    8                 0.000010000       unlet b:did_indent
    8                 0.000000000     endif
                                  
                                      # When there is a dot it is used to separate filetype names.  Thus for
                                      # "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   17                 0.000024000     for name in split(s, '\.')
   17   0.007305000   0.006142000       exe 'runtime! indent/' .. name .. '.vim'
   17                 0.000006000     endfor
   17                 0.000002000   endif

FUNCTION  go#lsp#DidChange()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:746
Called 18 times
Total time:   0.003703000
 Self time:   0.001280000

count     total (s)      self (s)
                                    " DidChange is called even when fname isn't open in a buffer (e.g. via
                                    " go#lsp#Info); don't report the file as open or as having changed when it's
                                    " not actually a buffer.
   18                 0.000156000   if bufnr(a:fname) == -1
                                      return
   18                 0.000007000   endif
                                  
   18                 0.000257000   let l:fname = fnamemodify(a:fname, ':p')
   18                 0.000085000   if !isdirectory(fnamemodify(l:fname, ':h'))
                                      return
   18                 0.000012000   endif
                                  
   18   0.000097000   0.000039000   call go#lsp#DidOpen(a:fname)
                                  
   18   0.000270000   0.000074000   let l:lsp = s:lspfactory.get()
                                  
   18                 0.000131000   let l:version = getbufvar(l:fname, 'changedtick')
   18                 0.000083000   if has_key(l:lsp.fileVersions, l:fname) && l:lsp.fileVersions[l:fname] == l:version
    9                 0.000003000     return
    9                 0.000003000   endif
    9                 0.000027000   let l:lsp.fileVersions[l:fname] = l:version
                                  
    9   0.000864000   0.000189000   let l:msg = go#lsp#message#DidChange(l:fname, join(go#util#GetLines(), "\n") . "\n", l:lsp.fileVersions[l:fname])
    9   0.000400000   0.000035000   let l:state = s:newHandlerState('')
    9   0.001182000   0.000053000   return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  go#config#HighlightTrailingWhitespaceError()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:410
Called 16 times
Total time:   0.000031000
 Self time:   0.000031000

count     total (s)      self (s)
   16                 0.000029000   return get(g:, 'go_highlight_trailing_whitespace_error', 0)

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:144
Called 76 times
Total time:   0.905470000
 Self time:   0.006202000

count     total (s)      self (s)
   76   0.005052000   0.000754000   if airline#util#stl_disabled(winnr()) || airline#util#is_popup_window(winnr())
    4                 0.000001000     return
   72                 0.000050000   endif
                                    " TODO: need to ignore popup windows here as well?
   72                 0.000924000   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                                    " create inactive statusline
   72   0.365194000   0.000401000   call airline#update_statusline_inactive(range)
                                  
   72                 0.000192000   unlet! w:airline_render_left w:airline_render_right
   72                 0.001002000   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                                  
                                    " Now create the active statusline
   72                 0.000159000   let w:airline_active = 1
   72                 0.001233000   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   72                 0.000086000   try
   72   0.530959000   0.000782000     call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)
                                    catch /^Vim\%((\a\+)\)\=:E48:/
                                      " Catch: Sandbox mode
                                      " no-op
   72                 0.000056000   endtry

FUNCTION  go#package#InGOPATH()
    Defined: ~/.vim/plugged/vim-go/autoload/go/package.vim:139
Called 8 times
Total time:   0.000319000
 Self time:   0.000319000

count     total (s)      self (s)
    8                 0.000232000   let l:dir = expand("%:p:h")
    8                 0.000045000   if has_key(s:in_gopath, dir)
    8                 0.000033000     return s:in_gopath[l:dir][0] !=#  '_'
                                    endif
                                  
                                    try
                                      " turn off module support so that `go list` will report the package name
                                      " with a leading '_' when the current buffer is not within GOPATH.
                                      let Restore_modules = go#util#SetEnv('GO111MODULE', 'off')
                                      let [l:out, l:err] = go#util#ExecInDir(['go', 'list'])
                                      if l:err != 0
                                        return 0
                                      endif
                                  
                                      let l:importpath = split(l:out, '\n')[0]
                                      if len(l:importpath) > 0
                                        let s:in_gopath[l:dir] = l:importpath
                                      endif
                                    finally
                                      call call(Restore_modules, [])
                                    endtry
                                  
                                    return len(l:importpath) > 0 && l:importpath[0] !=# '_'

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/.vim/plugged/ultisnips/autoload/UltiSnips.vim:190
Called 4 times
Total time:   0.007577000
 Self time:   0.007577000

count     total (s)      self (s)
    4                 0.007575000     py3 UltiSnips_Manager._track_change()

FUNCTION  371()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:109
Called 3 times
Total time:   0.000427000
 Self time:   0.000132000

count     total (s)      self (s)
    3                 0.000009000     let bufnum = get(self.buffers, a:i, -1)
    3   0.000126000   0.000009000     let group = self.get_group(a:i)
    3   0.000192000   0.000014000     let pgroup = self.get_group(a:i - 1)
                                      " always add a space when powerline_fonts are used
                                      " or for the very first item
    3                 0.000011000     if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
    1                 0.000002000       let space = s:spc
    2                 0.000002000     else
    2                 0.000008000       let space= (pgroup == group ? s:spc : '')
    3                 0.000003000     endif
                                  
    3                 0.000010000     if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                        if len(s:number_map) > 0
                                          return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                        else
                                          return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                        endif
    3                 0.000002000     else
    3                 0.000015000       return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                      endif

FUNCTION  gitgutter#utility#base_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:249
Called 11 times
Total time:   0.002483000
 Self time:   0.000553000

count     total (s)      self (s)
   11   0.001407000   0.000078000   let diffbase = gitgutter#utility#get_diff_base(a:bufnr)
                                  
                                    " If we already know the original path at this diff base, return it.
   11   0.000331000   0.000084000   let basepath = gitgutter#utility#getbufvar(a:bufnr, 'basepath', '')
   11                 0.000023000   if !empty(basepath)
                                      " basepath is diffbase:path
                                      " Note that path can also contain colons.
                                      " List destructuring / unpacking where the remaining items are assigned
                                      " to a single variable (:help let-unpack) is only available in v8.2.0540.
   11                 0.000089000     let parts = split(basepath, ':', 1)
   11                 0.000043000     let base = parts[0]
   11                 0.000080000     let bpath = join(parts[1:], ':')
                                  
   11                 0.000035000     if base == diffbase
   11   0.000411000   0.000057000       return gitgutter#utility#shellescape(bpath)
                                      endif
                                    endif
                                  
                                    " Obtain buffers' paths.
                                    let current_paths = {}
                                    for bufnr in range(1, bufnr('$') + 1)
                                      if gitgutter#utility#has_repo_path(bufnr)
                                        let current_paths[gitgutter#utility#repo_path(bufnr, 0)] = bufnr
                                      endif
                                    endfor
                                  
                                    " Get a list of file renames at the buffer's diff base.
                                    " Store the original paths on any corresponding buffers.
                                    " If the buffer's file was one of them, return its original path.
                                    let op = ''
                                    let renames = s:obtain_file_renames(a:bufnr, diffbase)
                                    for [current, original] in items(renames)
                                      if has_key(current_paths, current)
                                        let bufnr = current_paths[current]
                                        let basepath = diffbase.':'.original
                                        call gitgutter#utility#setbufvar(bufnr, 'basepath', basepath)
                                  
                                        if bufnr == a:bufnr
                                          let op = original
                                        endif
                                      endif
                                    endfor
                                    if !empty(op)
                                      return gitgutter#utility#shellescape(op)
                                    endif
                                  
                                    " Buffer's file was not renamed, so store current path and return it.
                                    let current_path = gitgutter#utility#repo_path(a:bufnr, 0)
                                    let basepath = diffbase.':'.current_path
                                    call gitgutter#utility#setbufvar(a:bufnr, 'basepath', basepath)
                                    return gitgutter#utility#shellescape(current_path)

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:169
Called 10 times
Total time:   0.000850000
 Self time:   0.000850000

count     total (s)      self (s)
   10                 0.000294000   if get(g:, 'airline_focuslost_inactive', 0)
                                      let bufnr=bufnr('%')
                                      call airline#highlighter#highlight_modified_inactive(bufnr)
                                      call airline#highlighter#highlight(['inactive'], bufnr)
                                      call airline#update_statusline_inactive(range(1, winnr('$')))
   10                 0.000218000   endif

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:232
Called 59 times
Total time:   0.000940000
 Self time:   0.000940000

count     total (s)      self (s)
   59                 0.000173000     let l:min = 0
   59                 0.000224000     let l:max = len(a:loclist) - 1
                                  
   59                 0.000158000     while 1
   59                 0.000119000         if l:max < l:min
   59                 0.000088000             return -1
                                          endif
                                  
                                          let l:mid = (l:min + l:max) / 2
                                          let l:item = a:loclist[l:mid]
                                  
                                          " Binary search for equal buffers, equal lines, then near columns.
                                          if l:item.bufnr < a:buffer
                                              let l:min = l:mid + 1
                                          elseif l:item.bufnr > a:buffer
                                              let l:max = l:mid - 1
                                          elseif l:item.lnum < a:line
                                              let l:min = l:mid + 1
                                          elseif l:item.lnum > a:line
                                              let l:max = l:mid - 1
                                          else
                                              " This part is a small sequential search.
                                              let l:index = l:mid
                                  
                                              " Search backwards to find the first problem on the line.
                                              while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                                  let l:index -= 1
                                              endwhile
                                  
                                              " Find the last problem on or before this column.
                                              while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                                  let l:index += 1
                                              endwhile
                                  
                                              " Scan forwards to find the last item on the column for the item
                                              " we found, which will have the most serious problem.
                                              let l:item_column = a:loclist[l:index].col
                                  
                                              while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                                  let l:index += 1
                                              endwhile
                                  
                                              return l:index
                                          endif
                                      endwhile

FUNCTION  ale#events#SaveEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:25
Called 9 times
Total time:   0.005642000
 Self time:   0.000332000

count     total (s)      self (s)
    9   0.000270000   0.000094000     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                                  
    9                 0.000011000     if l:should_lint
    9                 0.000045000         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    9                 0.000007000     endif
                                  
    9   0.000101000   0.000029000     if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
                                          let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
                                          let l:should_lint = l:should_lint && !l:will_fix
    9                 0.000003000     endif
                                  
    9   0.000086000   0.000035000     if l:should_lint && !ale#events#QuitRecently(a:buffer)
    9   0.005044000   0.000033000         call ale#Queue(0, 'lint_file', a:buffer)
    9                 0.000004000     endif

FUNCTION  go#util#GetLines()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:455
Called 18 times
Total time:   0.000704000
 Self time:   0.000704000

count     total (s)      self (s)
   18                 0.000444000   let buf = getline(1, '$')
   18                 0.000038000   if &encoding != 'utf-8'
                                      let buf = map(buf, 'iconv(v:val, &encoding, "utf-8")')
   18                 0.000012000   endif
   18                 0.000025000   if &l:fileformat == 'dos'
                                      " XXX: line2byte() depend on 'fileformat' option.
                                      " so if fileformat is 'dos', 'buf' must include '\r'.
                                      let buf = map(buf, 'v:val."\r"')
   18                 0.000009000   endif
   18                 0.000020000   return buf

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:179
Called 397 times
Total time:   0.012189000
 Self time:   0.005363000

count     total (s)      self (s)
                                    " only consider regular buffers (e.g. ones that represent actual files,
                                    " but not special ones like e.g. NERDTree)
  397   0.009172000   0.002346000   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
  163                 0.000172000     return ''
  234                 0.000129000   endif
  234                 0.000587000   if &readonly && !filereadable(bufname('%'))
                                      return '[noperm]'
  234                 0.000146000   else
  234                 0.000422000     return &readonly ? g:airline_symbols.readonly : ''
                                    endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1025
Called 254 times
Total time:   0.050054000
 Self time:   0.027612000

count     total (s)      self (s)
  254                 0.001127000   let dir = a:0 > 1 ? a:2 : s:Dir()
  254                 0.000472000   if empty(dir)
                                      return ''
  254                 0.000157000   endif
  254   0.023910000   0.001468000   let file = FugitiveActualDir(dir) . '/HEAD'
  254                 0.008603000   let ftime = getftime(file)
  254                 0.000463000   if ftime == -1
                                      return ''
  254                 0.001777000   elseif ftime != get(s:head_cache, file, [-1])[0]
   19                 0.000909000     let s:head_cache[file] = [ftime, readfile(file)[0]]
  254                 0.000166000   endif
  254                 0.000851000   let head = s:head_cache[file][1]
  254                 0.000579000   let len = a:0 ? a:1 : 0
  254                 0.001459000   if head =~# '^ref: '
  254                 0.000364000     if len < 0
                                        return strpart(head, 5)
  254                 0.000191000     else
  254                 0.006133000       return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                                      endif
                                    elseif head =~# '^\x\{40,\}$'
                                      return len < 0 ? head : strpart(head, 0, len)
                                    else
                                      return ''
                                    endif

FUNCTION  airline#extensions#tabline#redraw()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:149
Called 1 time
Total time:   0.001242000
 Self time:   0.001242000

count     total (s)      self (s)
                                      " sometimes, the tabline is not correctly updated see #1580
                                      " so force redraw here
    1                 0.000002000     if exists(":redrawtabline") == 2
    1                 0.001217000       redrawtabline
                                      else
                                      " Have to set a property equal to itself to get airline to re-eval.
                                      " Setting `let &tabline=&tabline` destroys the cursor position so we
                                      " need something less invasive.
                                        let &ro = &ro
    1                 0.000001000     endif

FUNCTION  <SNR>157_GetLinterNames()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:337
Called 12 times
Total time:   0.000306000
 Self time:   0.000306000

count     total (s)      self (s)
   12                 0.000046000     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                                  
                                      " b:ale_linters can be set to 'all'
   12                 0.000015000     if l:buffer_ale_linters is# 'all'
                                          return 'all'
   12                 0.000007000     endif
                                  
                                      " b:ale_linters can be set to a List.
   12                 0.000033000     if type(l:buffer_ale_linters) is v:t_list
                                          return l:buffer_ale_linters
   12                 0.000004000     endif
                                  
                                      " Try to get a buffer-local setting for the filetype
   12                 0.000026000     if has_key(l:buffer_ale_linters, a:original_filetype)
                                          return l:buffer_ale_linters[a:original_filetype]
   12                 0.000004000     endif
                                  
                                      " Try to get a global setting for the filetype
   12                 0.000039000     if has_key(g:ale_linters, a:original_filetype)
                                          return g:ale_linters[a:original_filetype]
   12                 0.000003000     endif
                                  
                                      " If the user has configured ALE to only enable linters explicitly, then
                                      " don't enable any linters by default.
   12                 0.000021000     if g:ale_linters_explicit
   12                 0.000012000         return []
                                      endif
                                  
                                      " Try to get a default setting for the filetype
                                      if has_key(s:default_ale_linters, a:original_filetype)
                                          return s:default_ale_linters[a:original_filetype]
                                      endif
                                  
                                      return 'all'

FUNCTION  <SNR>43_CeilingDirectories()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:388
Called 131 times
Total time:   0.013617000
 Self time:   0.013286000

count     total (s)      self (s)
  131                 0.000534000   if !exists('s:ceiling_directories')
                                      let s:ceiling_directories = []
                                      let resolve = 1
                                      for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
                                        if empty(dir)
                                          let resolve = 0
                                        elseif resolve
                                          call add(s:ceiling_directories, s:Slash(resolve(dir)))
                                        else
                                          call add(s:ceiling_directories, s:Slash(dir))
                                        endif
                                      endfor
  131                 0.000085000   endif
  131   0.009680000   0.009349000   return s:ceiling_directories + get(g:, 'ceiling_directories', [s:Slash(fnamemodify(expand('~'), ':h'))])

FUNCTION  go#uri#EncodePath()
    Defined: ~/.vim/plugged/vim-go/autoload/go/uri.vim:9
Called 9 times
Total time:   0.000187000
 Self time:   0.000077000

count     total (s)      self (s)
    9                 0.000019000     let l:separator = '/'
    9   0.000024000   0.000009000     if go#util#IsWin()
                                        let l:separator = '\\'
    9                 0.000002000     endif
    9   0.000127000   0.000032000     return s:encode(a:value, '[^' . l:separator . 'A-Za-z0-9_.~-]')

FUNCTION  fzf#vim#_format_buffer()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:789
Called 3 times
Total time:   0.001354000
 Self time:   0.000647000

count     total (s)      self (s)
    3                 0.000012000   let name = bufname(a:b)
    3                 0.000055000   let line = exists('*getbufinfo') ? getbufinfo(a:b)[0]['lnum'] : 0
    3                 0.000385000   let fullname = empty(name) ? '' : fnamemodify(name, ":p:~:.")
    3                 0.000013000   let dispname = empty(name) ? '[No Name]' : name
    3   0.000236000   0.000034000   let flag = a:b == bufnr('')  ? s:blue('%', 'Conditional') : (a:b == bufnr('#') ? s:magenta('#', 'Special') : ' ')
    3                 0.000022000   let modified = getbufvar(a:b, '&modified') ? s:red(' [+]', 'Exception') : ''
    3                 0.000017000   let readonly = getbufvar(a:b, '&modifiable') ? '' : s:green(' [RO]', 'Constant')
    3                 0.000029000   let extra = join(filter([modified, readonly], '!empty(v:val)'), '')
    3                 0.000018000   let target = empty(name) ? '' : (line == 0 ? fullname : fullname.':'.line)
    3   0.000559000   0.000054000   return s:rstrip(printf("%s\t%d\t[%s] %s\t%s\t%s", target, line, s:yellow(a:b, 'Number'), flag, dispname, extra))

FUNCTION  <SNR>41_BufReadHandler()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:630
Called 1 time
Total time:   0.000005000
 Self time:   0.000005000

count     total (s)      self (s)
                                    " Refresh NERDTree to show currently opened file
    1                 0.000002000   if g:nerdtree_tabs_autofind
                                      call s:NERDTreeFindFile()
                                      call s:NERDTreeUnfocus()
    1                 0.000001000   endif

FUNCTION  <SNR>101_format_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:77
Called 27 times
Total time:   0.000049000
 Self time:   0.000049000

count     total (s)      self (s)
   27                 0.000041000     return a:name

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:18
Called 187 times
Total time:   0.002391000
 Self time:   0.002391000

count     total (s)      self (s)
  187                 0.000297000   let buffer = +a:buffer
                                    " Default value for getbufvar() was introduced in Vim 7.3.831.
  187                 0.000461000   let ggvars = getbufvar(buffer, 'gitgutter')
  187                 0.000303000   if type(ggvars) == type('')
   12                 0.000018000     unlet ggvars
   12                 0.000020000     let ggvars = {}
   12                 0.000052000     call setbufvar(buffer, 'gitgutter', ggvars)
  187                 0.000088000   endif
  187                 0.000405000   let ggvars[a:varname] = a:val

FUNCTION  go#config#ImportsAutosave()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:295
Called 9 times
Total time:   0.000039000
 Self time:   0.000039000

count     total (s)      self (s)
    9                 0.000031000   return get(g:, 'go_imports_autosave', 1)

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:170
Called 6281 times
Total time:   0.022795000
 Self time:   0.022795000

count     total (s)      self (s)
 6281                 0.020746000     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  <SNR>157_IsBoolean()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:86
Called 6 times
Total time:   0.000012000
 Self time:   0.000012000

count     total (s)      self (s)
    6                 0.000012000     return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)

FUNCTION  <SNR>157_GetAliasedFiletype()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:301
Called 12 times
Total time:   0.000543000
 Self time:   0.000543000

count     total (s)      self (s)
   12                 0.000068000     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                                  
                                      " b:ale_linter_aliases can be set to a List or String.
   12                 0.000058000     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                          return l:buffer_aliases
   12                 0.000013000     endif
                                  
                                      " Check for aliased filetypes first in a buffer variable,
                                      " then the global variable,
                                      " then in the default mapping,
                                      " otherwise use the original filetype.
   48                 0.000083000     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
   36                 0.000084000         if has_key(l:dict, a:original_filetype)
                                              return l:dict[a:original_filetype]
   36                 0.000016000         endif
   48                 0.000038000     endfor
                                  
   12                 0.000011000     return a:original_filetype

FUNCTION  <SNR>41_NERDTreeUnfocus()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:252
Called 4 times
Total time:   0.000126000
 Self time:   0.000082000

count     total (s)      self (s)
                                    " save current window so that it's focus can be restored after switching
                                    " back to this tab
    4                 0.000017000   let t:NERDTreeTabLastWindow = winnr()
    4   0.000058000   0.000014000   if s:IsCurrentWindowNERDTree()
                                      let l:winNum = s:NextNormalWindow()
                                      if l:winNum != -1
                                        exec l:winNum.'wincmd w'
                                      else
                                        wincmd w
                                      endif
    4                 0.000003000   endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:219
Called 4475 times
Total time:   1.036330000
 Self time:   0.296873000

count     total (s)      self (s)
 4475                 0.005252000     if pumvisible()
                                        return
 4475                 0.001887000     endif
 4475                 0.005337000     let colors = a:colors
 4475                 0.006696000     if len(colors) == 4
 2334                 0.003898000       call add(colors, '')
 4475                 0.001991000     endif
                                      " colors should always be string values
 4475                 0.068201000     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
 4475                 0.004626000     if s:is_win32term
                                        let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                        let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
 4475                 0.001980000     endif
 4475   0.600070000   0.015388000     let old_hi = airline#highlighter#get_highlight(a:group)
 4475                 0.029673000     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
 4475   0.093198000   0.012855000     let colors = s:CheckDefined(colors)
 4475   0.068511000   0.015808000     if old_hi != new_hi || !s:hl_group_exists(a:group)
  200   0.022825000   0.001096000       let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
  200                 0.000129000       try
  200                 0.002066000         exe cmd
                                        catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                          let group=matchstr(v:exception, '\w\+\ze=')
                                          let color=matchstr(v:exception, '=\zs\w\+')
                                          let cmd=substitute(cmd, color, 'grey', 'g')
                                          exe cmd
                                          call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                        catch
                                          call airline#util#warning('Error when running command: '. cmd)
  200                 0.000155000       endtry
  200                 0.000483000       if has_key(s:hl_groups, a:group)
  200                 0.000407000         let s:hl_groups[a:group] = colors
  200                 0.000106000       endif
 4475                 0.001872000     endif

FUNCTION  go#util#ShellError()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:277
Called 9 times
Total time:   0.000031000
 Self time:   0.000031000

count     total (s)      self (s)
    9                 0.000025000   return v:shell_error

FUNCTION  go#config#HighlightFunctionParameters()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:422
Called 16 times
Total time:   0.000069000
 Self time:   0.000069000

count     total (s)      self (s)
                                    " fallback to highlight_function_arguments for backwards compatibility
   16                 0.000048000   return get(g:, 'go_highlight_function_parameters', get(g:, 'go_highlight_function_arguments', 0))

FUNCTION  nerdtree#echoWarning()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:296
Called 1 time
Total time:   0.000105000
 Self time:   0.000054000

count     total (s)      self (s)
    1                 0.000028000     echohl warningmsg
    1   0.000060000   0.000009000     call nerdtree#echo(a:msg)
    1                 0.000016000     echohl normal

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:485
Called 59 times
Total time:   0.003309000
 Self time:   0.002369000

count     total (s)      self (s)
   59                 0.000593000     let l:info = get(g:ale_buffer_info, a:buffer, {})
   59                 0.000218000     let l:loclist = get(l:info, 'loclist', [])
   59                 0.000224000     let l:pos = getpos('.')
   59   0.001638000   0.000698000     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
   59                 0.000296000     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                                  
   59                 0.000138000     return [l:info, l:loc]

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:35
Called 4668 times
Total time:   0.642639000
 Self time:   0.022122000

count     total (s)      self (s)
 4668   0.641354000   0.020837000     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>62_extract_option()
    Defined: ~/.fzf/plugin/fzf.vim:466
Called 2 times
Total time:   0.000119000
 Self time:   0.000119000

count     total (s)      self (s)
    2                 0.000006000   let opt = ''
    2                 0.000004000   let expect = 0
                                    " There are a few cases where this function doesn't work as expected.
                                    " Let's just assume such cases are extremely unlikely in real world.
                                    "   e.g. --query --border
    2                 0.000030000   for word in split(a:opts)
                                      if expect && word !~ '^"\=-'
                                        let opt = opt . ' ' . word
                                        let expect = 0
                                      elseif word == '--no-'.a:name
                                        let opt = ''
                                      elseif word =~ '^--'.a:name.'='
                                        let opt = word
                                      elseif word =~ '^--'.a:name.'$'
                                        let opt = word
                                        let expect = 1
                                      elseif expect
                                        let expect = 0
                                      endif
    2                 0.000003000   endfor
    2                 0.000004000   return opt

FUNCTION  229()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:178
Called 2 times
Total time:   0.000188000
 Self time:   0.000028000

count     total (s)      self (s)
    2                 0.000010000     let newObj = copy(self)
    2   0.000042000   0.000006000     let newObj.ui = g:NERDTreeUI.New(newObj)
    2   0.000133000   0.000009000     let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
    2                 0.000001000     let newObj._type = a:type
    2                 0.000001000     return newObj

FUNCTION  <SNR>55_ExtraMappings()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim:325
Called 27 times
Total time:   0.006268000
 Self time:   0.005020000

count     total (s)      self (s)
                                    " If pair is empty, delete both delimiters:
   27                 0.000238000   inoremap <silent> <Plug>delimitMateBS <C-R>=delimitMate#BS()<CR>
   27                 0.000253000   if !hasmapto('<Plug>delimitMateBS','i')
   27                 0.000129000     if empty(maparg('<BS>', 'i'))
   27                 0.000167000       silent! imap <unique> <buffer> <BS> <Plug>delimitMateBS
   27                 0.000012000     endif
   27                 0.000168000     if empty(maparg('<C-H>', 'i'))
   27                 0.000192000       silent! imap <unique> <buffer> <C-h> <Plug>delimitMateBS
   27                 0.000008000     endif
   27                 0.000009000   endif
                                    " If pair is empty, delete closing delimiter:
   27                 0.000677000   inoremap <silent> <expr> <Plug>delimitMateS-BS delimitMate#WithinEmptyPair() ? "\<Del>" : "\<S-BS>"
   27                 0.000301000   if !hasmapto('<Plug>delimitMateS-BS','i') && maparg('<S-BS>', 'i') == ''
   27                 0.000146000     silent! imap <unique> <buffer> <S-BS> <Plug>delimitMateS-BS
   27                 0.000009000   endif
                                    " Expand return if inside an empty pair:
   27                 0.000276000   inoremap <expr><silent> <Plug>delimitMateCR <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandReturn()\<CR>"
   27   0.000579000   0.000150000   if s:get('expand_cr', 0) && !hasmapto('<Plug>delimitMateCR', 'i') && maparg('<CR>', 'i') == ''
                                      silent! imap <unique> <buffer> <CR> <Plug>delimitMateCR
   27                 0.000008000   endif
                                    " Expand space if inside an empty pair:
   27                 0.000313000   inoremap <expr><silent> <Plug>delimitMateSpace <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandSpace()\<CR>"
   27   0.000570000   0.000149000   if s:get('expand_space', 0) && !hasmapto('<Plug>delimitMateSpace', 'i') && maparg('<Space>', 'i') == ''
                                      silent! imap <unique> <buffer> <Space> <Plug>delimitMateSpace
   27                 0.000013000   endif
                                    " Jump over any delimiter:
   27                 0.000279000   inoremap <expr><silent> <Plug>delimitMateS-Tab <SID>TriggerAbb()."\<C-R>=delimitMate#JumpAny()\<CR>"
   27   0.000796000   0.000398000   if s:get('tab2exit', 0) && !hasmapto('<Plug>delimitMateS-Tab', 'i') && maparg('<S-Tab>', 'i') == ''
   23                 0.000130000     silent! imap <unique> <buffer> <S-Tab> <Plug>delimitMateS-Tab
   27                 0.000013000   endif
                                    " Jump over next delimiters
   27                 0.000272000   inoremap <expr><buffer> <Plug>delimitMateJumpMany <SID>TriggerAbb()."\<C-R>=delimitMate#JumpMany()\<CR>"
   27                 0.000355000   if !hasmapto('<Plug>delimitMateJumpMany', 'i') && maparg("<C-G>g", 'i') == ''
   27                 0.000166000     imap <silent> <buffer> <C-G>g <Plug>delimitMateJumpMany
   27                 0.000010000   endif

FUNCTION  <SNR>41_SaveNERDTreeViewIfPossible()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:374
Called 22 times
Total time:   0.001863000
 Self time:   0.001863000

count     total (s)      self (s)
   22                 0.001472000   if exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) == winnr()
                                      " save scroll and cursor etc.
    6                 0.000063000     let s:nerdtree_view = winsaveview()
                                  
                                      " save NERDTree window width
    6                 0.000026000     let s:nerdtree_width = winwidth(winnr())
                                  
                                      " save buffer name (to be able to correct desync by commands spawning
                                      " a new NERDTree instance)
    6                 0.000028000     let s:nerdtree_buffer = bufname("%")
   22                 0.000016000   endif

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:7
Called 428 times
Total time:   0.054058000
 Self time:   0.044941000

count     total (s)      self (s)
  428                 0.001399000     let fnametruncate = get(g:, 'airline#extensions#tabline#fnametruncate', 0)
  428                 0.001088000     let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
  428                 0.000461000     let _ = ''
                                  
  428                 0.001015000     let name = bufname(a:bufnr)
  428                 0.000662000     if empty(name)
  149                 0.000168000       let _ = '[No Name]'
  279                 0.000947000     elseif name =~ 'term://'
                                        " Neovim Terminal
                                        let _ = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
  279                 0.000164000     else
  279                 0.000627000       if get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                          " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                          "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
  279                 0.028009000         let _ = pathshorten(fnamemodify(name, fmod))
                                        else
                                          let _ = fnamemodify(name, fmod)
  279                 0.000171000       endif
  279                 0.001113000       if a:bufnr != bufnr('%') && fnametruncate && strlen(_) > fnametruncate
                                          let _ = airline#util#strcharpart(_, 0, fnametruncate)
  279                 0.000133000       endif
  428                 0.000244000     endif
                                  
  428   0.011139000   0.002022000     return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  <SNR>172_write_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:371
Called 11 times
Total time:   0.062620000
 Self time:   0.062620000

count     total (s)      self (s)
   11                 0.000694000   let bufcontents = getbufline(a:bufnr, 1, '$')
                                  
   11                 0.000038000   if bufcontents == [''] && line2byte(1) == -1
                                      " Special case: completely empty buffer.
                                      " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                      call writefile([], a:file)
                                      return
   11                 0.000005000   endif
                                  
   11                 0.000062000   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                      if getbufvar(a:bufnr, '&endofline')
                                        call map(bufcontents, 'v:val."\r"')
                                      else
                                        for i in range(len(bufcontents) - 1)
                                          let bufcontents[i] = bufcontents[i] . "\r"
                                        endfor
                                      endif
   11                 0.000007000   endif
                                  
   11                 0.000044000   if getbufvar(a:bufnr, '&endofline')
   11                 0.000047000     call add(bufcontents, '')
   11                 0.000005000   endif
                                  
   11                 0.000034000   let fenc = getbufvar(a:bufnr, '&fileencoding')
   11                 0.000020000   if fenc !=# &encoding
                                      call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
   11                 0.000008000   endif
                                  
   11                 0.000034000   if getbufvar(a:bufnr, '&bomb')
                                      let bufcontents[0]='﻿'.bufcontents[0]
   11                 0.000005000   endif
                                  
                                    " The file we are writing to is a temporary file.  Sometimes the parent
                                    " directory is deleted outside Vim but, because Vim caches the directory
                                    " name at startup and does not check for its existence subsequently, Vim
                                    " does not realise.  This causes E482 errors.
   11                 0.000008000   try
   11                 0.058590000     call writefile(bufcontents, a:file, 'b')
                                    catch /E482/
                                      call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                      call writefile(bufcontents, a:file, 'b')
   11                 0.000176000   endtry

FUNCTION  gitgutter#hunk#reset()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:14
Called 2 times
Total time:   0.000187000
 Self time:   0.000041000

count     total (s)      self (s)
    2   0.000074000   0.000018000   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
    2   0.000111000   0.000021000   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>101_sh_autocmd_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:356
Called 36 times
Total time:   0.000526000
 Self time:   0.000526000

count     total (s)      self (s)
   36                 0.000192000   if exists('#airline')
   36                 0.000223000     unlet! b:airline_head b:airline_do_mq_check
   36                 0.000021000   endif

FUNCTION  go#config#DebugLogDelay()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:177
Called 13 times
Total time:   0.000104000
 Self time:   0.000104000

count     total (s)      self (s)
   13                 0.000082000   return get(g:, 'go_debug_log_delay', 10)

FUNCTION  go#config#HighlightArrayWhitespaceError()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:394
Called 16 times
Total time:   0.000046000
 Self time:   0.000046000

count     total (s)      self (s)
   16                 0.000037000   return get(g:, 'go_highlight_array_whitespace_error', 0)

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 744 times
Total time:   0.217498000
 Self time:   0.011395000

count     total (s)      self (s)
  744                 0.001231000   if a:group1 == a:group2
   96                 0.000067000     return 0
  648                 0.000339000   endif
  648   0.107919000   0.002747000   let color1 = airline#highlighter#get_highlight(a:group1)
  648   0.103453000   0.002522000   let color2 = airline#highlighter#get_highlight(a:group2)
  648                 0.003187000   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:54
Called 72 times
Total time:   0.001395000
 Self time:   0.000652000

count     total (s)      self (s)
   72   0.001070000   0.000327000   call <sid>check_defined_section(a:name)
   72                 0.000255000   let w:airline_section_{a:name} .= a:value

FUNCTION  ale#engine#Cleanup()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:731
Called 10 times
Total time:   0.000171000
 Self time:   0.000171000

count     total (s)      self (s)
                                      " Don't bother with cleanup code when newer NeoVim versions are exiting.
   10                 0.000045000     if get(v:, 'exiting', v:null) isnot v:null
                                          return
   10                 0.000005000     endif
                                  
   10                 0.000020000     if exists('*ale#lsp#CloseDocument')
                                          call ale#lsp#CloseDocument(a:buffer)
   10                 0.000004000     endif
                                  
   10                 0.000030000     if !has_key(g:ale_buffer_info, a:buffer)
   10                 0.000007000         return
                                      endif
                                  
                                      call ale#engine#RunLinters(a:buffer, [], 1)
                                  
                                      call remove(g:ale_buffer_info, a:buffer)

FUNCTION  <SNR>148_start()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:582
Called 9 times
Total time:   0.000038000
 Self time:   0.000038000

count     total (s)      self (s)
    9                 0.000018000   let self.started_at = reltime()
    9                 0.000008000   if self.statustype == ''
    9                 0.000004000     return
                                    endif
                                    let status = { 'desc': 'current status', 'type': self.statustype, 'state': "started", }
                                  
                                    call go#statusline#Update(self.jobdir, status)

FUNCTION  <SNR>142_AbsoluteVimPath()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:192
Called 48 times
Total time:   0.004977000
 Self time:   0.004925000

count     total (s)      self (s)
   48                 0.000173000   if a:0 && type(a:1) == type('')
                                      let path = a:1
   48                 0.000034000   else
   48                 0.000180000     let path = bufname(a:0 && a:1 > 0 ? a:1 : '')
   48                 0.000502000     if getbufvar(a:0 && a:1 > 0 ? a:1 : '', '&buftype') !~# '^\%(nowrite\|acwrite\)\=$'
   24                 0.000028000       return path
   24                 0.000015000     endif
   24                 0.000010000   endif
   24   0.000299000   0.000247000   if s:Slash(path) =~# '^/\|^\a\+:'
    2                 0.000002000     return path
   22                 0.000016000   else
   22                 0.003501000     return getcwd() . matchstr(getcwd(), '[\\/]') . path
                                    endif

FUNCTION  ale#util#Mode()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:5
Called 80 times
Total time:   0.000562000
 Self time:   0.000562000

count     total (s)      self (s)
   80                 0.000459000     return call('mode', a:000)

FUNCTION  <SNR>90_Setup()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:320
Called 18 times
Total time:   0.013651000
 Self time:   0.000630000

count     total (s)      self (s)
   18                 0.000058000     if &filetype ==# ""
   10   0.001117000   0.000038000         call s:InitColor()
   18                 0.000010000     endif
                                  
   18   0.000701000   0.000114000     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
   18   0.010952000   0.000092000         call s:IndentLinesEnable()
   18                 0.000014000     endif
                                  
   18   0.000665000   0.000170000     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                          call s:LeadingSpaceEnable()
   18                 0.000013000     endif

FUNCTION  <SNR>62_handle_ambidouble()
    Defined: ~/.fzf/plugin/fzf.vim:852
Called 2 times
Total time:   0.000050000
 Self time:   0.000050000

count     total (s)      self (s)
    2                 0.000008000   if &ambiwidth == 'double'
                                      let a:dict.env = { 'RUNEWIDTH_EASTASIAN': '1' }
    2                 0.000013000   elseif !s:warned && $RUNEWIDTH_EASTASIAN == '1' && &ambiwidth !=# 'double'
                                      call s:warn("$RUNEWIDTH_EASTASIAN is '1' but &ambiwidth is not 'double'")
                                      2sleep
                                      let s:warned = 1
    2                 0.000003000   endif

FUNCTION  <SNR>43_ResolveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:405
Called 254 times
Total time:   0.015561000
 Self time:   0.008773000

count     total (s)      self (s)
  254                 0.003108000   let type = getftype(a:git_dir)
  254   0.007950000   0.001162000   if type ==# 'dir' && FugitiveIsGitDir(a:git_dir)
  128                 0.000235000     return a:git_dir
  126                 0.000316000   elseif type ==# 'link' && FugitiveIsGitDir(a:git_dir)
                                      return resolve(a:git_dir)
  126                 0.000172000   elseif type !=# ''
                                      let line = get(s:ReadFile(a:git_dir, 1), 0, '')
                                      let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                      if file_dir !~# '^/\|^\a:\|^$' && a:git_dir =~# '/\.git$' && FugitiveIsGitDir(a:git_dir[0:-5] . file_dir)
                                        return simplify(a:git_dir[0:-5] . file_dir)
                                      elseif file_dir =~# '^/\|^\a:' && FugitiveIsGitDir(file_dir)
                                        return file_dir
                                      endif
  126                 0.000080000   endif
  126                 0.000129000   return ''

FUNCTION  <SNR>62_create_popup()
    Defined: ~/.fzf/plugin/fzf.vim:1019
Called 2 times
Total time:   0.000145000
 Self time:   0.000145000

count     total (s)      self (s)
    2                 0.000073000     let s:popup_create = {buf -> popup_create(buf, #{ line: a:opts.row, col: a:opts.col, minwidth: a:opts.width, maxwidth: a:opts.width, minheight: a:opts.height, maxheight: a:opts.height, zindex: 1000, })}
    2                 0.000066000     autocmd TerminalOpen * ++once call s:popup_create(str2nr(expand('<abuf>')))

FUNCTION  go#auto#fmt_autosave()
    Defined: ~/.vim/plugged/vim-go/autoload/go/auto.vim:148
Called 9 times
Total time:  48.704535000
 Self time:   0.003793000

count     total (s)      self (s)
    9                 0.003061000   if !(isdirectory(expand('%:p:h')) && resolve(expand('<afile>:p')) == expand('%:p'))
                                      return
    9                 0.000011000   endif
                                  
    9   0.000177000   0.000102000   if !(go#config#FmtAutosave() || go#config#ImportsAutosave())
                                      return
    9                 0.000010000   endif
                                  
                                    " Order matters when formatting and adjusting imports, because of gopls'
                                    " support for gofumpt. Gofumpt formatting will group all imports that look
                                    " like a stdlib package (e.g. there's no '.' in the package path) together.
                                    " When the local setting is provided, the only way to get the local imports
                                    " grouped separately when gofumpt is used to format is to format first and
                                    " then organize imports.
                                  
    9   0.000524000   0.000248000   if go#config#FmtAutosave() && !(go#config#ImportsAutosave() && go#config#ImportsMode() == 'goimports')
    9  48.700496000   0.000173000     call go#fmt#Format(0)
                                  
                                      " return early when the imports mode is goimports, because there's no need
                                      " to format again when goimports was run
    9   0.000095000   0.000027000     if go#config#FmtCommand() == 'goimports'
    9                 0.000007000       return
                                      endif
                                    endif
                                  
                                    if !go#config#ImportsAutosave()
                                      return
                                    endif
                                  
                                    call go#fmt#Format(1)

FUNCTION  <SNR>62_compare_versions()
    Defined: ~/.fzf/plugin/fzf.vim:184
Called 4 times
Total time:   0.000205000
 Self time:   0.000205000

count     total (s)      self (s)
    4                 0.000030000   let a = split(a:a, '\.')
    4                 0.000017000   let b = split(a:b, '\.')
    8                 0.000039000   for idx in range(0, max([len(a), len(b)]) - 1)
    8                 0.000032000     let v1 = str2nr(get(a, idx, 0))
    8                 0.000026000     let v2 = str2nr(get(b, idx, 0))
   10                 0.000019000     if     v1 < v2 | return -1
    8                 0.000018000     elseif v1 > v2 | return 1
    4                 0.000004000     endif
    4                 0.000005000   endfor
                                    return 0

FUNCTION  <SNR>172_is_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:269
Called 77 times
Total time:   0.000102000
 Self time:   0.000102000

count     total (s)      self (s)
   77                 0.000086000   return a:from_count == 0 && a:to_count > 0

FUNCTION  299()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:133
Called 6 times
Total time:   0.012847000
 Self time:   0.000872000

count     total (s)      self (s)
    6                 0.000260000       let self.buf .= a:data
                                  
    6   0.002503000   0.000170000       let [self.buf, l:messages] = self.readMessage(self.buf)
                                  
   12                 0.000033000       for l:message in l:messages
    6                 0.000026000         if has_key(l:message, 'method')
    6                 0.000018000           if has_key(l:message, 'id')
                                              call self.handleRequest(l:message)
    6                 0.000011000           else
    6   0.009697000   0.000055000             call self.handleNotification(l:message)
    6                 0.000007000           endif
                                          elseif has_key(l:message, 'result') || has_key(l:message, 'error')
                                            call self.handleResponse(l:message)
    6                 0.000007000         endif
   12                 0.000023000       endfor

FUNCTION  <SNR>51_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:347
Called 30 times
Total time:   0.006648000
 Self time:   0.001690000

count     total (s)      self (s)
   30   0.006618000   0.001660000   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>62_execute_term()
    Defined: ~/.fzf/plugin/fzf.vim:862
Called 2 times
Total time:   0.156495000
 Self time:   0.008899000

count     total (s)      self (s)
    2                 0.000019000   let winrest = winrestcmd()
    2                 0.000010000   let pbuf = bufnr('')
    2   0.000877000   0.000029000   let [ppos, winopts, is_popup] = s:split(a:dict)
    2   0.000137000   0.000013000   call s:use_sh()
    2                 0.000037000   let b:fzf = a:dict
    2                 0.000038000   let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps, 'winopts': winopts, 'winrest': winrest, 'lines': &lines, 'columns': &columns, 'command': a:command }
    2                 0.000017000   function! fzf.switch_back(inplace)
                                      if a:inplace && bufnr('') == self.buf
                                        if bufexists(self.pbuf)
                                          execute 'keepalt keepjumps b' self.pbuf
                                        endif
                                        " No other listed buffer
                                        if bufnr('') == self.buf
                                          enew
                                        endif
                                      endif
                                    endfunction
    2                 0.000007000   function! fzf.on_exit(id, code, ...)
                                      if s:getpos() == self.ppos " {'window': 'enew'}
                                        for [opt, val] in items(self.winopts)
                                          execute 'let' opt '=' val
                                        endfor
                                        call self.switch_back(1)
                                      else
                                        if bufnr('') == self.buf
                                          " We use close instead of bd! since Vim does not close the split when
                                          " there's no other listed buffer (nvim +'set nobuflisted')
                                          close
                                        endif
                                        silent! execute 'tabnext' self.ppos.tab
                                        silent! execute self.ppos.win.'wincmd w'
                                      endif
                                  
                                      if bufexists(self.buf)
                                        execute 'bd!' self.buf
                                      endif
                                  
                                      if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                        execute self.winrest
                                      endif
                                  
                                      let lines = s:collect(self.temps)
                                      if !s:exit_handler(a:code, self.command, 1)
                                        return
                                      endif
                                  
                                      call s:pushd(self.dict)
                                      call s:callback(self.dict, lines)
                                      call self.switch_back(s:getpos() == self.ppos)
                                  
                                      if &buftype == 'terminal'
                                        call feedkeys(&filetype == 'fzf' ? "\<Plug>(fzf-insert)" : "\<Plug>(fzf-normal)")
                                      endif
                                    endfunction
                                  
    2                 0.000002000   try
    2   0.000946000   0.000021000     call s:pushd(a:dict)
    2                 0.000004000     if s:is_win
                                        let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                        call s:writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                        let command = fzf.temps.batchfile
    2                 0.000003000     else
    2                 0.000007000       let command = a:command
    2                 0.000003000     endif
    2                 0.000009000     let command .= s:term_marker
    2                 0.000012000     if has('nvim')
                                        call s:handle_ambidouble(fzf)
                                        call termopen(command, fzf)
    2                 0.000002000     else
    2                 0.000032000       let term_opts = {'exit_cb': function(fzf.on_exit)}
    2                 0.000007000       if v:version >= 802
    2                 0.000006000         let term_opts.term_kill = 'term'
    2                 0.000002000       endif
    2                 0.000003000       if is_popup
    2                 0.000005000         let term_opts.hidden = 1
                                        else
                                          let term_opts.curwin = 1
    2                 0.000002000       endif
    2   0.000069000   0.000019000       call s:handle_ambidouble(term_opts)
    2   0.145554000   0.008319000       keepjumps let fzf.buf = term_start([&shell, &shellcmdflag, command], term_opts)
    2                 0.000005000       if is_popup && exists('#TerminalWinOpen')
                                          doautocmd <nomodeline> TerminalWinOpen
    2                 0.000001000       endif
    2                 0.000009000       if !has('patch-8.0.1261') && !s:is_win
                                          call term_wait(fzf.buf, 20)
    2                 0.000000000       endif
    2                 0.000002000     endif
    2                 0.000010000     tnoremap <buffer> <c-z> <nop>
    2                 0.000004000     if exists('&termwinkey') && (empty(&termwinkey) || &termwinkey =~? '<c-w>')
    2                 0.000010000       tnoremap <buffer> <c-w> <c-w>.
    2                 0.000000000     endif
    2                 0.000002000   finally
    2   0.000012000   0.000005000     call s:dopopd()
    2                 0.000000000   endtry
    2   0.000288000   0.000023000   setlocal nospell bufhidden=wipe nobuflisted nonumber
    2   0.008146000   0.000004000   setf fzf
    2                 0.000005000   startinsert
    2                 0.000002000   return []

FUNCTION  airline#util#is_popup_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:214
Called 76 times
Total time:   0.000775000
 Self time:   0.000775000

count     total (s)      self (s)
                                     " Keep the statusline active if it's a popup window
   76                 0.000236000    if exists('*win_gettype')
   76                 0.000369000      return win_gettype(a:winnr) ==# 'popup' || win_gettype(a:winnr) ==# 'autocmd'
                                     else
                                        return airline#util#getwinvar(a:winnr, '&buftype', '') ==# 'popup'
                                    endif

FUNCTION  go#fmt#run()
    Defined: ~/.vim/plugged/vim-go/autoload/go/fmt.vim:150
Called 9 times
Total time:  48.519654000
 Self time:   0.000368000

count     total (s)      self (s)
    9   0.001112000   0.000181000   let l:cmd = s:fmt_cmd(a:bin_name, a:source, a:target)
    9                 0.000029000   if empty(l:cmd)
                                      return
    9                 0.000008000   endif
    9  48.518474000   0.000119000   return go#util#Exec(l:cmd)

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:125
Called 54 times
Total time:   0.001150000
 Self time:   0.000457000

count     total (s)      self (s)
   54   0.000965000   0.000272000   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   54                 0.000151000   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>74_exec()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:266
Called 9 times
Total time:  48.491336000
 Self time:   0.000718000

count     total (s)      self (s)
    9                 0.000038000   let l:bin = a:cmd[0]
    9   0.001847000   0.000145000   let l:cmd = go#util#Shelljoin([l:bin] + a:cmd[1:])
    9   0.000270000   0.000070000   if go#util#HasDebug('shell-commands')
                                      call go#util#EchoInfo('shell command: ' . l:cmd)
    9                 0.000009000   endif
                                  
    9  48.488919000   0.000234000   let l:out = call('s:system', [l:cmd] + a:000)
    9   0.000194000   0.000163000   return [l:out, go#util#ShellError()]

FUNCTION  gitgutter#utility#git_supports_command_line_config_override()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:10
Called 11 times
Total time:   0.000143000
 Self time:   0.000143000

count     total (s)      self (s)
   11                 0.000050000   if !exists('s:c_flag')
                                      let [_, error_code] = gitgutter#utility#system(gitgutter#git().' -c foo.bar=baz --version')
                                      let s:c_flag = !error_code
   11                 0.000008000   endif
   11                 0.000014000   return s:c_flag

FUNCTION  <SNR>124_evaluate_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:209
Called 181 times
Total time:   0.020436000
 Self time:   0.008562000

count     total (s)      self (s)
  181                 0.000308000   let tabline = a:tabline
  181   0.014088000   0.002214000   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
  181                 0.001576000   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
  181                 0.001125000   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
  181                 0.000746000   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
  181                 0.000589000   let tabline = substitute(tabline, '%=', '', 'g')
  181                 0.000576000   let tabline = substitute(tabline, '%\d*\*', '', 'g')
  181                 0.000563000   if has('tablineat')
                                      let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
  181                 0.000097000   endif
  181                 0.000162000   return tabline

FUNCTION  airline#async#vim_vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:207
Called 20 times
Total time:   0.015010000
 Self time:   0.015010000

count     total (s)      self (s)
   20                 0.000025000     if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                        let cmd = a:config['cmd'] . shellescape(a:file)
   20                 0.000007000     else
   20                 0.000094000       let cmd = [&shell, &shellcmdflag, a:config['cmd'] . shellescape(a:file)]
   20                 0.000006000     endif
                                  
   20                 0.000065000     let options = {'cfg': a:config, 'buf': '', 'file': a:file}
   20                 0.000049000     if has_key(s:untracked_jobs, a:file)
   11                 0.000104000       if job_status(get(s:untracked_jobs, a:file)) == 'run'
   10                 0.000007000         return
    1                 0.000002000       elseif has_key(s:untracked_jobs, a:file)
    1                 0.000003000         call remove(s:untracked_jobs, a:file)
    1                 0.000000000       endif
   10                 0.000000000     endif
   10                 0.014202000     let id = job_start(cmd, { 'err_io':   'out', 'out_cb':   function('s:on_stdout', options), 'close_cb': function('s:on_exit_untracked', options)})
   10                 0.000170000     let s:untracked_jobs[a:file] = id

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:63
Called 11 times
Total time:   0.117398000
 Self time:   0.004104000

count     total (s)      self (s)
   11   0.000324000   0.000089000   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                      throw 'gitgutter path not set'
   11                 0.000008000   endif
                                  
   11   0.000244000   0.000042000   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                      throw 'gitgutter not tracked'
   11                 0.000007000   endif
                                  
   11   0.000236000   0.000038000   if gitgutter#utility#repo_path(a:bufnr, 0) == -3
                                      throw 'gitgutter assume unchanged'
   11                 0.000006000   endif
                                  
                                    " Wrap compound commands in parentheses to make Windows happy.
                                    " bash doesn't mind the parentheses.
   11                 0.000016000   let cmd = '('
                                  
                                    " Append buffer number to temp filenames to avoid race conditions between
                                    " writing and reading the files when asynchronously processing multiple
                                    " buffers.
                                  
                                    " Without the buffer number, buff_file would have a race between the
                                    " second gitgutter#process_buffer() writing the file (synchronously, below)
                                    " and the first gitgutter#process_buffer()'s async job reading it (with
                                    " git-diff).
   11                 0.000053000   let buff_file = s:temp_buffer.'.'.a:bufnr
                                  
                                    " Add a counter to avoid a similar race with two quick writes of the same buffer.
                                    " Use a modulus greater than a maximum reasonable number of visible buffers.
   11                 0.000115000   let s:counter = (s:counter + 1) % 20
   11                 0.000044000   let buff_file .= '.'.s:counter
                                  
   11   0.001397000   0.000081000   let extension = gitgutter#utility#extension(a:bufnr)
   11                 0.000028000   if !empty(extension)
   11                 0.000031000     let buff_file .= '.'.extension
   11                 0.000006000   endif
                                  
                                    " Write buffer to temporary file.
                                    " Note: this is synchronous.
   11   0.062937000   0.000317000   call s:write_buffer(a:bufnr, buff_file)
                                  
   11                 0.000074000   if a:from ==# 'index'
                                      " Without the buffer number, from_file would have a race in the shell
                                      " between the second process writing it (with git-show) and the first
                                      " reading it (with git-diff).
   11                 0.000170000     let from_file = s:temp_from.'.'.a:bufnr
                                  
                                      " Add a counter to avoid a similar race with two quick writes of the same buffer.
   11                 0.000048000     let from_file .= '.'.s:counter
                                  
   11                 0.000050000     if !empty(extension)
   11                 0.000027000       let from_file .= '.'.extension
   11                 0.000012000     endif
                                  
                                      " Write file from index to temporary file.
   11   0.005563000   0.000316000     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#base_path(a:bufnr)
   11   0.000238000   0.000146000     let cmd .= gitgutter#git().' --no-pager show --textconv '.index_name.' > '.from_file.' || exit 0) && ('
                                  
                                    elseif a:from ==# 'working_tree'
                                      let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
   11                 0.000010000   endif
                                  
                                    " Call git-diff.
   11   0.000106000   0.000057000   let cmd .= gitgutter#git().' --no-pager'
   11   0.000229000   0.000086000   if gitgutter#utility#git_supports_command_line_config_override()
   11                 0.000043000     let cmd .= ' -c "diff.autorefreshindex=0"'
   11                 0.000038000     let cmd .= ' -c "diff.noprefix=false"'
   11                 0.000033000     let cmd .= ' -c "core.safecrlf=false"'
   11                 0.000008000   endif
   11                 0.000109000   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                                  
                                    " Pipe git-diff output into grep.
   11                 0.000039000   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
   11   0.000506000   0.000075000     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
   11                 0.000007000   endif
                                  
                                    " grep exits with 1 when no matches are found; git-diff exits with 1 when
                                    " differences are found.  However we want to treat non-matches and
                                    " differences as non-erroneous behaviour; so we OR the command with one
                                    " which always exits with success (0).
   11                 0.000042000   let cmd .= ' || exit 0'
                                  
   11                 0.000022000   let cmd .= ')'
                                  
   11   0.003342000   0.000090000   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                                  
   11   0.000117000   0.000074000   if g:gitgutter_async && gitgutter#async#available()
   11   0.040223000   0.000757000     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
   11                 0.000099000     return 'async'
                                  
                                    else
                                      let [diff, error_code] = gitgutter#utility#system(cmd)
                                  
                                      if error_code
                                        call gitgutter#debug#log(diff)
                                        throw 'gitgutter diff failed'
                                      endif
                                  
                                      return diff
                                    endif

FUNCTION  <SNR>51_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:338
Called 34 times
Total time:   0.004755000
 Self time:   0.000447000

count     total (s)      self (s)
   34   0.004717000   0.000409000   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  16()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:305
Called 16 times
Total time:   0.000192000
 Self time:   0.000111000

count     total (s)      self (s)
   16   0.000121000   0.000040000     if nerdtree#runningWindows()
                                          return " `\|\"#%&,?()\*^<>$"
   16                 0.000011000     endif
                                  
   16                 0.000021000     return " \\`\|\"#%&,?()\*^<>[]{}$"

FUNCTION  <SNR>55_Map()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim:157
Called 27 times
Total time:   0.025735000
 Self time:   0.001627000

count     total (s)      self (s)
                                    " Set mappings:
   27                 0.000021000   try
   27                 0.000039000     let save_keymap = &keymap
   27                 0.000054000     let save_iminsert = &iminsert
   27                 0.000030000     let save_imsearch = &imsearch
   27                 0.000044000     let save_cpo = &cpo
   27                 0.000173000     set keymap=
   27                 0.000063000     set cpo&vim
   27   0.000495000   0.000269000     silent! doautocmd <nomodeline> User delimitMate_map
   27   0.000622000   0.000136000     if s:get('autoclose', 1)
   27   0.017237000   0.000109000       call s:AutoClose()
                                      else
                                        call s:NoAutoClose()
   27                 0.000013000     endif
   27   0.006352000   0.000084000     call s:ExtraMappings()
   27                 0.000029000   finally
   27                 0.000103000     let &cpo = save_cpo
   27                 0.000094000     let &keymap = save_keymap
   27                 0.000136000     let &iminsert = save_iminsert
   27                 0.000067000     let &imsearch = save_imsearch
   27                 0.000021000   endtry
                                  
   27                 0.000037000   let b:delimitMate_enabled = 1

FUNCTION  <SNR>142_ReloadWinStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:4301
Called 19 times
Total time:   0.000086000
 Self time:   0.000086000

count     total (s)      self (s)
   19                 0.000066000   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
   19                 0.000011000     return
                                    endif
                                    if !exists('b:fugitive_reltime')
                                      exe s:ReloadStatusBuffer()
                                      return
                                    endif
                                    let t = b:fugitive_reltime
                                    if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:Tree() . '/', t), t)) =~# '-\|\d\{10\}\.'
                                      exe s:ReloadStatusBuffer()
                                    endif

FUNCTION  <SNR>172_is_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 33 times
Total time:   0.000056000
 Self time:   0.000056000

count     total (s)      self (s)
   33                 0.000049000   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  go#config#AutoTypeInfo()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:323
Called 9 times
Total time:   0.000049000
 Self time:   0.000049000

count     total (s)      self (s)
    9                 0.000035000   return get(g:, "go_auto_type_info", 0)

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 72 times
Total time:   0.001926000
 Self time:   0.000531000

count     total (s)      self (s)
   72   0.001862000   0.000467000   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:34
Called 428 times
Total time:   0.009117000
 Self time:   0.009117000

count     total (s)      self (s)
  428                 0.001584000     let buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
  428                 0.001193000     let buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
                                  
  428                 0.001107000     let _ = buf_nr_show ? printf(buf_nr_format, a:bufnr) : ''
  428                 0.002008000     let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                                  
  428                 0.001300000     if getbufvar(a:bufnr, '&modified') == 1
                                        let _ .= g:airline_symbols.modified
  428                 0.000224000     endif
  428                 0.000390000     return _

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:360
Called 13 times
Total time:   0.000169000
 Self time:   0.000169000

count     total (s)      self (s)
   13                 0.000142000   return has('win64') || has('win32') || has('win16')

FUNCTION  <SNR>103_ale_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:130
Called 10 times
Total time:   0.103478000
 Self time:   0.000222000

count     total (s)      self (s)
   10                 0.000037000   if !exists('#airline')
                                      " airline disabled
                                      return
   10                 0.000005000   endif
   10                 0.000024000   if get(g:, 'airline_skip_empty_sections', 0)
   10   0.103385000   0.000129000     exe ':AirlineRefresh!'
   10                 0.000004000   endif

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:147
Called 154 times
Total time:   0.006989000
 Self time:   0.006989000

count     total (s)      self (s)
  154                 0.002028000   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  154                 0.000850000   if g:airline_detect_spell && (&spell || (exists('g:airline_spell_check_command') && eval(g:airline_spell_check_command)))
                                  
                                      if g:airline_detect_spelllang !=? '0' && g:airline_detect_spelllang ==? 'flag'
                                        let spelllang = tolower(&spelllang)
                                        if has_key(s:flags, spelllang)
                                          return s:flags[spelllang]
                                        elseif has_key(s:flags_noregion, spelllang)
                                          return s:flags_noregion[spelllang]
                                        endif
                                      endif
                                  
                                      let winwidth = airline#util#winwidth()
                                      if winwidth >= 90
                                        return g:airline_symbols.spell . spelllang
                                      elseif winwidth >= 70
                                        return g:airline_symbols.spell
                                      elseif !empty(g:airline_symbols.spell)
                                        return split(g:airline_symbols.spell, '\zs')[0]
                                      endif
  154                 0.000099000   endif
  154                 0.000128000   return ''

FUNCTION  go#config#ImportsMode()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:343
Called 9 times
Total time:   0.000203000
 Self time:   0.000130000

count     total (s)      self (s)
    9   0.000188000   0.000115000   return get(g:, "go_imports_mode", go#config#GoplsEnabled() ? 'gopls' : 'goimports')

FUNCTION  ale#linter#GetAll()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:278
Called 12 times
Total time:   0.004484000
 Self time:   0.003619000

count     total (s)      self (s)
                                      " Don't return linters in the sandbox.
                                      " Otherwise a sandboxed script could modify them.
   12   0.000185000   0.000047000     if ale#util#InSandbox()
                                          return []
   12                 0.000006000     endif
                                  
   12                 0.000014000     let l:combined_linters = []
                                  
   24                 0.000028000     for l:filetype in a:filetypes
                                          " Load linters from runtimepath if we haven't done that yet.
   12                 0.000084000         if !has_key(s:runtime_loaded_map, l:filetype)
    2   0.003835000   0.003108000             execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                                  
    2                 0.000019000             let s:runtime_loaded_map[l:filetype] = 1
   12                 0.000004000         endif
                                  
   12                 0.000108000         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   24                 0.000012000     endfor
                                  
   12                 0.000010000     return l:combined_linters

FUNCTION  airline#extensions#tabline#load_theme()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:82
Called 2 times
Total time:   0.004661000
 Self time:   0.000167000

count     total (s)      self (s)
    2                 0.000004000     if pumvisible()
                                        return
    2                 0.000000000     endif
    2                 0.000009000     let colors    = get(a:palette, 'tabline', {})
    2                 0.000005000     let tablabel  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
                                      " Theme for tabs on the left
    2                 0.000004000     let tab     = get(colors, 'airline_tab', a:palette.inactive.airline_c)
    2                 0.000003000     let tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
    2                 0.000005000     let tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
    2                 0.000002000     let tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
    2                 0.000006000     let tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
    2                 0.000004000     let tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
    2                 0.000004000     if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
                                        let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
                                        let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
    2                 0.000002000     else
                                        "Fall back to normal airline_c if modified airline_c isn't present
    2                 0.000004000       let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
    2                 0.000004000       let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
    2                 0.000000000     endif
    2   0.000335000   0.000006000     call airline#highlighter#exec('airline_tablabel', tablabel)
    2   0.000322000   0.000003000     call airline#highlighter#exec('airline_tab', tab)
    2   0.000325000   0.000005000     call airline#highlighter#exec('airline_tabsel', tabsel)
    2   0.000325000   0.000004000     call airline#highlighter#exec('airline_tabtype', tabtype)
    2   0.000327000   0.000010000     call airline#highlighter#exec('airline_tabfill', tabfill)
    2   0.000322000   0.000004000     call airline#highlighter#exec('airline_tabmod', tabmod)
    2   0.000331000   0.000005000     call airline#highlighter#exec('airline_tabmod_unsel', tabmodu)
    2   0.000320000   0.000003000     call airline#highlighter#exec('airline_tabhid', tabhid)
                                  
                                      " Theme for tabs on the right
                                      " label on the right
    2                 0.000004000     let tablabel_r  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
    2                 0.000005000     let tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
    2                 0.000004000     let tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
    2                 0.000003000     let tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
    2                 0.000006000     let tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
    2   0.000330000   0.000006000     call airline#highlighter#exec('airline_tablabel_right', tablabel_r)
    2   0.000324000   0.000004000     call airline#highlighter#exec('airline_tab_right',    tab_right)
    2   0.000326000   0.000004000     call airline#highlighter#exec('airline_tabsel_right', tabsel_right)
    2   0.000326000   0.000005000     call airline#highlighter#exec('airline_tabmod_right', tabmod_right)
    2   0.000324000   0.000005000     call airline#highlighter#exec('airline_tabhid_right', tabhid_right)
    2   0.000327000   0.000006000     call airline#highlighter#exec('airline_tabmod_unsel_right', tabmodu_right)

FUNCTION  <SNR>147_BufferCacheExists()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:88
Called 110 times
Total time:   0.000627000
 Self time:   0.000627000

count     total (s)      self (s)
  110                 0.000477000     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
  110                 0.000096000         return 0
                                      endif
                                  
                                      return 1

FUNCTION  fzf#shellescape()
    Defined: ~/.fzf/plugin/fzf.vim:101
Called 29 times
Total time:   0.001325000
 Self time:   0.001010000

count     total (s)      self (s)
   29                 0.000141000   let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
   29                 0.000114000   if shell =~# 'cmd.exe$'
                                      return s:shellesc_cmd(a:arg)
   29                 0.000025000   endif
   29                 0.000022000   try
   29   0.000266000   0.000175000     let [shell, &shell] = [&shell, shell]
   29   0.000323000   0.000153000     return s:fzf_call('shellescape', a:arg)
   29                 0.000037000   finally
   29   0.000203000   0.000149000     let [shell, &shell] = [&shell, shell]
   29                 0.000037000   endtry

FUNCTION  <SNR>175_listtype()
    Defined: ~/.vim/plugged/vim-go/autoload/go/list.vim:134
Called 8 times
Total time:   0.000118000
 Self time:   0.000082000

count     total (s)      self (s)
    8   0.000073000   0.000037000   let listtype = go#config#ListType()
    8                 0.000007000   if empty(listtype)
                                      return a:listtype
    8                 0.000003000   endif
                                  
    8                 0.000004000   return listtype

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:25
Called 72 times
Total time:   0.001797000
 Self time:   0.001797000

count     total (s)      self (s)
   72                 0.000367000   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                      let sections = s:GetAirlineSection()
                                      let spc = g:airline_symbols.space
                                      call a:1.add_section_spaced('airline_a', sections[0])
                                      call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                      call a:1.add_section('airline_term', spc.s:termname(a:2.bufnr))
                                      call a:1.split()
                                      call a:1.add_section('airline_y', '')
                                      call a:1.add_section_spaced('airline_z', sections[1])
                                      return 1
   72                 0.000039000   endif

FUNCTION  <lambda>70()
    Defined: ~/.fzf/plugin/fzf.vim:1020
Called 1 time
Total time:   0.000069000
 Self time:   0.000069000

count     total (s)      self (s)
                                  return popup_create(buf, #{ line: a:opts.row, col: a:opts.col, minwidth: a:opts.width, maxwidth: a:opts.width, minheight: a:opts.height, maxheight: a:opts.height, zindex: 1000, })

FUNCTION  <SNR>62_popup_support()
    Defined: ~/.fzf/plugin/fzf.vim:137
Called 4 times
Total time:   0.000080000
 Self time:   0.000080000

count     total (s)      self (s)
    4                 0.000075000   return has('nvim') ? has('nvim-0.4') : has('popupwin') && has('patch-8.2.191')

FUNCTION  200()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:280
Called 2 times
Total time:   0.001129000
 Self time:   0.000151000

count     total (s)      self (s)
    2                 0.000007000     let path = {}
    2   0.000286000   0.000038000     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                          let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
    2                 0.000001000     else
    2                 0.000008000         let dir = a:str ==# '' ? getcwd() : a:str
                                  
                                          "hack to get an absolute path if a relative path is given
    2                 0.000009000         if dir =~# '^\.'
                                              let dir = getcwd() . nerdtree#slash() . dir
    2                 0.000002000         endif
                                  
                                          "hack to prevent removing slash if dir is the root of the file system.
    2                 0.000003000         if dir !=# '/'
    2   0.000055000   0.000010000             let dir = g:NERDTreePath.Resolve(dir)
    2                 0.000002000         endif
                                  
    2                 0.000003000         try
    2   0.000695000   0.000010000             let path = g:NERDTreePath.New(dir)
                                          catch /^NERDTree.InvalidArgumentsError/
                                              call nerdtree#echo('No bookmark or directory found for: ' . a:str)
                                              return {}
    2                 0.000003000         endtry
    2                 0.000002000     endif
    2                 0.000004000     if !path.isDirectory
                                          let path = path.getParent()
    2                 0.000002000     endif
                                  
    2                 0.000004000     return path

FUNCTION  202()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:329
Called 2 times
Total time:   0.023112000
 Self time:   0.001329000

count     total (s)      self (s)
                                  
                                      " Options for a non-file/control buffer.
    2   0.000006000   0.000005000     setlocal bufhidden=hide
    2   0.000004000   0.000002000     setlocal buftype=nofile
    2   0.001229000   0.001226000     setlocal noswapfile
                                  
                                      " Options for controlling buffer/window appearance.
    2                 0.000005000     setlocal foldcolumn=0
    2   0.000010000   0.000009000     setlocal foldmethod=manual
    2   0.000288000   0.000004000     setlocal nobuflisted
    2                 0.000004000     setlocal nofoldenable
    2   0.000011000   0.000010000     setlocal nolist
    2   0.000005000   0.000003000     setlocal nospell
    2   0.000004000   0.000003000     setlocal nowrap
                                  
    2                 0.000002000     if g:NERDTreeShowLineNumbers
                                          setlocal number
    2                 0.000001000     else
    2                 0.000006000         setlocal nonumber
    2                 0.000002000         if v:version >= 703
    2                 0.000004000             setlocal norelativenumber
    2                 0.000002000         endif
    2                 0.000000000     endif
                                  
    2                 0.000002000     iabc <buffer>
                                  
    2                 0.000002000     if g:NERDTreeHighlightCursorline
    2                 0.000008000         setlocal cursorline
    2                 0.000001000     endif
                                  
    2   0.000021000   0.000006000     call self._setupStatusline()
    2   0.002934000   0.000009000     call self._bindMappings()
                                  
    2   0.018552000   0.000004000     setlocal filetype=nerdtree

FUNCTION  203()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:367
Called 2 times
Total time:   0.000015000
 Self time:   0.000013000

count     total (s)      self (s)
    2                 0.000002000     if g:NERDTreeStatusline != -1
    2   0.000009000   0.000007000         let &l:statusline = g:NERDTreeStatusline
    2                 0.000000000     endif

FUNCTION  205()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:395
Called 1 time
Total time:   0.024291000
 Self time:   0.000028000

count     total (s)      self (s)
    1   0.000052000   0.000018000     let creator = s:Creator.New()
    1   0.024237000   0.000008000     call creator.toggleTabTree(a:dir)

FUNCTION  206()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:408
Called 1 time
Total time:   0.024229000
 Self time:   0.000082000

count     total (s)      self (s)
    1   0.000066000   0.000007000     if g:NERDTree.ExistsForTab()
    1   0.000059000   0.000009000         if !g:NERDTree.IsOpen()
                                              call self._createTreeWin()
                                              if !empty(a:dir) && a:dir !=# b:NERDTree.root.path.str()
                                                  call self.createTabTree(a:dir)
                                              elseif !&hidden
                                                  call b:NERDTree.render()
                                              endif
                                              call b:NERDTree.ui.restoreScreenState()
    1                 0.000001000         else
    1   0.024061000   0.000023000             call g:NERDTree.Close()
    1                 0.000000000         endif
                                      else
                                          call self.createTabTree(a:dir)
    1                 0.000000000     endif

FUNCTION  <SNR>117_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 1255 times
Total time:   0.154848000
 Self time:   0.077284000

count     total (s)      self (s)
 1255                 0.001628000   let start=1
                                  
                                    " do not check for inactive windows or the tabline
 1255                 0.001810000   if a:self._context.active == 0
  349                 0.000326000     return 0
  906                 0.002121000   elseif get(a:self._context, 'tabline', 0)
  331                 0.000241000     return 0
  575                 0.000293000   endif
                                  
                                    " only check, if airline#skip_empty_sections == 1
  575                 0.001284000   if get(g:, 'airline_skip_empty_sections', 0) == 0
                                      return 0
  575                 0.000305000   endif
                                  
                                    " only check, if airline#skip_empty_sections == 1
  575                 0.001308000   if get(w:, 'airline_skip_empty_sections', -1) == 0
                                      return 0
  575                 0.000270000   endif
                                  
                                    " special case: When the content is %=, that is the
                                    " separation marker, which switches between left- and
                                    " right-aligned content.
                                    " Consider that to be empty, so that the previous previous
                                    " group is correctly remembered in the builder() function
  575                 0.001455000   if empty(a:content) || a:content is# '%='
   97                 0.000069000     return 1
  478                 0.000266000   endif
                                  
  478                 0.026844000   let stripped = substitute(a:content, '\(%{.*}\|%#__accent_[^#]*#\|%#__restore__#\|%( \| %)\)', '', 'g')
                                  
  478                 0.000949000   if !empty(stripped)
  118                 0.000126000     return 0 " There is content in the statusline
  360                 0.000177000   endif
                                  
  360                 0.000435000   let exprlist = []
  360                 0.014683000   call substitute(a:content, '%{\([^}]*\)}', '\=add(exprlist, submatch(1))', 'g')
                                  
 1092                 0.001295000   for expr in exprlist
  939                 0.000536000     try
                                        " catch all exceptions, just in case
  939   0.083792000   0.006228000       if !empty(eval(expr))
  207                 0.000199000         return 0
  732                 0.000369000       endif
                                      catch
                                        return 0
  939                 0.000613000     endtry
  885                 0.000545000   endfor
  153                 0.000121000   return 1

FUNCTION  <SNR>171_StopCursorTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:67
Called 412 times
Total time:   0.004631000
 Self time:   0.004631000

count     total (s)      self (s)
  412                 0.000909000     if s:cursor_timer != -1
  364                 0.001427000         call timer_stop(s:cursor_timer)
  364                 0.001059000         let s:cursor_timer = -1
  412                 0.000311000     endif

FUNCTION  go#path#FromURI()
    Defined: ~/.vim/plugged/vim-go/autoload/go/path.vim:177
Called 6 times
Total time:   0.000529000
 Self time:   0.000344000

count     total (s)      self (s)
    6                 0.000038000     let l:i = len('file://')
    6                 0.000054000     let l:encoded_path = a:uri[: l:i - 1] is# 'file://' ? a:uri[l:i :] : a:uri
                                  
    6   0.000248000   0.000103000     let l:path = go#uri#Decode(l:encoded_path)
                                  
                                      " If the path is like /C:/foo/bar, it should be C:\foo\bar instead.
    6   0.000109000   0.000069000     if go#util#IsWin() && l:path =~# '^/[a-zA-Z]:'
                                          let l:path = substitute(l:path[1:], '/', '\\', 'g')
    6                 0.000008000     endif
                                  
    6                 0.000012000     return l:path

FUNCTION  <SNR>90_IndentLinesEnable()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:153
Called 18 times
Total time:   0.010860000
 Self time:   0.010396000

count     total (s)      self (s)
   18                 0.000135000     let s:indentSpace = get(g:, 'indentLine_indentSpace', &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth)
   18                 0.000027000     if g:indentLine_newVersion
   18                 0.000061000         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                              return
   18                 0.000013000         endif
                                  
   18                 0.000065000         if !exists("w:indentLine_indentLineId")
    8                 0.000023000             let w:indentLine_indentLineId = []
   18                 0.000007000         endif
                                  
   18   0.000566000   0.000102000         call s:SetConcealOption()
                                  
   18                 0.000030000         if g:indentLine_showFirstIndentLevel
                                              call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
   18                 0.000024000         endif
                                  
   18                 0.000070000         let n = len(g:indentLine_char_list)
   18                 0.000031000         let level = 0
  378                 0.000510000         for i in range(s:indentSpace+1, s:indentSpace * g:indentLine_indentLevel + 1, s:indentSpace)
  360                 0.000419000             if n > 0
                                                  let char = g:indentLine_char_list[level % n]
                                                  let level += 1
  360                 0.000254000             else
  360                 0.000513000                 let char = g:indentLine_char
  360                 0.000210000             endif
  360                 0.005937000             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': char}))
  378                 0.000302000         endfor
                                  
   18                 0.000020000         return
                                      endif
                                  
                                      if exists("b:indentLine_enabled") && b:indentLine_enabled
                                          return
                                      else
                                          let b:indentLine_enabled = 1
                                      endif
                                  
                                      call s:SetConcealOption()
                                  
                                      let g:mysyntaxfile = g:indentLine_mysyntaxfile
                                  
                                      if g:indentLine_showFirstIndentLevel
                                          execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                      endif
                                  
                                      if g:indentLine_faster
                                          execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                          execute 'syntax match IndentLine / \{'.(s:indentSpace-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                          execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                      else
                                          let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                          for i in range(s:indentSpace+1, s:indentSpace * s:indentLine_indentLevel + 1, s:indentSpace)
                                              execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                          endfor
                                      endif

FUNCTION  <SNR>41_IsCurrentWindowNERDTree()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:347
Called 6 times
Total time:   0.000083000
 Self time:   0.000083000

count     total (s)      self (s)
    6                 0.000078000   return exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) == winnr()

FUNCTION  <SNR>172_process_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:298
Called 33 times
Total time:   0.000162000
 Self time:   0.000162000

count     total (s)      self (s)
   33                 0.000027000   if a:to_line == 0
                                      call add(a:modifications, [1, 'removed_first_line'])
   33                 0.000018000   else
   33                 0.000055000     call add(a:modifications, [a:to_line, 'removed'])
   33                 0.000014000   endif

FUNCTION  <SNR>114_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:44
Called 41756 times
Total time:   0.873110000
 Self time:   0.873110000

count     total (s)      self (s)
41756                 0.038912000     let color = ''
41756                 0.167290000     if hlexists(a:group)
38376                 0.226815000       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
41756                 0.020982000     endif
41756                 0.070170000     if empty(color) || color == -1
                                        " should always exist
 3380                 0.024681000       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                        " however, just in case
 3380                 0.005010000       if empty(color) || color == -1
                                          let color = 'NONE'
 3380                 0.001432000       endif
41756                 0.017120000     endif
41756                 0.032219000     return color

FUNCTION  <SNR>188_DetectFromHashBang()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/autoload/dist/script.vim:22
Called 0 times
Total time:   0.000000000
 Self time:   0.000000000

count     total (s)      self (s)
                                    var line1 = firstline
                                  
                                    # Check for a line like "#!/usr/bin/env {options} bash".  Turn it into
                                    # "#!/usr/bin/bash" to make matching easier.
                                    # Recognize only a few {options} that are commonly used.
                                    if line1 =~ '^#!\s*\S*\<env\s'
                                      line1 = substitute(line1, '\S\+=\S\+', '', 'g')
                                      line1 = substitute(line1, '\(-[iS]\|--ignore-environment\|--split-string\)', '', '')
                                      line1 = substitute(line1, '\<env\s\+', '', '')
                                    endif
                                  
                                    # Get the program name.
                                    # Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                                    # If the word env is used, use the first word after the space:
                                    # "#!/usr/bin/env perl [path/args]"
                                    # If there is no path use the first word: "#!perl [path/args]".
                                    # Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                                    var name: string
                                    if line1 =~ '^#!\s*\a:[/\\]'
                                      name = substitute(line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                                    elseif line1 =~ '^#!.*\<env\>'
                                      name = substitute(line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                                    elseif line1 =~ '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                      name = substitute(line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                                    else
                                      name = substitute(line1, '^#!\s*\S*[/\\]\(\f\+\).*', '\1', '')
                                    endif
                                  
                                    # tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                                    # third line.  Suggested by Steven Atkinson.
                                    if getline(3) =~ '^exec wish'
                                      name = 'wish'
                                    endif
                                  
                                    var ft = Exe2filetype(name, line1)
                                    if ft != ''
                                      exe 'setl ft=' .. ft
                                    endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:290
Called 92 times
Total time:   0.002177000
 Self time:   0.001890000

count     total (s)      self (s)
   92                 0.000134000     try
   92   0.001227000   0.000940000         let &l:equalprg=&l:equalprg
                                      catch /E48/
                                          " E48 is the sandbox error.
                                          return 1
   92                 0.000161000     endtry
                                  
   92                 0.000094000     return 0

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:61
Called 154 times
Total time:   0.000931000
 Self time:   0.000931000

count     total (s)      self (s)
  154                 0.000834000   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  211()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:28
Called 499 times
Total time:   0.003414000
 Self time:   0.003414000

count     total (s)      self (s)
  499                 0.001776000     let newObj = copy(self)
  499                 0.000838000     let newObj._flags = {}
  499                 0.000523000     return newObj

FUNCTION  213()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:45
Called 1555 times
Total time:   0.009474000
 Self time:   0.009474000

count     total (s)      self (s)
 1555                 0.001266000     let flagstring = ''
 1555                 0.002393000     for i in values(self._flags)
                                          let flagstring .= join(i)
 1555                 0.000713000     endfor
                                  
 1555                 0.001756000     if len(flagstring) == 0
 1555                 0.000854000         return ''
                                      endif
                                  
                                      return '[' . flagstring . ']'

FUNCTION  215()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:12
Called 1 time
Total time:   0.017078000
 Self time:   0.000037000

count     total (s)      self (s)
    1                 0.000001000     if a:node.path.isDirectory
    1                 0.000002000         let self.root = a:node
                                      else
                                          call a:node.cacheParent()
                                          let self.root = a:node.parent
    1                 0.000001000     endif
                                  
    1   0.010180000   0.000005000     call self.root.open()
                                  
                                      "change dir to the dir of the new root if instructed to
    1                 0.000003000     if g:NERDTreeChDirMode >= 2
    1   0.002122000   0.000002000         call self.root.path.changeToDir()
    1                 0.000000000     endif
                                  
    1   0.004535000   0.000003000     call self.render()
    1   0.000218000   0.000004000     call self.root.putCursorHere(0, 0)
                                  
    1                 0.000006000     if exists('#User#NERDTreeNewRoot')
                                          doautocmd User NERDTreeNewRoot
    1                 0.000000000     endif

FUNCTION  216()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:37
Called 1 time
Total time:   0.024038000
 Self time:   0.000117000

count     total (s)      self (s)
    1   0.000050000   0.000004000     if !s:NERDTree.IsOpen()
                                          return
    1                 0.000001000     endif
                                  
    1                 0.000004000     if winnr('$') !=# 1
                                          " Use the window ID to identify the currently active window or fall
                                          " back on the buffer ID if win_getid/win_gotoid are not available, in
                                          " which case we'll focus an arbitrary window showing the buffer.
    1                 0.000006000         let l:useWinId = exists('*win_getid') && exists('*win_gotoid')
                                  
    1   0.000042000   0.000005000         if winnr() ==# s:NERDTree.GetWinNum()
    1   0.000067000   0.000010000             call nerdtree#exec('wincmd p', 1)
    1                 0.000006000             let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
    1   0.000028000   0.000005000             call nerdtree#exec('wincmd p', 1)
                                          else
                                              let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr('')
    1                 0.000001000         endif
                                  
    1   0.000067000   0.000009000         call nerdtree#exec(s:NERDTree.GetWinNum() . ' wincmd w', 1)
    1   0.023708000   0.000024000         call nerdtree#exec('close', 0)
    1                 0.000008000         if l:useWinId
    1   0.000024000   0.000008000             call nerdtree#exec('call win_gotoid(' . l:activeBufOrWin . ')', 0)
                                          else
                                              call nerdtree#exec(bufwinnr(l:activeBufOrWin) . ' wincmd w', 0)
    1                 0.000001000         endif
                                      else
                                          close
    1                 0.000001000     endif

FUNCTION  nerdtree#closeTreeOnOpen()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:34
Called 10 times
Total time:   0.000047000
 Self time:   0.000047000

count     total (s)      self (s)
   10                 0.000040000     return g:NERDTreeQuitOnOpen == 1 || g:NERDTreeQuitOnOpen == 3

FUNCTION  219()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:100
Called 912 times
Total time:   0.002057000
 Self time:   0.002057000

count     total (s)      self (s)
  912                 0.001811000     return exists('b:NERDTree')

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 154 times
Total time:   0.006010000
 Self time:   0.006010000

count     total (s)      self (s)
  154                 0.001030000   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  154                 0.000532000     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
  154                 0.000655000     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
  154                 0.000412000     let default = get(g:, 'airline#extensions#keymap#default', '')
  154                 0.000231000     if (label !=# '')
  154                 0.000345000       let label .= ' '
  154                 0.000092000     endif
  154                 0.000224000     let keymap = &keymap
  154                 0.000387000     if has_key(short_codes, keymap)
                                        let keymap = short_codes[keymap]
  154                 0.000092000     endif
  154                 0.001181000     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                                    else
                                      return ''
                                    endif

FUNCTION  <SNR>142_DirUrlPrefix()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:588
Called 9 times
Total time:   0.000362000
 Self time:   0.000042000

count     total (s)      self (s)
    9   0.000361000   0.000041000     return 'fugitive://' . s:PathUrlEncode(s:GitDir(a:dir)) . '//'

FUNCTION  <SNR>93_check_defined_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:48
Called 72 times
Total time:   0.000743000
 Self time:   0.000743000

count     total (s)      self (s)
   72                 0.000309000   if !exists('w:airline_section_{a:name}')
   72                 0.000301000     let w:airline_section_{a:name} = g:airline_section_{a:name}
   72                 0.000042000   endif

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:249
Called 257 times
Total time:   0.299064000
 Self time:   0.010780000

count     total (s)      self (s)
  257                 0.000935000   if !exists('b:buffer_vcs_config')
    6   0.000160000   0.000028000     call s:init_buffer()
  257                 0.000161000   endif
                                  
  257   0.217293000   0.001451000   call s:update_branch()
  257   0.071889000   0.001519000   call s:update_untracked()
                                  
  257                 0.001259000   if exists('b:airline_head') && !empty(b:airline_head)
  227                 0.000369000     return b:airline_head
   30                 0.000008000   endif
                                  
   30                 0.000106000   let b:airline_head = ''
   30                 0.000104000   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                                  
   30                 0.000032000   let heads = []
   90                 0.000098000   for vcs in vcs_priority
   60                 0.000258000     if !empty(b:buffer_vcs_config[vcs].branch)
   27                 0.000068000       let heads += [vcs]
   60                 0.000030000     endif
   90                 0.000053000   endfor
                                  
   57                 0.000058000   for vcs in heads
   27                 0.000043000     if !empty(b:airline_head)
                                        let b:airline_head .= ' | '
   27                 0.000009000     endif
   27                 0.000048000     if len(heads) > 1
                                        let b:airline_head .= s:vcs_config[vcs].exe .':'
   27                 0.000010000     endif
   27   0.002183000   0.000285000     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
   27                 0.000057000     let additional = b:buffer_vcs_config[vcs].untracked
   27                 0.000115000     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
   22                 0.000095000       let additional = g:airline_symbols['dirty']
   27                 0.000010000     endif
   27                 0.000048000     let b:airline_head .= additional
   57                 0.000044000   endfor
                                  
   30                 0.000039000   if empty(heads)
    3   0.000115000   0.000086000     if airline#util#has_vcscommand()
                                        noa call VCSCommandEnableBufferSetup()
                                        if exists('b:VCSCommandBufferInfo')
                                          let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                        endif
    3                 0.000002000     endif
   30                 0.000015000   endif
                                  
   30                 0.000038000   if empty(heads)
    3   0.000030000   0.000017000     if airline#util#has_custom_scm()
                                        try
                                          let Fn = function(g:airline#extensions#branch#custom_head)
                                          let b:airline_head = Fn()
                                        endtry
    3                 0.000002000     endif
   30                 0.000010000   endif
                                  
   30                 0.000089000   if exists("g:airline#extensions#branch#displayed_head_limit")
                                      let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                      if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                        let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '…' : '.')
                                      endif
   30                 0.000012000   endif
                                  
   30                 0.000039000   return b:airline_head

FUNCTION  <SNR>192_merge_opts()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:143
Called 2 times
Total time:   0.000112000
 Self time:   0.000019000

count     total (s)      self (s)
    2   0.000111000   0.000018000   return s:extend_opts(a:dict, a:eopts, 0)

FUNCTION  <SNR>41_CloseIfOnlyNerdTreeLeft()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:337
Called 22 times
Total time:   0.001189000
 Self time:   0.001189000

count     total (s)      self (s)
   22                 0.001103000   if exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1 && winnr("$") == 1
                                      q
   22                 0.000016000   endif

FUNCTION  <SNR>51_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:329
Called 90 times
Total time:   0.011130000
 Self time:   0.011130000

count     total (s)      self (s)
   90                 0.008016000   let p = resolve(expand('#'.a:bufnr.':p'))
                                  
                                    " Remove extra parts from fugitive's filepaths
   90                 0.002445000   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                                  
   90                 0.000433000   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  airline#extensions#load_theme()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:132
Called 2 times
Total time:   0.004736000
 Self time:   0.000026000

count     total (s)      self (s)
    2   0.004735000   0.000025000   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  airline#extensions#tabline#buflist#clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:10
Called 13 times
Total time:   0.000200000
 Self time:   0.000139000

count     total (s)      self (s)
   13                 0.000025000   if !exists('#airline')
                                      " airline disabled
                                      return
   13                 0.000004000   endif
   13   0.000059000   0.000033000   call airline#extensions#tabline#buflist#invalidate()
   13   0.000086000   0.000051000   call airline#extensions#tabline#buffers#invalidate()

FUNCTION  <SNR>56_set()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim:15
Called 621 times
Total time:   0.004495000
 Self time:   0.004495000

count     total (s)      self (s)
  621                 0.000971000   let bufnr = bufnr('%')
  621                 0.000981000   if !has_key(s:options, bufnr)
   10                 0.000057000     let s:options[bufnr] = {}
  621                 0.000268000   endif
  621                 0.001404000   let s:options[bufnr][a:name] = a:value

FUNCTION  <SNR>117_get_transitioned_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 633 times
Total time:   0.436120000
 Self time:   0.019013000

count     total (s)      self (s)
  633                 0.000741000   let line = ''
  633                 0.002813000   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                      call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                      let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                      let line .=  a:self._context.right_sep.'%#'.a:group.'#'
  633                 0.000370000   else
  633   0.420071000   0.002964000     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  633                 0.002444000     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  633                 0.002092000     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  633                 0.001504000     let line .= '%#'.a:group.'#'
  633                 0.000416000   endif
  633                 0.000626000   return line

FUNCTION  nerdtree#osDefaultCaseSensitiveFS()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:217
Called 1415 times
Total time:   0.003098000
 Self time:   0.003098000

count     total (s)      self (s)
 1415                 0.002588000     return s:osDefaultCaseSensitiveFS

FUNCTION  220()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:106
Called 7 times
Total time:   0.000091000
 Self time:   0.000091000

count     total (s)      self (s)
    7                 0.000027000     if !exists('t:NERDTreeBufName')
    6                 0.000004000         return
    1                 0.000001000     end
                                  
                                      "check b:NERDTree is still there and hasn't been e.g. :bdeleted
    1                 0.000049000     return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  224()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 46 times
Total time:   0.002143000
 Self time:   0.002143000

count     total (s)      self (s)
   46                 0.000189000     if exists('t:NERDTreeBufName')
   46                 0.001895000         return bufwinnr(t:NERDTreeBufName)
                                      endif
                                  
                                      " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                      for w in range(1,winnr('$'))
                                          if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . 'win_\d\+$'
                                              return w
                                          endif
                                      endfor
                                  
                                      return -1

FUNCTION  225()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 26 times
Total time:   0.001565000
 Self time:   0.000223000

count     total (s)      self (s)
   26   0.001546000   0.000204000     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  228()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:171
Called 12 times
Total time:   0.000713000
 Self time:   0.000106000

count     total (s)      self (s)
   12   0.000659000   0.000052000     if !s:NERDTree.IsOpen()
                                          throw 'NERDTree.TreeNotOpen'
   12                 0.000012000     endif

FUNCTION  46()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:848
Called 719 times
Total time:   0.006519000
 Self time:   0.002870000

count     total (s)      self (s)
  719   0.005274000   0.001625000     if !nerdtree#runningWindows()
  719                 0.000864000         return a:pathstr
                                      endif
                                  
                                      let toReturn = a:pathstr
                                  
                                      "remove the x:\ of the front
                                      let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', '')
                                  
                                      "remove the \\ network share from the front
                                      let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', '')
                                  
                                      "convert all \ chars to /
                                      let toReturn = substitute(toReturn, '\', '/', 'g')
                                  
                                      return toReturn

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:204
Called 299 times
Total time:   0.010665000
 Self time:   0.002526000

count     total (s)      self (s)
  299   0.010304000   0.002165000   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 195 times
Total time:   0.009918000
 Self time:   0.002930000

count     total (s)      self (s)
  195   0.002126000   0.000934000   let part = airline#parts#get('mode')
  195                 0.000541000   let minwidth = get(part, 'minwidth', 79)
  195   0.006962000   0.001166000   return airline#util#shorten(get(w:, 'airline_current_mode', ''), minwidth, 1)

FUNCTION  <SNR>62_exit_handler()
    Defined: ~/.fzf/plugin/fzf.vim:660
Called 2 times
Total time:   0.000010000
 Self time:   0.000010000

count     total (s)      self (s)
    2                 0.000003000   if a:code == 130
    2                 0.000002000     return 0
                                    elseif has('nvim') && a:code == 129
                                      " When deleting the terminal buffer while fzf is still running,
                                      " Nvim sends SIGHUP.
                                      return 0
                                    elseif a:code > 1
                                      call s:error('Error running ' . a:command)
                                      if !empty(a:000)
                                        sleep
                                      endif
                                      return 0
                                    endif
                                    return 1

FUNCTION  <SNR>172_process_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:306
Called 11 times
Total time:   0.000106000
 Self time:   0.000106000

count     total (s)      self (s)
   11                 0.000013000   let offset = 0
   22                 0.000014000   while offset < a:to_count
   11                 0.000010000     let line_number = a:to_line + offset
   11                 0.000017000     call add(a:modifications, [line_number, 'modified'])
   11                 0.000006000     let offset += 1
   22                 0.000012000   endwhile

FUNCTION  go#config#BinPath()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:386
Called 17 times
Total time:   0.000119000
 Self time:   0.000119000

count     total (s)      self (s)
   17                 0.000099000   return get(g:, "go_bin_path", "")

FUNCTION  <SNR>114_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:60
Called 10439 times
Total time:   0.049071000
 Self time:   0.049071000

count     total (s)      self (s)
10439                 0.046068000     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  <SNR>103_airline_ale_count()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:11
Called 110 times
Total time:   0.000216000
 Self time:   0.000216000

count     total (s)      self (s)
  110                 0.000173000   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  airline#extensions#tabline#buflist#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:6
Called 55 times
Total time:   0.000222000
 Self time:   0.000222000

count     total (s)      self (s)
   55                 0.000174000   unlet! s:current_buffer_list

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 72 times
Total time:   0.000733000
 Self time:   0.000733000

count     total (s)      self (s)
   72                 0.000196000   if &buftype == 'quickfix'
                                      let w:airline_section_a = airline#extensions#quickfix#get_type()
                                      let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                      let w:airline_section_c = ''
                                      let w:airline_section_x = ''
   72                 0.000042000   endif

FUNCTION  <SNR>192_blue()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:312
Called 2 times
Total time:   0.000555000
 Self time:   0.000042000

count     total (s)      self (s)
    2   0.000552000   0.000039000    return s:ansi(a:str, get(a:, 1, ''), 'blue')

FUNCTION  <SNR>192_conf()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:31
Called 2 times
Total time:   0.000033000
 Self time:   0.000033000

count     total (s)      self (s)
    2                 0.000013000   let conf = get(g:, 'fzf_vim', {})
    2                 0.000015000   return get(conf, a:name, get(g:, 'fzf_' . a:name, a:default))

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:40
Called 44 times
Total time:   0.000991000
 Self time:   0.000266000

count     total (s)      self (s)
   44   0.000510000   0.000111000   let summary = gitgutter#hunk#summary(a:bufnr)
   44                 0.000052000   let summary[2] += a:count
   44   0.000423000   0.000097000   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>139_hi()
    Defined: ~/.vim/plugged/vim-go/syntax/go.vim:465
Called 1 time
Total time:   0.000091000
 Self time:   0.000088000

count     total (s)      self (s)
    1                 0.000007000   hi def link goSameId Search
    1                 0.000006000   hi def link goDiagnosticError SpellBad
    1                 0.000006000   hi def link goDiagnosticWarning SpellRare
                                  
                                    " TODO(bc): is it appropriate to define text properties in a syntax file?
                                    " The highlight groups need to be defined before the text properties types
                                    " are added, and when users have syntax enabled in their vimrc after
                                    " filetype plugin on, the highlight groups won't be defined when
                                    " ftplugin/go.vim is executed when the first go file is opened.
                                    " See https://github.com/fatih/vim-go/issues/2658.
    1                 0.000003000   if has('textprop')
    1                 0.000004000     if empty(prop_type_get('goSameId'))
                                        call prop_type_add('goSameId', {'highlight': 'goSameId'})
    1                 0.000000000     endif
    1                 0.000003000     if empty(prop_type_get('goDiagnosticError'))
                                        call prop_type_add('goDiagnosticError', {'highlight': 'goDiagnosticError'})
    1                 0.000001000     endif
    1                 0.000002000     if empty(prop_type_get('goDiagnosticWarning'))
                                        call prop_type_add('goDiagnosticWarning', {'highlight': 'goDiagnosticWarning'})
    1                 0.000001000     endif
    1                 0.000000000   endif
                                  
    1                 0.000006000   hi def link goDeclsFzfKeyword        Keyword
    1                 0.000006000   hi def link goDeclsFzfFunction       Function
    1                 0.000007000   hi def link goDeclsFzfSpecialComment SpecialComment
    1                 0.000007000   hi def link goDeclsFzfComment        Comment
                                  
                                    " :GoCoverage commands
    1                 0.000003000   hi def      goCoverageCovered    ctermfg=green guifg=#A6E22E
    1                 0.000002000   hi def      goCoverageUncover    ctermfg=red guifg=#F92672
                                  
                                    " :GoDebug commands
    1   0.000005000   0.000002000   if go#config#HighlightDebug()
    1                 0.000003000     hi def GoDebugBreakpoint term=standout ctermbg=117 ctermfg=0 guibg=#BAD4F5  guifg=Black
    1                 0.000003000     hi def GoDebugCurrent term=reverse  ctermbg=12  ctermfg=7 guibg=DarkBlue guifg=White
    1                 0.000000000   endif

FUNCTION  fugitive#Find()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1806
Called 9 times
Total time:   0.003411000
 Self time:   0.001454000

count     total (s)      self (s)
    9                 0.000019000   if type(a:object) == type(0)
                                      let name = bufname(a:object)
                                      return s:VimSlash(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
    9                 0.000022000   elseif a:object =~# '^[~$]'
                                      let prefix = matchstr(a:object, '^[~$]\i*')
                                      let owner = expand(prefix)
                                      return s:VimSlash(FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix))))
    9                 0.000000000   endif
    9   0.000054000   0.000045000   let rev = s:Slash(a:object)
    9                 0.000026000   if rev =~# '^\a\+://' && rev !~# '^fugitive:'
                                      return rev
    9                 0.000063000   elseif rev =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                      return s:VimSlash(a:object)
    9                 0.000034000   elseif rev =~# '^\.\.\=\%(/\|$\)'
                                      return s:VimSlash(simplify(getcwd() . '/' . a:object))
    9                 0.000002000   endif
    9   0.000436000   0.000043000   let dir = call('s:GitDir', a:000)
    9                 0.000009000   if empty(dir)
                                      let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs\%(\.\.\=$\|\.\.\=/.*\|/.*\|\w:/.*\)')
                                      let dir = FugitiveExtractGitDir(file)
                                      if empty(dir)
                                        return ''
                                      endif
    9                 0.000006000   endif
    9   0.000442000   0.000023000   let tree = s:Tree(dir)
    9   0.000390000   0.000028000   let urlprefix = s:DirUrlPrefix(dir)
    9                 0.000015000   let base = len(tree) ? tree : urlprefix . '0'
    9                 0.000007000   if rev ==# '.git'
                                      let f = len(tree) && len(getftype(tree . '/.git')) ? tree . '/.git' : dir
    9                 0.000014000   elseif rev =~# '^\.git/'
    9                 0.000017000     let f = strpart(rev, 5)
    9   0.000400000   0.000048000     let fdir = simplify(FugitiveActualDir(dir) . '/')
    9   0.000448000   0.000034000     let cdir = simplify(FugitiveCommonDir(dir) . '/')
    9                 0.000017000     if f =~# '^\.\./\.\.\%(/\|$\)'
                                        let f = simplify(len(tree) ? tree . f[2:-1] : fdir . f)
    9                 0.000016000     elseif f =~# '^\.\.\%(/\|$\)'
                                        let f = s:PathJoin(base, f[2:-1])
    9                 0.000031000     elseif cdir !=# fdir && ( f =~# '^\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(fdir . f) < 0 && getftime(cdir . f) >= 0)
                                        let f = simplify(cdir . f)
    9                 0.000004000     else
    9                 0.000019000       let f = simplify(fdir . f)
    9                 0.000002000     endif
                                    elseif rev ==# ':/'
                                      let f = tree
                                    elseif rev =~# '^\.\%(/\|$\)'
                                      let f = s:PathJoin(base, rev[1:-1])
                                    elseif rev =~# '^::\%(/\|\a\+\:\)'
                                      let f = rev[2:-1]
                                    elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                      let f = simplify(getcwd() . '/' . rev[2:-1])
                                    elseif rev =~# '^::'
                                      let f = s:PathJoin(base, '/' . rev[2:-1])
                                    elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                      let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                      if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                        let f = s:PathJoin(urlprefix, +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1))
                                      else
                                        let altdir = FugitiveExtractGitDir(f)
                                        if len(altdir) && !s:cpath(dir, altdir)
                                          return fugitive#Find(a:object, altdir)
                                        endif
                                      endif
                                    elseif rev =~# '^:[0-3]:'
                                      let f = s:PathJoin(urlprefix, rev[1] . '/' . rev[3:-1])
                                    elseif rev ==# ':'
                                      let f = urlprefix
                                    elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                      let f = matchstr(rev, ')\zs.*')
                                      if f=~# '^\.\.\=\%(/\|$\)'
                                        let f = simplify(getcwd() . '/' . f)
                                      elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                        let f = s:PathJoin(base, '/' . f)
                                      endif
                                    elseif rev =~# '^:/\@!'
                                      let f = s:PathJoin(urlprefix, '0/' . rev[1:-1])
                                    else
                                      if !exists('f')
                                        let commit = matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*')
                                        let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                        if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                          let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                          if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                            let file = '/' . strpart(file, len(base) + 1)
                                          else
                                            let altdir = FugitiveExtractGitDir(file)
                                            if len(altdir) && !s:cpath(dir, altdir)
                                              return fugitive#Find(a:object, altdir)
                                            endif
                                            return file
                                          endif
                                        endif
                                        let commits = split(commit, '\.\.\.-\@!', 1)
                                        if len(commits) == 2
                                          call map(commits, 'empty(v:val) ? "@" : v:val')
                                          let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                        endif
                                        if commit !~# '^[0-9a-f]\{40,\}$\|^$'
                                          let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                          if empty(commit) && len(file)
                                            let commit = repeat('0', 40)
                                          endif
                                        endif
                                        if len(commit)
                                          let f = s:PathJoin(urlprefix, commit . file)
                                        else
                                          let f = s:PathJoin(base, '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', ''))
                                        endif
                                      endif
    9                 0.000004000   endif
    9   0.000030000   0.000022000   return s:VimSlash(f)

FUNCTION  airline#util#strchars()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:121
Called 181 times
Total time:   0.000654000
 Self time:   0.000654000

count     total (s)      self (s)
  181                 0.000213000   if s:has_strchars
  181                 0.000349000     return strchars(a:str)
                                    else
                                      return strlen(substitute(a:str, '.', 'a', 'g'))
                                    endif

FUNCTION  <SNR>118_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 209 times
Total time:   0.065376000
 Self time:   0.009395000

count     total (s)      self (s)
 1028                 0.001154000   for key in a:keys
  819                 0.002084000     if (key == 'warning' || key == 'error') && !a:context.active
   74                 0.000056000       continue
  745                 0.000369000     endif
  745   0.058974000   0.002993000     call s:add_section(a:builder, a:context, key)
  954                 0.000616000   endfor

FUNCTION  230()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:187
Called 2520 times
Total time:   0.011651000
 Self time:   0.011651000

count     total (s)      self (s)
 2520                 0.005253000     if !exists('s:NERDTree._PathFilters')
                                          let s:NERDTree._PathFilters = []
 2520                 0.000999000     endif
 2520                 0.002358000     return s:NERDTree._PathFilters

FUNCTION  233()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:205
Called 35 times
Total time:   0.739395000
 Self time:   0.000198000

count     total (s)      self (s)
   35   0.739370000   0.000173000     call self.ui.render()

FUNCTION  234()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:12
Called 6 times
Total time:   0.000346000
 Self time:   0.000121000

count     total (s)      self (s)
    6                 0.000012000     if g:NERDTreeAutoCenter
    6                 0.000024000         let current_line = winline()
    6                 0.000010000         let lines_to_top = current_line
    6   0.000264000   0.000039000         let lines_to_bottom = winheight(g:NERDTree.GetWinNum()) - current_line
    6                 0.000018000         if lines_to_top < g:NERDTreeAutoCenterThreshold || lines_to_bottom < g:NERDTreeAutoCenterThreshold
                                              normal! zz
    6                 0.000004000         endif
    6                 0.000004000     endif

FUNCTION  235()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:25
Called 41 times
Total time:   0.007557000
 Self time:   0.007368000

count     total (s)      self (s)
   41   0.000311000   0.000208000     if self.getShowHelp()
                                          let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                          let help .= "\" ============================\n"
                                          let help .= "\" File node mappings~\n"
                                          let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                          if self.nerdtree.isTabTree()
                                              let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                          else
                                              let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                          endif
                                          if self.nerdtree.isTabTree()
                                              let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                          endif
                                          let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                          let help .= "\" middle-click,\n"
                                          let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                          let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                          let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                          let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                          let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Directory node mappings~\n"
                                          let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                          let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                          let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                          let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                          let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                          let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                          let help .= "\"    current node recursively\n"
                                          let help .= "\" middle-click,\n"
                                          let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Bookmark table mappings~\n"
                                          let help .= "\" double-click,\n"
                                          let help .= '" '. g:NERDTreeMapJumpBookmarks .": jump to bookmark table\n"
                                          let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                          let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                          let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                          let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                          let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                          let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                          let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                          let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                          let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                          let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Tree navigation mappings~\n"
                                          let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                          let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                          let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                          let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                          let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                          let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Filesystem mappings~\n"
                                          let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                          let help .= "\"    selected dir\n"
                                          let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                          let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                          let help .= "\"    but leave old root open\n"
                                          let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                          let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                          let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                          let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                          let help .= "\"    selected dir\n"
                                          let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Tree filtering mappings~\n"
                                          let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                          let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                          let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                          let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                                          let help .= '" '. g:NERDTreeMapToggleFileLines .': files lines (' . (self.getShowFileLines() ? 'on' : 'off') . ")\n"
                                  
                                          " add quickhelp entries for each custom key map
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Custom mappings~\n"
                                          for i in g:NERDTreeKeyMap.All()
                                              if !empty(i.quickhelpText)
                                                  let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                              endif
                                          endfor
                                  
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Other mappings~\n"
                                          let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                          let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                          let help .= "\"    the NERDTree window\n"
                                          let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                          let help .= "\"\n\" ----------------------------\n"
                                          let help .= "\" Bookmark commands~\n"
                                          let help .= "\" :Bookmark [<name>]\n"
                                          let help .= "\" :BookmarkToRoot <name>\n"
                                          let help .= "\" :RevealBookmark <name>\n"
                                          let help .= "\" :OpenBookmark <name>\n"
                                          let help .= "\" :ClearBookmarks [<names>]\n"
                                          let help .= "\" :ClearAllBookmarks\n"
                                          let help .= "\" :ReadBookmarks\n"
                                          let help .= "\" :WriteBookmarks\n"
                                          let help .= "\" :EditBookmarks\n"
                                          silent! put =help
   41   0.000246000   0.000160000     elseif !self.isMinimal()
   41                 0.000168000         let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
   41                 0.000433000         silent! put =help
   41                 0.000028000     endif

FUNCTION  236()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:144
Called 2 times
Total time:   0.000036000
 Self time:   0.000036000

count     total (s)      self (s)
    2                 0.000019000     let newObj = copy(self)
    2                 0.000002000     let newObj.nerdtree = a:nerdtree
    2                 0.000001000     let newObj._showHelp = 0
    2                 0.000002000     let newObj._ignoreEnabled = 1
    2                 0.000003000     let newObj._showFiles = g:NERDTreeShowFiles
    2                 0.000002000     let newObj._showHidden = g:NERDTreeShowHidden
    2                 0.000002000     let newObj._showBookmarks = g:NERDTreeShowBookmarks
    2                 0.000002000     let newObj._showFileLines = g:NERDTreeFileLines
                                  
    2                 0.000002000     return newObj

FUNCTION  237()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:162
Called 45 times
Total time:   0.057171000
 Self time:   0.018649000

count     total (s)      self (s)
   45                 0.000433000     let line = getline(a:ln)
                                  
   45   0.004906000   0.000341000     let rootLine = self.getRootLineNum()
                                  
   45                 0.000090000     if a:ln ==# rootLine
   24                 0.000112000         return self.nerdtree.root.path
   21                 0.000017000     endif
                                  
   21   0.000233000   0.000174000     if line ==# s:UI.UpDirLine()
                                          return self.nerdtree.root.path.getParent()
   21                 0.000018000     endif
                                  
   21                 0.000033000     if a:ln < rootLine
                                          return {}
   21                 0.000013000     endif
                                  
   21   0.001347000   0.000148000     let indent = self._indentLevelFor(line)
                                  
                                      " remove the tree parts and the leading space
   21   0.000612000   0.000137000     let curFile = self._stripMarkup(line)
                                  
   21                 0.000032000     let dir = ''
   21                 0.000038000     let lnum = a:ln
  468                 0.000603000     while lnum > 0
  468                 0.000744000         let lnum = lnum - 1
  468                 0.001085000         let curLine = getline(lnum)
  468   0.008295000   0.001881000         let curLineStripped = self._stripMarkup(curLine)
                                  
                                          " have we reached the top of the tree?
  468                 0.000701000         if lnum ==# rootLine
   21   0.002522000   0.000319000             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
   21                 0.000021000             break
  447                 0.000309000         endif
  447                 0.001638000         if curLineStripped =~# '/$'
  427   0.012952000   0.001782000             let lpindent = self._indentLevelFor(curLine)
  427                 0.000661000             if lpindent < indent
   15                 0.000025000                 let indent = indent - 1
                                  
   15                 0.000111000                 let dir = substitute (curLineStripped,'^\\', '', '') . dir
   15                 0.000023000                 continue
  412                 0.000301000             endif
  432                 0.000276000         endif
  453                 0.000361000     endwhile
   21                 0.000107000     let curFile = self.nerdtree.root.path.drive . dir . curFile
   21   0.012647000   0.000210000     let toReturn = g:NERDTreePath.New(curFile)
   21                 0.000028000     return toReturn

FUNCTION  238()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:214
Called 21 times
Total time:   0.021162000
 Self time:   0.009600000

count     total (s)      self (s)
                                  
   21   0.002522000   0.000043000     if a:node.isRoot()
    5   0.000296000   0.000012000         return self.getRootLineNum()
   16                 0.000006000     endif
                                  
   16   0.000752000   0.000155000     let l:pathComponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/\s*$', '', '')]
   16                 0.000022000     let l:currentPathComponent = 1
                                  
   16   0.000636000   0.000056000     let l:fullPath = a:node.path.str({'format': 'UI'})
                                  
  447   0.000836000   0.000338000     for l:lineNumber in range(self.getRootLineNum() + 1, line('$'))
  447                 0.000598000         let l:currentLine = getline(l:lineNumber)
  447   0.005568000   0.000798000         let l:indentLevel = self._indentLevelFor(l:currentLine)
                                  
  447                 0.000431000         if l:indentLevel !=# l:currentPathComponent
                                              continue
  447                 0.000128000         endif
                                  
  447   0.003137000   0.000783000         let l:currentLine = self._stripMarkup(l:currentLine)
  447                 0.000873000         let l:currentPath =  join(l:pathComponents, '/') . '/' . l:currentLine
                                  
                                          " Directories: If the current path 'starts with' the full path, then
                                          " either the paths are equal or the line is a cascade containing the
                                          " full path.
  447                 0.000890000         if l:fullPath[-1:] ==# '/' && stridx(l:currentPath, l:fullPath) ==# 0
   12                 0.000006000             return l:lineNumber
  435                 0.000130000         endif
                                  
                                          " Files: The paths must exactly match.
  435                 0.000366000         if l:fullPath ==# l:currentPath
    4                 0.000003000             return l:lineNumber
  431                 0.000122000         endif
                                  
                                          " Otherwise: If the full path starts with the current path and the
                                          " current path is a directory, we add a new path component.
  431                 0.000706000         if stridx(l:fullPath, l:currentPath) ==# 0 && l:currentPath[-1:] ==# '/'
   13                 0.000048000             let l:currentLine = substitute(l:currentLine, '/\s*$', '', '')
   13                 0.000021000             call add(l:pathComponents, l:currentLine)
   13                 0.000013000             let l:currentPathComponent += 1
  431                 0.000120000         endif
  431                 0.000135000     endfor
                                  
                                      return -1

FUNCTION  239()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:262
Called 66 times
Total time:   0.005347000
 Self time:   0.005347000

count     total (s)      self (s)
   66                 0.000157000     let rootLine = 1
  396                 0.003610000     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
  330                 0.000701000         let rootLine = rootLine + 1
  396                 0.000434000     endwhile
   66                 0.000088000     return rootLine

FUNCTION  <SNR>125_ExcludeOther()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:32
Called 78 times
Total time:   0.000794000
 Self time:   0.000794000

count     total (s)      self (s)
   78                 0.000620000   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
   78                 0.000117000     return 1 | endif

FUNCTION  <SNR>142_PathUrlEncode()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:91
Called 9 times
Total time:   0.000055000
 Self time:   0.000055000

count     total (s)      self (s)
    9                 0.000047000   return substitute(a:str, '[%#?[:cntrl:]]', '\=printf("%%%02X", char2nr(submatch(0)))', 'g')

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 13 times
Total time:   0.043920000
 Self time:   0.041284000

count     total (s)      self (s)
   13   0.000803000   0.000155000   call gitgutter#debug#log('[async] '.a:cmd)
                                  
   13                 0.000088000   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
   13   0.000202000   0.000098000   let command = s:build_command(a:cmd)
                                  
   13                 0.000048000   if has('nvim')
                                      call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
   13                 0.000010000   else
   13                 0.039434000     let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
   13   0.002866000   0.000982000     let s:jobs[s:job_id(job)] = 1
   13                 0.000049000   endif

FUNCTION  nerdtree#exec()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:157
Called 29 times
Total time:   0.024525000
 Self time:   0.001715000

count     total (s)      self (s)
   29                 0.000110000     let old_ei = &eventignore
   29                 0.000049000     if a:ignoreAll
   27                 0.000197000         set eventignore=all
   29                 0.000027000     endif
   29                 0.000025000     try
   29                 0.000463000         exec a:cmd
   29                 0.000051000     finally
   29   0.000157000   0.000134000         let &eventignore = old_ei
   29                 0.000039000     endtry

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:169
Called 11 times
Total time:   0.010877000
 Self time:   0.000583000

count     total (s)      self (s)
   11   0.000367000   0.000066000   call gitgutter#debug#log(a:diff)
                                  
   11                 0.000022000   if !bufexists(a:bufnr)
                                      return
   11                 0.000003000   endif
                                  
   11   0.002699000   0.000111000   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
   11   0.007354000   0.000070000   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                                  
   11                 0.000015000   let signs_count = len(modified_lines)
   11                 0.000020000   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                      call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                      call gitgutter#sign#clear_signs(a:bufnr)
                                  
   11                 0.000004000   else
   11                 0.000021000     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
                                        call gitgutter#sign#update_signs(a:bufnr, modified_lines)
   11                 0.000005000     endif
   11                 0.000002000   endif
                                  
   11   0.000160000   0.000039000   call s:save_last_seen_change(a:bufnr)
   11                 0.000053000   if exists('#User#GitGutter')
                                      let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                      execute 'doautocmd' s:nomodeline 'User GitGutter'
                                      unlet g:gitgutter_hook_context
   11                 0.000005000   endif

FUNCTION  <SNR>62_fzf_tempname()
    Defined: ~/.fzf/plugin/fzf.vim:126
Called 3 times
Total time:   0.000057000
 Self time:   0.000018000

count     total (s)      self (s)
    3   0.000054000   0.000015000   return s:fzf_call('tempname')

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:98
Called 72 times
Total time:   0.003138000
 Self time:   0.003138000

count     total (s)      self (s)
   72                 0.000561000   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes', ['asciidoc', 'help', 'mail', 'markdown', 'rmd', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                                    " export current filetypes settings to global namespace
   72                 0.000316000   let g:airline#extensions#wordcount#filetypes = filetypes
                                  
                                    " Check if filetype needs testing
   72                 0.000132000   if did_filetype()
                                      " correctly test for compound filetypes (e.g. markdown.pandoc)
   25                 0.000065000     let ft = substitute(&filetype, '\.', '\\|', 'g')
                                  
                                      " Select test based on type of "filetypes": new=list, old=string
   25                 0.000238000     if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                        let b:airline_changedtick = -1
                                        call s:update_wordcount(1) " force update: ensures initial worcount exists
   25                 0.000042000     elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                        unlet b:airline_wordcount
   25                 0.000009000     endif
   72                 0.000036000   endif
                                  
   72                 0.000174000   if exists('b:airline_wordcount')
                                      call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
   72                 0.000046000   endif

FUNCTION  <SNR>151_encode()
    Defined: ~/.vim/plugged/vim-go/autoload/go/uri.vim:17
Called 9 times
Total time:   0.000095000
 Self time:   0.000095000

count     total (s)      self (s)
    9                 0.000090000     return substitute(   a:value,   a:unreserved,   '\=s:encodechar(submatch(0))',   'g')

FUNCTION  go#fmt#CleanErrors()
    Defined: ~/.vim/plugged/vim-go/autoload/go/fmt.vim:187
Called 8 times
Total time:   0.000450000
 Self time:   0.000167000

count     total (s)      self (s)
    8   0.000328000   0.000045000   let l:listtype = go#list#Type("GoFmt")
                                  
                                    " clean up previous list
    8                 0.000009000   if l:listtype == "quickfix"
    8                 0.000031000     let l:list_title = getqflist({'title': 1})
                                    else
                                      let l:list_title = getloclist(0, {'title': 1})
    8                 0.000004000   endif
                                  
    8                 0.000030000   if has_key(l:list_title, 'title') && (l:list_title['title'] == 'Format' || l:list_title['title'] == 'GoMetaLinterAutoSave')
                                      call go#list#Clean(l:listtype)
    8                 0.000001000   endif

FUNCTION  <SNR>148_debugasync()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:1325
Called 13 times
Total time:   0.000501000
 Self time:   0.000329000

count     total (s)      self (s)
   13                 0.000133000   let s:logtimer = 0
                                  
   13   0.000247000   0.000075000   if !go#util#HasDebug('lsp')
   13                 0.000069000     let s:log = []
   13                 0.000009000     return
                                    endif
                                  
                                    " set the timer to try again if Vim is in a state where we don't want to
                                    " change the window.
                                    if exists('*state')
                                      let l:state = state('a')
                                    else
                                      let l:state = mode(1)
                                      if !(l:state == 'ic' || l:state == 'Rc' || l:state == 'Rvc')
                                        let l:state = ''
                                      endif
                                    endif
                                    let l:mode = mode(1)
                                    if len(l:state) > 0 || l:mode[0] == 'v' || l:mode[0] == 'V' || l:mode[0] == 's' || l:mode =~ 'CTRL-V'
                                      let s:logtimer = timer_start(go#config#DebugLogDelay(), function('s:debugasync', []))
                                      return
                                    endif
                                  
                                    try
                                      let l:winid = win_getid()
                                  
                                      let l:name = '__GOLSP_LOG__'
                                      let l:log_winid = bufwinid(l:name)
                                      if l:log_winid == -1
                                        silent keepalt botright 10new
                                        silent file `='__GOLSP_LOG__'`
                                        setlocal buftype=nofile bufhidden=wipe nomodified nobuflisted noswapfile nowrap nonumber nocursorline
                                        setlocal filetype=golsplog
                                        setlocal fileencoding=utf-8
                                        call win_gotoid(l:winid)
                                      endif
                                  
                                      let l:logwinid = bufwinid(l:name)
                                  
                                      try
                                        call setbufvar(l:name, '&modifiable', 1)
                                        for [l:event, l:data] in s:log
                                          call remove(s:log, 0)
                                          if getbufline(l:name, 1)[0] == ''
                                            call setbufline(l:name, '$', printf('===== %s =====', l:event))
                                          else
                                            call appendbufline(l:name, '$', printf('===== %s =====', l:event))
                                          endif
                                          call appendbufline(l:name, '$', split(l:data, "\r\n"))
                                        endfor
                                  
                                        " Move the window's cursor position without switching to the window
                                        call win_execute(l:logwinid, 'normal! G')
                                        call setbufvar(l:name, '&modifiable', 0)
                                      finally
                                      endtry
                                    catch
                                      call go#util#EchoError(printf('at %s: %s', v:throwpoint, v:exception))
                                    finally
                                      " retry when there's an exception. This can happen when trying to do
                                      " completion, because the window can not be changed while completion is in
                                      " progress.
                                      if len(s:log) != 0
                                        let s:logtimer = timer_start(go#config#DebugLogDelay(), function('s:debugasync', []))
                                      endif
                                    endtry

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:130
Called 24 times
Total time:   0.004553000
 Self time:   0.003994000

count     total (s)      self (s)
   24                 0.000050000   if !g:gitgutter_map_keys
                                      return
   24                 0.000015000   endif
                                  
                                    " Note hasmapto() and maparg() operate on the current buffer.
                                  
   24                 0.000061000   let bufnr = bufnr('')
                                  
   24   0.000511000   0.000136000   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
   14                 0.000010000     return
   10                 0.000003000   endif
                                  
   10                 0.000624000   if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
   10                 0.000090000     nmap <buffer> [c <Plug>(GitGutterPrevHunk)
   10                 0.000006000   endif
   10                 0.000215000   if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
   10                 0.000059000     nmap <buffer> ]c <Plug>(GitGutterNextHunk)
   10                 0.000002000   endif
                                  
   10                 0.000186000   if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
   10                 0.000076000     xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
   10                 0.000032000   endif
   10                 0.000222000   if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
   10                 0.000085000     nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
   10                 0.000007000   endif
   10                 0.000210000   if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
   10                 0.000083000     nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
   10                 0.000008000   endif
   10                 0.000207000   if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
   10                 0.000072000     nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
   10                 0.000005000   endif
                                  
   10                 0.000234000   if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
   10                 0.000085000     omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
   10                 0.000006000   endif
   10                 0.000224000   if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
   10                 0.000073000     omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
   10                 0.000006000   endif
   10                 0.000219000   if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
   10                 0.000072000     xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
   10                 0.000008000   endif
   10                 0.000272000   if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
   10                 0.000075000     xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
   10                 0.000004000   endif
                                  
   10   0.000251000   0.000067000   call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  <SNR>93_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:112
Called 150 times
Total time:   0.009104000
 Self time:   0.009104000

count     total (s)      self (s)
  150                 0.000492000   for matchft in g:airline_exclude_filetypes
                                      if matchft ==# &ft
                                        return 1
                                      endif
  150                 0.000132000   endfor
                                  
  600                 0.000814000   for matchw in g:airline_exclude_filenames
  450                 0.003380000     if matchstr(expand('%'), matchw) ==# matchw
                                        return 1
  450                 0.000249000     endif
  600                 0.000376000   endfor
                                  
  150                 0.000257000   if g:airline_exclude_preview && &previewwindow
                                      return 1
  150                 0.000084000   endif
                                  
  150                 0.000124000   return 0

FUNCTION  <SNR>55_AutoClose()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim:282
Called 27 times
Total time:   0.017128000
 Self time:   0.009313000

count     total (s)      self (s)
                                    " Add matching pair and jump to the midle:
                                    " inoremap <silent> <buffer> ( ()<Left>
   27                 0.000030000   let i = 0
  108   0.002267000   0.000597000   while i < len(s:get('matchpairs_list', []))
   81   0.003295000   0.000783000     let ld = s:get('left_delims', [])[i] == '|' ? '<bar>' : s:get('left_delims', [])[i]
   81   0.003155000   0.000741000     let rd = s:get('right_delims', [])[i] == '|' ? '<bar>' : s:get('right_delims', [])[i]
   81                 0.001400000     exec 'inoremap <expr><silent> <Plug>delimitMate' . ld. ' <SID>TriggerAbb().delimitMate#ParenDelim("' . escape(rd, '|') . '")'
   81                 0.000662000     exec 'silent! imap <unique> <buffer> '.ld.' <Plug>delimitMate'.ld
   81                 0.000093000     let i += 1
  108                 0.000053000   endwhile
                                  
                                    " Exit from inside the matching pair:
  108   0.000574000   0.000175000   for delim in s:get('right_delims', [])
   81                 0.000123000     let delim = delim == '|' ? '<bar>' : delim
   81                 0.000988000     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb().delimitMate#JumpOut("\' . delim . '")'
   81                 0.000551000     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate'. delim
  108                 0.000051000   endfor
                                  
                                    " Add matching quote and jump to the midle, or exit if inside a pair of matching quotes:
                                    " inoremap <silent> <buffer> " <C-R>=delimitMate#QuoteDelim("\"")<CR>
  108   0.000594000   0.000192000   for delim in s:get('quotes_list', [])
   81                 0.000071000     if delim == '|'
                                        let delim = '<Bar>'
   81                 0.000037000     endif
   81                 0.001143000     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb()."<C-R>=delimitMate#QuoteDelim(\"\\\' . delim . '\")<CR>"'
   81                 0.000630000     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate' . delim
  108                 0.000053000   endfor
                                  
                                    " Try to fix the use of apostrophes (kept for backward compatibility):
                                    " inoremap <silent> <buffer> n't n't
   27   0.000557000   0.000139000   for map in s:get('apostrophes_list', [])
                                      exec "inoremap <silent> " . map . " " . map
                                      exec 'silent! imap <unique> <buffer> ' . map . ' <Plug>delimitMate' . map
   27                 0.000014000   endfor

FUNCTION  240()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:271
Called 41 times
Total time:   0.000070000
 Self time:   0.000070000

count     total (s)      self (s)
   41                 0.000061000     return self._showBookmarks

FUNCTION  241()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:276
Called 2205 times
Total time:   0.002334000
 Self time:   0.002334000

count     total (s)      self (s)
 2205                 0.001841000     return self._showFiles

FUNCTION  243()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:286
Called 2520 times
Total time:   0.002702000
 Self time:   0.002702000

count     total (s)      self (s)
 2520                 0.002097000     return self._showHidden

FUNCTION  244()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:291
Called 306 times
Total time:   0.000469000
 Self time:   0.000469000

count     total (s)      self (s)
  306                 0.000360000     return self._showFileLines

FUNCTION  245()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:296
Called 895 times
Total time:   0.017139000
 Self time:   0.016149000

count     total (s)      self (s)
                                      " Replace multi-character DirArrows with a single space so the
                                      " indentation calculation doesn't get messed up.
  895                 0.001241000     if g:NERDTreeDirArrowExpandable ==# ''
                                          let l:line = '  '.a:line
  895                 0.000504000     else
  895                 0.006049000         let l:line = substitute(substitute(a:line, '\V'.g:NERDTreeDirArrowExpandable, ' ', ''), '\V'.g:NERDTreeDirArrowCollapsible, ' ', '')
  895                 0.000488000     endif
  895                 0.003458000     let leadChars = match(l:line, '\M\[^ ]')
  895   0.003135000   0.002145000     return leadChars / s:UI.IndentWid()

FUNCTION  247()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:314
Called 2520 times
Total time:   0.002978000
 Self time:   0.002978000

count     total (s)      self (s)
 2520                 0.002457000     return self._ignoreEnabled ==# 1

FUNCTION  248()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:319
Called 164 times
Total time:   0.000286000
 Self time:   0.000286000

count     total (s)      self (s)
  164                 0.000230000     return g:NERDTreeMinimalUI

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 22 times
Total time:   0.000470000
 Self time:   0.000105000

count     total (s)      self (s)
   22   0.000243000   0.000037000   let summary = gitgutter#hunk#summary(a:bufnr)
   22                 0.000024000   let summary[0] += a:count
   22   0.000203000   0.000044000   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>50_on_buffilepost()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:277
Called 2 times
Total time:   0.000769000
 Self time:   0.000111000

count     total (s)      self (s)
    2                 0.000009000   if len(s:renaming) > 1
                                      if s:renaming[0] != a:bufnr
                                        throw 'gitgutter rename error' s:renaming[0] a:bufnr
                                      endif
                                      unlet s:renaming[0]
                                      return
    2                 0.000001000   endif
                                  
                                    " reset cached values
    2   0.000700000   0.000042000   GitGutterBufferDisable
                                  
    2                 0.000005000   if s:gitgutter_was_enabled
                                      GitGutterBufferEnable
    2                 0.000003000   endif
                                  
    2                 0.000006000   unlet s:renaming
    2                 0.000004000   unlet s:gitgutter_was_enabled

FUNCTION  airline#extensions#tabline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:227
Called 26 times
Total time:   0.001074000
 Self time:   0.000458000

count     total (s)      self (s)
   26   0.000743000   0.000127000   let builder = airline#builder#new(a:context)
   26                 0.000060000   let builder._build = builder.build
   26                 0.000189000   call extend(builder, s:prototype, 'force')
   26                 0.000027000   return builder

FUNCTION  airline#extensions#searchcount#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:33
Called 271 times
Total time:   0.030427000
 Self time:   0.020984000

count     total (s)      self (s)
  271                 0.000319000   try
  271                 0.009927000     let result = searchcount(#{recompute: 1, maxcount: -1})
  271                 0.000859000     if empty(result) || result.total ==# 0
  156                 0.000171000       return ''
  115                 0.000094000     endif
  115                 0.000254000     if result.incomplete ==# 1     " timed out
                                        return printf('%s[?/??]', s:search_term())
  115                 0.000266000     elseif result.incomplete ==# 2 " max count exceeded
                                        if result.total > result.maxcount &&  result.current > result.maxcount
                                          return printf('%s[>%d/>%d]', s:search_term(),		    result.current, result.total)
                                        elseif result.total > result.maxcount
                                          return printf('%s[%d/>%d]', s:search_term(),		    result.current, result.total)
                                        endif
  115                 0.000090000     endif
  115   0.010776000   0.001333000     return printf('%s[%d/%d]', s:search_term(),		result.current, result.total)
                                    catch
                                      return ''
  271                 0.000330000   endtry

FUNCTION  <SNR>62_fzf_call()
    Defined: ~/.fzf/plugin/fzf.vim:70
Called 42 times
Total time:   0.001286000
 Self time:   0.001286000

count     total (s)      self (s)
   42                 0.001256000     return call(a:fn, a:000)

FUNCTION  <SNR>103_new_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:40
Called 110 times
Total time:   0.000412000
 Self time:   0.000412000

count     total (s)      self (s)
                                    " The FirstProblem call in ALE is a far more efficient way
                                    " of obtaining line number data. If the installed ALE supports
                                    " it, we should use this method of getting line data.
  110                 0.000107000   if a:cnt == 0
  110                 0.000083000     return ''
                                    endif
                                    let l:buffer = bufnr('')
                                  
                                    " Try to get the first error from ALE.
                                    let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
                                    if empty(l:result)
                                      " If there are no errors then try and check for style errors.
                                      let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                                    endif
                                  
                                    if empty(l:result)
                                        return ''
                                    endif
                                  
                                    let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                                    let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                                  
                                    return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:231
Called 428 times
Total time:   0.061436000
 Self time:   0.005688000

count     total (s)      self (s)
  428   0.003386000   0.001696000     let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
  428                 0.001249000     let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
  428   0.056481000   0.002423000     return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>119_reset_tick()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:189
Called 10 times
Total time:   0.000737000
 Self time:   0.000177000

count     total (s)      self (s)
   10   0.000724000   0.000164000   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  <SNR>147_CreateCountDict()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:5
Called 110 times
Total time:   0.000820000
 Self time:   0.000820000

count     total (s)      self (s)
                                      " Keys 0 and 1 are for backwards compatibility.
                                      " The count object used to be a List of [error_count, warning_count].
  110                 0.000618000     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  250()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:329
Called 41 times
Total time:   0.002779000
 Self time:   0.001738000

count     total (s)      self (s)
                                  
   41   0.000170000   0.000100000     if !self.isMinimal()
   41                 0.000211000         call setline(line('.')+1, '>----------Bookmarks----------')
   41                 0.000137000         call cursor(line('.')+1, col('.'))
   41                 0.000041000     endif
                                  
   41                 0.000103000     if g:NERDTreeBookmarksSort ==# 1 || g:NERDTreeBookmarksSort ==# 2
   41   0.000924000   0.000195000         call g:NERDTreeBookmark.SortBookmarksList()
   41                 0.000030000     endif
                                  
   41   0.000399000   0.000157000     for i in g:NERDTreeBookmark.Bookmarks()
                                          call setline(line('.')+1, i.str())
                                          call cursor(line('.')+1, col('.'))
   41                 0.000035000     endfor
                                  
   41                 0.000186000     call setline(line('.')+1, '')
   41                 0.000137000     call cursor(line('.')+1, col('.'))

FUNCTION  252()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:372
Called 12 times
Total time:   0.002883000
 Self time:   0.000690000

count     total (s)      self (s)
   12                 0.000073000     let win = winnr()
   12                 0.000097000     let self._screenState = {}
   12                 0.000016000     try
   12   0.001988000   0.000056000         call g:NERDTree.CursorToTreeWin()
   12                 0.000092000         let self._screenState['oldPos'] = getpos('.')
   12                 0.000061000         let self._screenState['oldTopLine'] = line('w0')
   12                 0.000087000         let self._screenState['oldWindowSize'] = winnr('$')==1 ? g:NERDTreeWinSize : winwidth('')
   12   0.000387000   0.000126000         call nerdtree#exec(win . 'wincmd w', 1)
                                      catch
   12                 0.000018000     endtry

FUNCTION  253()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:386
Called 1 time
Total time:   0.000001000
 Self time:   0.000001000

count     total (s)      self (s)
    1                 0.000000000     let self._showHidden = a:val

FUNCTION  254()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:395
Called 936 times
Total time:   0.009243000
 Self time:   0.009243000

count     total (s)      self (s)
  936                 0.005488000     let l:line = substitute(a:line, '^.\{-}' . g:NERDTreeNodeDelimiter, '', '')
  936                 0.003371000     return substitute(l:line, g:NERDTreeNodeDelimiter.'.*$', '', '')

FUNCTION  255()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:401
Called 41 times
Total time:   0.868099000
 Self time:   0.009027000

count     total (s)      self (s)
   41   0.000923000   0.000726000     setlocal noreadonly modifiable
                                  
                                      " remember the top line of the buffer and the current line so we can
                                      " restore the view exactly how it was
   41                 0.000159000     let curLine = line('.')
   41                 0.000149000     let curCol = col('.')
   41                 0.000117000     let topLine = line('w0')
                                  
                                      " delete all lines in the buffer (being careful not to clobber a register)
   41                 0.002131000     silent 1,$delete _
                                  
   41   0.007769000   0.000212000     call self._dumpHelp()
                                  
                                      " delete the blank line before the help and add one after it
   41   0.000162000   0.000094000     if !self.isMinimal()
   41                 0.000448000         call setline(line('.')+1, '')
   41                 0.000199000         call cursor(line('.')+1, col('.'))
   41                 0.000027000     endif
                                  
   41   0.000196000   0.000126000     if self.getShowBookmarks()
   41   0.002899000   0.000120000         call self._renderBookmarks()
   41                 0.000023000     endif
                                  
                                      " add the 'up a dir' line
   41   0.000156000   0.000094000     if !self.isMinimal()
   41   0.000347000   0.000281000         call setline(line('.')+1, s:UI.UpDirLine())
   41                 0.000130000         call cursor(line('.')+1, col('.'))
   41                 0.000023000     endif
                                  
                                      " draw the header line
   41   0.003701000   0.000462000     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
   41                 0.000205000     call setline(line('.')+1, header)
   41                 0.000139000     call cursor(line('.')+1, col('.'))
                                  
                                      " draw the tree
   41   0.845748000   0.000935000     silent put =self.nerdtree.root.renderToString()
                                  
                                      " delete the blank line at the top of the buffer
   41                 0.000196000     silent 1,1delete _
                                  
                                      " restore the view
   41                 0.000116000     let old_scrolloff=&scrolloff
   41   0.000358000   0.000264000     let &scrolloff=0
   41                 0.000114000     call cursor(topLine, 1)
   41                 0.000636000     normal! zt
   41                 0.000093000     call cursor(curLine, curCol)
   41   0.000166000   0.000123000     let &scrolloff = old_scrolloff
                                  
   41   0.000294000   0.000210000     setlocal readonly nomodifiable

FUNCTION  256()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:457
Called 6 times
Total time:   0.179188000
 Self time:   0.000289000

count     total (s)      self (s)
    6   0.041675000   0.000089000     let currentNode = g:NERDTreeFileNode.GetSelected()
                                  
                                      " go up the tree till we find a node that will be visible or till we run
                                      " out of nodes
    6   0.003708000   0.000057000     while currentNode !=# {} && !currentNode.isVisible() && !currentNode.isRoot()
                                          let currentNode = currentNode.parent
    6                 0.000008000     endwhile
                                  
    6   0.128942000   0.000040000     call self.render()
                                  
    6                 0.000014000     if currentNode !=# {}
    6   0.004793000   0.000033000         call currentNode.putCursorHere(0, 0)
    6                 0.000002000     endif

FUNCTION  go#config#HighlightStringSpellcheck()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:443
Called 16 times
Total time:   0.000045000
 Self time:   0.000045000

count     total (s)      self (s)
   16                 0.000040000   return get(g:, 'go_highlight_string_spellcheck', 1)

FUNCTION  <SNR>51_winshell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:77
Called 11 times
Total time:   0.000132000
 Self time:   0.000132000

count     total (s)      self (s)
   11                 0.000124000   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  go#config#MetalinterAutosave()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:279
Called 9 times
Total time:   0.000021000
 Self time:   0.000021000

count     total (s)      self (s)
    9                 0.000015000   return get(g:, "go_metalinter_autosave", 0)

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:72
Called 150 times
Total time:   0.026015000
 Self time:   0.009362000

count     total (s)      self (s)
  150                 0.000823000   let filetype_overrides = get(s:, 'filetype_overrides', {})
  150                 0.000740000   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                                  
  150   0.009749000   0.000645000   if s:is_excluded_window()
                                      return -1
  150                 0.000072000   endif
                                  
  150                 0.000237000   if &buftype == 'terminal'
                                      let w:airline_section_x = ''
                                      let w:airline_section_y = ''
  150                 0.000083000   endif
                                  
  150                 0.000591000   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                      let w:airline_section_a = 'Preview'
                                      let w:airline_section_b = ''
                                      let w:airline_section_c = bufname(winbufnr(winnr()))
  150                 0.000107000   endif
                                  
  150                 0.000819000   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                      " for help files only override it, if the buftype is also of type 'help',
                                      " else it would trigger when editing Vim help files
   31                 0.000108000     let args = filetype_overrides[&ft]
   31   0.007807000   0.000258000     call airline#extensions#apply_left_override(args[0], args[1])
  150                 0.000082000   endif
                                  
  150                 0.000212000   if &buftype == 'help'
                                      let w:airline_section_x = ''
                                      let w:airline_section_y = ''
                                      let w:airline_render_right = 1
  150                 0.000085000   endif
                                  
  150                 0.000527000   for item in items(s:filetype_regex_overrides)
                                      if match(&ft, item[0]) >= 0
                                        call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                      endif
  150                 0.000121000   endfor

FUNCTION  <SNR>101_config_fugitive_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:99
Called 257 times
Total time:   0.174729000
 Self time:   0.004706000

count     total (s)      self (s)
  257   0.172369000   0.002346000   let s:vcs_config['git'].branch =  FugitiveHead(s:sha1size)
  257                 0.001069000   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                      " Shorten default a bit
                                      let s:vcs_config['git'].branch='mas'
  257                 0.000179000   endif

FUNCTION  ale#Set()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:204
Called 5 times
Total time:   0.000040000
 Self time:   0.000040000

count     total (s)      self (s)
    5                 0.000013000     let l:full_name = 'ale_' . a:variable_name
                                  
    5                 0.000007000     if !has_key(g:, l:full_name)
    5                 0.000012000         let g:[l:full_name] = a:default
    5                 0.000004000     endif

FUNCTION  <SNR>172_process_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:315
Called 22 times
Total time:   0.001032000
 Self time:   0.001032000

count     total (s)      self (s)
   22                 0.000013000   let offset = 0
   44                 0.000039000   while offset < a:from_count
   22                 0.000025000     let line_number = a:to_line + offset
   22                 0.000035000     call add(a:modifications, [line_number, 'modified'])
   22                 0.000018000     let offset += 1
   44                 0.000016000   endwhile
  198                 0.000136000   while offset < a:to_count
  176                 0.000135000     let line_number = a:to_line + offset
  176                 0.000260000     call add(a:modifications, [line_number, 'added'])
  176                 0.000126000     let offset += 1
  198                 0.000063000   endwhile

FUNCTION  go#path#BinPath()
    Defined: ~/.vim/plugged/vim-go/autoload/go/path.vim:73
Called 17 times
Total time:   0.001113000
 Self time:   0.000736000

count     total (s)      self (s)
   17   0.000249000   0.000130000   let l:bin_path = go#config#BinPath()
   17                 0.000039000   if l:bin_path isnot ""
                                      return l:bin_path
   17                 0.000010000   endif
                                  
                                    " check if our global custom path is set, if not check if GOBIN is set so
                                    " we can use it, otherwise use default GOPATH
   17   0.000356000   0.000098000   let l:bin_path = go#util#env('gobin')
   17                 0.000028000   if l:bin_path isnot ''
   17                 0.000069000     let l:bin_path = $GOBIN
                                    else
                                      let l:go_paths = split(go#path#Default(), go#util#PathListSep())
                                      if len(l:go_paths) == 0
                                        return '' "nothing found
                                      endif
                                      let l:bin_path = expand(l:go_paths[0] . '/bin/')
   17                 0.000012000   endif
                                  
   17                 0.000023000   return l:bin_path

FUNCTION  <SNR>142_TempDelete()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3319
Called 8 times
Total time:   0.001783000
 Self time:   0.000212000

count     total (s)      self (s)
    8   0.001641000   0.000070000   let key = s:cpath(s:AbsoluteVimPath(a:file))
    8                 0.000070000   if has_key(s:temp_files, key) && !has_key(s:temp_files[key], 'job') && key !=# s:cpath(get(get(g:, '_fugitive_last_job', {}), 'file', ''))
                                      call delete(a:file)
                                      call remove(s:temp_files, key)
    8                 0.000004000   endif
    8                 0.000008000   return ''

FUNCTION  <SNR>41_BufWinEnterHandler()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:612
Called 10 times
Total time:   0.000103000
 Self time:   0.000103000

count     total (s)      self (s)
   10                 0.000023000   if s:NewTabCreated
                                      " Turn off the 'NewTabCreated' flag
                                      let s:NewTabCreated = 0
                                  
                                      " Restore focus to NERDTree if necessary
                                      if !g:nerdtree_tabs_focus_on_files
                                        call s:NERDTreeRestoreFocus()
                                      endif
   10                 0.000006000   endif

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:218
Called 720 times
Total time:   0.014422000
 Self time:   0.014422000

count     total (s)      self (s)
  720                 0.007029000   if has_key(s:contexts, a:winnr)
  720                 0.005705000     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                                    endif
                                    " in rare circumstances this happens...see #276
                                    return ''

FUNCTION  <SNR>147_GetCounts()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:97
Called 110 times
Total time:   0.002258000
 Self time:   0.000811000

count     total (s)      self (s)
  110   0.001011000   0.000384000     if !s:BufferCacheExists(a:buffer)
  110   0.001155000   0.000335000         return s:CreateCountDict()
                                      endif
                                  
                                      call s:UpdateCacheIfNecessary(a:buffer)
                                  
                                      return g:ale_buffer_info[a:buffer].count

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:60
Called 34 times
Total time:   0.011745000
 Self time:   0.000782000

count     total (s)      self (s)
   34   0.011691000   0.000728000   return gitgutter#utility#getbufvar(a:bufnr, 'enabled') && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  go#config#ListType()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:132
Called 8 times
Total time:   0.000036000
 Self time:   0.000036000

count     total (s)      self (s)
    8                 0.000028000   return get(g:, 'go_list_type', '')

FUNCTION  262()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:523
Called 6 times
Total time:   0.179634000
 Self time:   0.000100000

count     total (s)      self (s)
    6                 0.000019000     let self._showHidden = !self._showHidden
    6   0.179232000   0.000044000     call self.renderViewSavingPosition()
    6   0.000373000   0.000027000     call self.centerView()

FUNCTION  265()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:554
Called 62 times
Total time:   0.000125000
 Self time:   0.000125000

count     total (s)      self (s)
   62                 0.000084000     return '.. (up a dir)'

FUNCTION  266()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/event.vim:6
Called 471 times
Total time:   0.004660000
 Self time:   0.004660000

count     total (s)      self (s)
  471                 0.001229000     let newObj = copy(self)
  471                 0.000724000     let newObj.nerdtree = a:nerdtree
  471                 0.000640000     let newObj.subject = a:subject
  471                 0.000575000     let newObj.action = a:action
  471                 0.000613000     let newObj.params = a:params
  471                 0.000400000     return newObj

FUNCTION  268()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:14
Called 471 times
Total time:   0.017536000
 Self time:   0.007320000

count     total (s)      self (s)
  471   0.006887000   0.002227000     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                                  
  471   0.007294000   0.001738000     for Listener in s:Notifier.GetListenersForEvent(a:event)
                                          let l:Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
                                          call l:Callback(event)
  471                 0.000361000     endfor

FUNCTION  269()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:23
Called 471 times
Total time:   0.002749000
 Self time:   0.002749000

count     total (s)      self (s)
  471                 0.001255000     if !exists('s:refreshListenersMap')
                                          let s:refreshListenersMap = {}
  471                 0.000215000     endif
  471                 0.000512000     return s:refreshListenersMap

FUNCTION  <SNR>62_split()
    Defined: ~/.fzf/plugin/fzf.vim:799
Called 2 times
Total time:   0.000848000
 Self time:   0.000307000

count     total (s)      self (s)
    2                 0.000034000   let directions = { 'up':    ['topleft', 'resize', &lines], 'down':  ['botright', 'resize', &lines], 'left':  ['vertical topleft', 'vertical resize', &columns], 'right': ['vertical botright', 'vertical resize', &columns] }
    2   0.000051000   0.000016000   let ppos = s:getpos()
    2                 0.000005000   let is_popup = 0
    2                 0.000003000   try
    2   0.000036000   0.000012000     if s:present(a:dict, 'window')
    2                 0.000011000       if type(a:dict.window) == type({})
    2   0.000043000   0.000010000         if !s:popup_support()
                                            throw 'Nvim 0.4+ or Vim 8.2.191+ with popupwin feature is required for pop-up window'
    2                 0.000003000         end
    2   0.000468000   0.000019000         call s:popup(a:dict.window)
    2                 0.000005000         let is_popup = 1
                                        else
                                          execute 'keepalt' a:dict.window
    2                 0.000003000       endif
                                      elseif !s:splittable(a:dict)
                                        execute (tabpagenr()-1).'tabnew'
                                      else
                                        for [dir, triple] in items(directions)
                                          let val = get(a:dict, dir, '')
                                          if !empty(val)
                                            let [cmd, resz, max] = triple
                                            if (dir == 'up' || dir == 'down') && val[0] == '~'
                                              let sz = s:calc_size(max, val, a:dict)
                                            else
                                              let sz = s:calc_size(max, val, {})
                                            endif
                                            execute cmd sz.'new'
                                            execute resz sz
                                            return [ppos, {}, is_popup]
                                          endif
                                        endfor
    2                 0.000003000     endif
    2                 0.000015000     return [ppos, is_popup ? {} : { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }, is_popup]
    2                 0.000004000   finally
    2                 0.000004000     if !is_popup
                                        setlocal winfixwidth winfixheight
    2                 0.000002000     endif
    2                 0.000004000   endtry

FUNCTION  <SNR>153_on_exit_vim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:87
Called 13 times
Total time:   0.011659000
 Self time:   0.000574000

count     total (s)      self (s)
   13                 0.000087000   let job = ch_getjob(a:channel)
   13   0.000272000   0.000064000   let jobid = s:job_id(job)
   13                 0.000088000   if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
   13                 0.000027000   while 1
   13                 0.000034000     if job_status(job) == 'dead'
   13                 0.000038000       let exit_code = job_info(job).exitval
   13                 0.000011000       break
                                      endif
                                      sleep 5m
   13                 0.000009000   endwhile
                                  
   13                 0.000010000   if !exit_code
   11   0.010981000   0.000104000     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
   13                 0.000006000   endif

FUNCTION  <SNR>62_shortpath()
    Defined: ~/.fzf/plugin/fzf.vim:1064
Called 1 time
Total time:   0.000291000
 Self time:   0.000291000

count     total (s)      self (s)
    1                 0.000215000   let short = fnamemodify(getcwd(), ':~:.')
    1                 0.000012000   if !has('win32unix')
    1                 0.000012000     let short = pathshorten(short)
    1                 0.000002000   endif
    1                 0.000008000   let slash = (s:is_win && !&shellslash) ? '\' : '/'
    1                 0.000036000   return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)

FUNCTION  <SNR>121_Lint()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:96
Called 12 times
Total time:   0.009594000
 Self time:   0.000869000

count     total (s)      self (s)
                                      " Use the filetype from the buffer
   12                 0.000182000     let l:filetype = getbufvar(a:buffer, '&filetype')
   12   0.008277000   0.000083000     let l:linters = ale#linter#Get(l:filetype)
                                  
   12   0.000179000   0.000045000     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
   12   0.000131000   0.000034000     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                                  
                                      " Load code to ignore linters only if we need to.
   12                 0.000084000     if (   !empty(l:ignore_config)   || l:disable_lsp is 1   || l:disable_lsp is v:true   || (l:disable_lsp is# 'auto' && get(g:, 'lspconfig', 0)))
                                          let l:linters = ale#engine#ignore#Exclude(   l:filetype,   l:linters,   l:ignore_config,   l:disable_lsp,)
   12                 0.000008000     endif
                                  
                                      " Tell other sources that they can start checking the buffer now.
   12                 0.000038000     let g:ale_want_results_buffer = a:buffer
   12   0.000467000   0.000167000     silent doautocmd <nomodeline> User ALEWantResults
   12                 0.000023000     unlet! g:ale_want_results_buffer
                                  
                                      " Don't set up buffer data and so on if there are no linters to run.
   12                 0.000054000     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
   12                 0.000011000         return
                                      endif
                                  
                                      " Clear lint_file linters, or only run them if the file exists.
                                      let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                                  
                                      call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:74
Called 361 times
Total time:   0.058619000
 Self time:   0.023743000

count     total (s)      self (s)
  361                 0.007753000     let l:buffer = bufnr('')
                                  
  361                 0.001816000     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                          return
  361                 0.000645000     endif
                                  
                                      " Only echo the warnings in normal mode, otherwise we will get problems.
  361                 0.002181000     if mode(1) isnot# 'n'
    1                 0.000001000         return
  360                 0.000268000     endif
                                  
  360   0.034852000   0.003285000     if ale#ShouldDoNothing(l:buffer)
  301                 0.000330000         return
   59                 0.000069000     endif
                                  
   59   0.003886000   0.000577000     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                                  
   59                 0.000109000     if g:ale_echo_cursor
   59                 0.000172000         if !empty(l:loc)
                                              let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                              let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                              call ale#cursor#TruncatedEcho(l:msg)
                                              let l:info.echoed = 1
   59                 0.000166000         elseif get(l:info, 'echoed')
                                              " We'll only clear the echoed message when moving off errors once,
                                              " so we don't continually clear the echo line.
                                              "
                                              " no-custom-checks
                                              echo
                                              let l:info.echoed = 0
   59                 0.000053000         endif
   59                 0.000047000     endif
                                  
   59                 0.000095000     if g:ale_cursor_detail
                                          if !empty(l:loc)
                                              call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                          else
                                              call ale#preview#CloseIfTypeMatches('ale-preview')
                                          endif
   59                 0.000043000     endif

FUNCTION  <SNR>188_DetectFromText()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/autoload/dist/script.vim:239
Called 3 times
Total time:   0.000704000
 Self time:   0.000704000

count     total (s)      self (s)
    3                 0.000000000   var line2 = getline(2)
    3                 0.000002000   var line3 = getline(3)
    3                 0.000000000   var line4 = getline(4)
    3                 0.000001000   var line5 = getline(5)
                                  
                                    # Bourne-like shell scripts: sh ksh bash bash2
    3                 0.000641000   if line1 =~ '^:$'
                                      call dist#ft#SetFileTypeSH(line1)
                                  
                                    # Z shell scripts
                                    elseif line1 =~ '^#compdef\>'
                                        || line1 =~ '^#autoload\>'
                                        || "\n" .. line1 .. "\n" .. line2 .. "\n" .. line3 ..
                                  	 "\n" .. line4 .. "\n" .. line5
                                  	 =~ '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                      setl ft=zsh
                                  
                                    # ELM Mail files
                                    elseif line1 =~ '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                      setl ft=mail
                                  
                                    # Mason
                                    elseif line1 =~ '^<[%&].*>'
                                      setl ft=mason
                                  
                                    # Vim scripts (must have '" vim' as the first line to trigger this)
                                    elseif line1 =~ '^" *[vV]im$'
                                      setl ft=vim
                                  
                                    # libcxx and libstdc++ standard library headers like "iostream" do not have
                                    # an extension, recognize the Emacs file mode.
                                    elseif line1 =~? '-\*-.*C++.*-\*-'
                                      setl ft=cpp
                                  
                                    # MOO
                                    elseif line1 =~ '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                      setl ft=moo
                                  
                                      # Diff file:
                                      # - "diff" in first line (context diff)
                                      # - "Only in " in first line
                                      # - "--- " in first line and "+++ " in second line (unified diff).
                                      # - "*** " in first line and "--- " in second line (context diff).
                                      # - "# It was generated by makepatch " in the second line (makepatch diff).
                                      # - "Index: <filename>" in the first line (CVS file)
                                      # - "=== ", line of "=", "---", "+++ " (SVK diff)
                                      # - "=== ", "--- ", "+++ " (bzr diff, common case)
                                      # - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                      # - "# HG changeset patch" in first line (Mercurial export format)
                                    elseif line1 =~ '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                                  	 || (line1 =~ '^--- ' && line2 =~ '^+++ ')
                                  	 || (line1 =~ '^\* looking for ' && line2 =~ '^\* comparing to ')
                                  	 || (line1 =~ '^\*\*\* ' && line2 =~ '^--- ')
                                  	 || (line1 =~ '^=== ' && ((line2 =~ '^=\{66\}' && line3 =~ '^--- ' && line4 =~ '^+++') || (line2 =~ '^--- ' && line3 =~ '^+++ ')))
                                  	 || (line1 =~ '^=== \(removed\|added\|renamed\|modified\)')
                                      setl ft=diff
                                  
                                      # PostScript Files (must have %!PS as the first line, like a2ps output)
                                    elseif line1 =~ '^%![ \t]*PS'
                                      setl ft=postscr
                                  
                                      # M4 scripts: Guess there is a line that starts with "dnl".
                                    elseif line1 =~ '^\s*dnl\>'
                                  	 || line2 =~ '^\s*dnl\>'
                                  	 || line3 =~ '^\s*dnl\>'
                                  	 || line4 =~ '^\s*dnl\>'
                                  	 || line5 =~ '^\s*dnl\>'
                                      setl ft=m4
                                  
                                      # AmigaDos scripts
                                    elseif $TERM == "amiga" && (line1 =~ "^;" || line1 =~? '^\.bra')
                                      setl ft=amiga
                                  
                                      # SiCAD scripts (must have procn or procd as the first line to trigger this)
                                    elseif line1 =~? '^ *proc[nd] *$'
                                      setl ft=sicad
                                  
                                      # Purify log files start with "****  Purify"
                                    elseif line1 =~ '^\*\*\*\*  Purify'
                                      setl ft=purifylog
                                  
                                      # XML
                                    elseif line1 =~ '<?\s*xml.*?>'
                                      setl ft=xml
                                  
                                      # XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                                    elseif line1 =~ '\<DTD\s\+XHTML\s'
                                      setl ft=xhtml
                                  
                                      # HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                      # Avoid "doctype html", used by slim.
                                    elseif line1 =~? '<!DOCTYPE\s\+html\>'
                                      setl ft=html
                                  
                                      # PDF
                                    elseif line1 =~ '^%PDF-'
                                      setl ft=pdf
                                  
                                      # XXD output
                                    elseif line1 =~ '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                      setl ft=xxd
                                  
                                      # RCS/CVS log output
                                    elseif line1 =~ '^RCS file:' || line2 =~ '^RCS file:'
                                      setl ft=rcslog
                                  
                                      # CVS commit
                                    elseif line2 =~ '^CVS:' || getline("$") =~ '^CVS: '
                                      setl ft=cvs
                                  
                                      # Prescribe
                                    elseif line1 =~ '^!R!'
                                      setl ft=prescribe
                                  
                                      # Send-pr
                                    elseif line1 =~ '^SEND-PR:'
                                      setl ft=sendpr
                                  
                                      # SNNS files
                                    elseif line1 =~ '^SNNS network definition file'
                                      setl ft=snnsnet
                                    elseif line1 =~ '^SNNS pattern definition file'
                                      setl ft=snnspat
                                    elseif line1 =~ '^SNNS result file'
                                      setl ft=snnsres
                                  
                                      # Virata
                                    elseif line1 =~ '^%.\{-}[Vv]irata'
                                  	 || line2 =~ '^%.\{-}[Vv]irata'
                                  	 || line3 =~ '^%.\{-}[Vv]irata'
                                  	 || line4 =~ '^%.\{-}[Vv]irata'
                                  	 || line5 =~ '^%.\{-}[Vv]irata'
                                      setl ft=virata
                                  
                                      # Strace
                                      # inaccurate fast match first, then use accurate slow match
                                    elseif (line1 =~ 'execve(' && line1 =~ '^[0-9:. ]*execve(')
                                  	   || line1 =~ '^__libc_start_main'
                                      setl ft=strace
                                  
                                      # VSE JCL
                                    elseif line1 =~ '^\* $$ JOB\>' || line1 =~ '^// *JOB\>'
                                      setl ft=vsejcl
                                  
                                      # TAK and SINDA
                                    elseif line4 =~ 'K & K  Associates' || line2 =~ 'TAK 2000'
                                      setl ft=takout
                                    elseif line3 =~ 'S Y S T E M S   I M P R O V E D '
                                      setl ft=sindaout
                                    elseif getline(6) =~ 'Run Date: '
                                      setl ft=takcmp
                                    elseif getline(9) =~ 'Node    File  1'
                                      setl ft=sindacmp
                                  
                                      # DNS zone files
                                    elseif line1 .. line2 .. line3 .. line4 =~ '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                      setl ft=bindzone
                                  
                                      # BAAN
                                    elseif line1 =~ '|\*\{1,80}' && line2 =~ 'VRC '
                                  	 || line2 =~ '|\*\{1,80}' && line3 =~ 'VRC '
                                      setl ft=baan
                                  
                                      # Valgrind
                                    elseif line1 =~ '^==\d\+== valgrind' || line3 =~ '^==\d\+== Using valgrind'
                                      setl ft=valgrind
                                  
                                      # Go docs
                                    elseif line1 =~ '^PACKAGE DOCUMENTATION$'
                                      setl ft=godoc
                                  
                                      # Renderman Interface Bytestream
                                    elseif line1 =~ '^##RenderMan'
                                      setl ft=rib
                                  
                                      # Scheme scripts
                                    elseif line1 =~ 'exec\s\+\S*scheme' || line2 =~ 'exec\s\+\S*scheme'
                                      setl ft=scheme
                                  
                                      # Git output
                                    elseif line1 =~ '^\(commit\|tree\|object\) \x\{40,\}\>\|^tag \S\+$'
                                      setl ft=git
                                  
                                      # Gprof (gnu profiler)
                                    elseif line1 == 'Flat profile:'
                                  	&& line2 == ''
                                  	&& line3 =~ '^Each sample counts as .* seconds.$'
                                      setl ft=gprof
                                  
                                      # Erlang terms
                                      # (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
                                    elseif line1 =~? '-\*-.*erlang.*-\*-'
                                      setl ft=erlang
                                  
                                      # YAML
                                    elseif line1 =~ '^%YAML'
                                      setl ft=yaml
                                  
                                      # MikroTik RouterOS script
                                    elseif line1 =~ '^#.*by RouterOS.*$'
                                      setl ft=routeros
                                  
                                      # Sed scripts
                                      # #ncomment is allowed but most likely a false positive so require a space
                                      # before any trailing comment text
                                    elseif line1 =~ '^#n\%($\|\s\)'
                                      setl ft=sed
                                  
                                    else
    3                 0.000002000     var lnum = 1
    3                 0.000011000     while getline(lnum) =~ "^? " && lnum < line("$")
                                        lnum += 1
                                      endwhile
    3                 0.000037000     if getline(lnum) =~ '^Index:\s\+\f\+$'
                                        # CVS diff
                                        setl ft=diff
                                  
                                        # locale input files: Formal Definitions of Cultural Conventions
                                        # filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                      elseif expand("%") =~ '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                        lnum = 1
                                        while lnum < 100 && lnum < line("$")
                                  	if getline(lnum) =~ '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                                  	  setf fdcc
                                  	  break
                                  	endif
                                  	lnum += 1
                                        endwhile
                                      endif
    3                 0.000004000   endif

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:160
Called 277 times
Total time:   0.002668000
 Self time:   0.002668000

count     total (s)      self (s)
  277                 0.001086000   if !exists("s:has_lawrencium")
                                      let s:has_lawrencium  = exists('*lawrencium#statusline')
  277                 0.000174000   endif
  277                 0.000373000   return s:has_lawrencium

FUNCTION  <SNR>142_ExpireStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:4285
Called 19 times
Total time:   0.004395000
 Self time:   0.000594000

count     total (s)      self (s)
   19                 0.000033000   if a:bufnr is# -2 || a:bufnr is# 0
   10                 0.000217000     let s:head_cache = {}
   10                 0.000097000     let s:last_time = reltime()
   10                 0.000010000     return ''
    9                 0.000001000   endif
    9   0.003462000   0.000051000   let head_file = fugitive#Find('.git/HEAD', a:bufnr)
    9                 0.000011000   if !empty(head_file)
    9   0.000452000   0.000062000     let s:last_times[s:Tree(a:bufnr) . '/'] = reltime()
    9                 0.000030000     if has_key(s:head_cache, head_file)
    9                 0.000025000       call remove(s:head_cache, head_file)
    9                 0.000002000     endif
    9                 0.000003000   endif
    9                 0.000004000   return ''

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:68
Called 10439 times
Total time:   1.411302000
 Self time:   0.489121000

count     total (s)      self (s)
                                      " only check for the cterm reverse attribute
                                      " TODO: do we need to check all modes (gui, term, as well)?
10439                 0.071864000     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
10439                 0.029483000     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                        let res = s:hl_groups[a:group]
                                        return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
10439                 0.005308000     else
10439   0.260267000   0.035122000       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
10439   0.248255000   0.032015000       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
10439   0.245718000   0.030343000       let guifg = s:get_syn(a:group, 'fg', 'gui')
10439   0.246481000   0.030131000       let guibg = s:get_syn(a:group, 'bg', 'gui')
10439                 0.058608000       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
10439                 0.008548000       if reverse
                                          let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
10439                 0.005709000       else
10439   0.094235000   0.045164000         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
10439                 0.005210000       endif
10439                 0.004516000     endif
10439                 0.027478000     let s:hl_groups[a:group] = res
10439                 0.007477000     return res

FUNCTION  <SNR>62_defaults()
    Defined: ~/.fzf/plugin/fzf.vim:365
Called 2 times
Total time:   0.000071000
 Self time:   0.000071000

count     total (s)      self (s)
    2                 0.000018000   let rules = copy(get(g:, 'fzf_colors', {}))
    2                 0.000034000   let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
    2                 0.000013000   return empty(colors) ? '' : fzf#shellescape('--color='.colors)

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:201
Called 11 times
Total time:   0.002177000
 Self time:   0.000668000

count     total (s)      self (s)
   11                 0.000013000   let hunks = []
   88                 0.000141000   for line in split(a:diff, '\n')
   77   0.001706000   0.000197000     let hunk_info = gitgutter#diff#parse_hunk(line)
   77                 0.000078000     if len(hunk_info) == 4
   77                 0.000098000       call add(hunks, hunk_info)
   77                 0.000033000     endif
   88                 0.000043000   endfor
   11                 0.000007000   return hunks

FUNCTION  go#path#CheckBinPath()
    Defined: ~/.vim/plugged/vim-go/autoload/go/path.vim:98
Called 17 times
Total time:   0.033737000
 Self time:   0.032407000

count     total (s)      self (s)
                                    " remove whitespaces if user applied something like 'goimports   '
   17                 0.000557000   let binpath = substitute(a:binpath, '^\s*\(.\{-}\)\s*$', '\1', '')
                                  
                                    " save original path
   17                 0.000099000   let old_path = $PATH
                                  
                                    " check if we have an appropriate bin_path
   17   0.001241000   0.000128000   let go_bin_path = go#path#BinPath()
   17                 0.000042000   if !empty(go_bin_path)
                                      " append our GOBIN and GOPATH paths and be sure they can be found there...
                                      " let us search in our GOBIN and GOPATH paths
                                      " respect the ordering specified by go_search_bin_path_first
                                      if go#config#SearchBinPathFirst()
                                        let $PATH = go_bin_path . go#util#PathListSep() . $PATH
                                      else
                                        let $PATH = $PATH . go#util#PathListSep() . go_bin_path
                                      endif
   17                 0.000011000   endif
                                  
                                    " if it's in PATH just return it
   17                 0.016668000   if executable(binpath)
   17                 0.000096000     if exists('*exepath')
   17                 0.013831000       let binpath = exepath(binpath)
   17                 0.000033000     endif
   17                 0.000358000     let $PATH = old_path
                                  
   17   0.000351000   0.000134000     if go#util#IsUsingCygwinShell() == 1
                                        return s:CygwinPath(binpath)
   17                 0.000012000     endif
                                  
   17                 0.000025000     return binpath
                                    endif
                                  
                                    " just get the basename
                                    let basename = fnamemodify(binpath, ":t")
                                    if !executable(basename)
                                      call go#util#EchoError(printf("could not find '%s'. Run :GoInstallBinaries to fix it", basename))
                                  
                                      " restore back!
                                      let $PATH = old_path
                                      return ""
                                    endif
                                  
                                    let $PATH = old_path
                                  
                                    if go#util#IsUsingCygwinShell() == 1
                                      return s:CygwinPath(a:binpath)
                                    endif
                                  
                                    return go_bin_path . go#util#PathSep() . basename

FUNCTION  <SNR>192_fzf()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:321
Called 1 time
Total time:   0.447264000
 Self time:   0.000104000

count     total (s)      self (s)
    1   0.371154000   0.000016000   call s:check_requirements()
                                  
    1                 0.000006000   let [extra, bang] = [{}, 0]
    1                 0.000003000   if len(a:extra) <= 1
                                      let first = get(a:extra, 0, 0)
                                      if type(first) == s:TYPE.dict
                                        let extra = first
                                      else
                                        let bang = first
                                      endif
    1                 0.000002000   elseif len(a:extra) == 2
    1                 0.000003000     let [extra, bang] = a:extra
                                    else
                                      throw 'invalid number of arguments'
    1                 0.000001000   endif
                                  
    1                 0.000005000   let extra  = copy(extra)
    1                 0.000007000   let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
    1                 0.000008000   let merged = extend(copy(a:opts), extra)
    1   0.000066000   0.000009000   call s:merge_opts(merged, eopts)
    1   0.075993000   0.000028000   return fzf#run(s:wrap(a:name, merged, bang))

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:30
Called 622 times
Total time:   0.021088000
 Self time:   0.013258000

count     total (s)      self (s)
  622   0.013411000   0.005581000   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                      if get(a:000, 0, 0)
                                        " shorten from tail
                                        return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                      else
                                        " shorten from beginning of string
                                        return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                      endif
  622                 0.000396000   else
  622                 0.000724000     return a:text
                                    endif

FUNCTION  270()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:30
Called 471 times
Total time:   0.005556000
 Self time:   0.002807000

count     total (s)      self (s)
  471   0.004216000   0.001467000     let listenersMap = s:Notifier.GetListenersMap()
  471                 0.001135000     return get(listenersMap, a:name, [])

FUNCTION  272()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:149
Called 2 times
Total time:   0.000029000
 Self time:   0.000009000

count     total (s)      self (s)
    2   0.000029000   0.000009000   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  <SNR>51_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:212
Called 13 times
Total time:   0.001488000
 Self time:   0.000119000

count     total (s)      self (s)
   13   0.001478000   0.000109000   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  277()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 176 times
Total time:   0.000733000
 Self time:   0.000733000

count     total (s)      self (s)
  176                 0.000615000   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  278()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:12
Called 44 times
Total time:   0.000615000
 Self time:   0.000428000

count     total (s)      self (s)
   44                 0.000186000   let spc = empty(a:contents) ? '' : g:airline_symbols.space
   44   0.000391000   0.000204000   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  279()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 875 times
Total time:   0.003258000
 Self time:   0.003258000

count     total (s)      self (s)
  875                 0.002942000   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>110_map_keys()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:195
Called 83 times
Total time:   0.022273000
 Self time:   0.022273000

count     total (s)      self (s)
   83                 0.000365000   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   83                 0.000097000   if bidx_mode > 0
   83                 0.000091000     if bidx_mode == 1
  913                 0.001086000       for i in range(1, 10)
  830                 0.015953000         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i%10, i-1)
  913                 0.000617000       endfor
                                      else
                                        let start_idx = bidx_mode == 2 ? 11 : 1
                                        for i in range(start_idx, 99)
                                          exe printf('noremap <silent> <Plug>AirlineSelectTab%02d :call <SID>select_tab(%d)<CR>', i, i-start_idx)
                                        endfor
   83                 0.000054000     endif
   83                 0.001271000     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   83                 0.001106000     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                      " Enable this for debugging
                                      " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
   83                 0.000072000   endif

FUNCTION  airline#extensions#fzf#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:37
Called 78 times
Total time:   0.001075000
 Self time:   0.001075000

count     total (s)      self (s)
   78                 0.000284000   if getbufvar(a:2.bufnr, '&filetype') ==# 'fzf'
                                      let spc = g:airline_symbols.space
                                      call a:1.add_section('airline_a', spc.'FZF'.spc)
                                      call a:1.add_section('airline_c', '')
                                      return 1
   78                 0.000048000   endif

FUNCTION  <SNR>56_get()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim:23
Called 924 times
Total time:   0.008555000
 Self time:   0.008555000

count     total (s)      self (s)
  924                 0.005603000   let options = deepcopy(eval('s:options.' . bufnr('%')))
  924                 0.000653000   if a:0
                                      return options[a:1]
  924                 0.000418000   endif
  924                 0.000614000   return options

FUNCTION  <SNR>55_option_init()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim:31
Called 621 times
Total time:   0.015815000
 Self time:   0.007603000

count     total (s)      self (s)
  621                 0.000964000   let opt_name = "delimitMate_" . a:name
                                    " Find value to use.
  621                 0.001640000   if !has_key(b:, opt_name) && !has_key(g:, opt_name)
  621                 0.000660000     let value = a:default
                                    elseif has_key(b:, opt_name)
                                      let value = b:[opt_name]
                                    else
                                      let value = g:[opt_name]
  621                 0.000234000   endif
  621   0.009680000   0.001468000   call s:set(a:name, value)

FUNCTION  <SNR>142_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:182
Called 33 times
Total time:   0.000061000
 Self time:   0.000061000

count     total (s)      self (s)
   33                 0.000043000     return a:path

FUNCTION  242()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:281
Called 41 times
Total time:   0.000103000
 Self time:   0.000103000

count     total (s)      self (s)
   41                 0.000078000     return self._showHelp

FUNCTION  <SNR>184_foldable()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/syntax/ruby.vim:40
Called 159 times
Total time:   0.000746000
 Self time:   0.000746000

count     total (s)      self (s)
  159                 0.000249000   if index(s:foldable_groups, 'NONE') > -1
                                      return 0
  159                 0.000063000   endif
                                  
  159                 0.000188000   if index(s:foldable_groups, 'ALL') > -1
  159                 0.000084000     return 1
                                    endif
                                  
                                    for l:i in a:000
                                      if index(s:foldable_groups, l:i) > -1
                                        return 1
                                      endif
                                    endfor
                                  
                                    return 0

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:205
Called 82 times
Total time:   0.030332000
 Self time:   0.003001000

count     total (s)      self (s)
   82                 0.000437000     if getbufvar(a:bufnr, '&modified')
                                        let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   82                 0.000050000     else
   82                 0.000979000       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   82                 0.000043000     endif
                                  
   82                 0.000139000     if !empty(colors)
   82   0.027969000   0.000638000       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   82                 0.000035000     endif

FUNCTION  <SNR>62_has_any()
    Defined: ~/.fzf/plugin/fzf.vim:293
Called 4 times
Total time:   0.000226000
 Self time:   0.000226000

count     total (s)      self (s)
   22                 0.000045000   for key in a:keys
   18                 0.000067000     if has_key(a:dict, key)
                                        return 1
   18                 0.000017000     endif
   22                 0.000025000   endfor
    4                 0.000006000   return 0

FUNCTION  go#config#HighlightOperators()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:414
Called 16 times
Total time:   0.000032000
 Self time:   0.000032000

count     total (s)      self (s)
   16                 0.000031000   return get(g:, 'go_highlight_operators', 0)

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:318
Called 257 times
Total time:   0.319391000
 Self time:   0.010763000

count     total (s)      self (s)
  257   0.300525000   0.001461000   let head = airline#extensions#branch#head()
  257   0.003070000   0.001682000   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
  257                 0.001193000   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  257   0.009611000   0.001435000   let head = airline#util#shorten(head, winwidth, minwidth)
  257                 0.001404000   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  257                 0.002833000   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  246()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:309
Called 895 times
Total time:   0.000990000
 Self time:   0.000990000

count     total (s)      self (s)
  895                 0.000742000     return 2

FUNCTION  281()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:25
Called 77 times
Total time:   0.000315000
 Self time:   0.000315000

count     total (s)      self (s)
   77                 0.000283000   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  283()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:33
Called 26 times
Total time:   0.000108000
 Self time:   0.000108000

count     total (s)      self (s)
   26                 0.000087000   return len(self._sections)

FUNCTION  284()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 202 times
Total time:   0.932872000
 Self time:   0.107163000

count     total (s)      self (s)
  202                 0.000315000   let side = 1
  202                 0.000221000   let line = ''
  202                 0.000204000   let i = 0
  202                 0.000525000   let length = len(self._sections)
  202                 0.000259000   let split = 0
  202                 0.000262000   let is_empty = 0
  202                 0.000255000   let prev_group = ''
                                  
 1457                 0.002003000   while i < length
 1255                 0.003021000     let section = self._sections[i]
 1255                 0.002278000     let group = section[0]
 1255                 0.002357000     let contents = section[1]
 1255                 0.001664000     let pgroup = prev_group
 1255   0.018305000   0.005054000     let prev_group = airline#builder#get_prev_group(self._sections, i)
 1255                 0.003046000     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                        let group = 'airline_term'
 1255                 0.003808000     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
   41                 0.000147000       let group = 'airline_c'. self._context.bufnr
 1214                 0.003636000     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
   41                 0.000089000       let prev_group = 'airline_c'. self._context.bufnr
 1255                 0.000710000     endif
 1255                 0.001074000     if is_empty
  182                 0.000231000       let prev_group = pgroup
 1255                 0.000652000     endif
 1255   0.160175000   0.005327000     let is_empty = s:section_is_empty(self, contents)
                                  
 1255                 0.001099000     if is_empty
                                        " need to fix highlighting groups, since we
                                        " have skipped a section, we actually need
                                        " the previous previous group and so the
                                        " separator goes from the previous previous group
                                        " to the current group
  250                 0.000292000       let pgroup = group
 1255                 0.000657000     endif
                                  
 1255                 0.001728000     if group == ''
                                        let line .= contents
 1255                 0.001631000     elseif group == '|'
  202                 0.000200000       let side = 0
  202                 0.000588000       let line .= contents
  202                 0.000318000       let split = 1
 1053                 0.000583000     else
 1053                 0.001262000       if prev_group == ''
  229                 0.000573000         let line .= '%#'.group.'#'
  824                 0.000667000       elseif split
  148                 0.000124000         if !is_empty
  137   0.100725000   0.000988000           let line .= s:get_transitioned_separator(self, prev_group, group, side)
  148                 0.000077000         endif
  148                 0.000173000         let split = 0
  676                 0.000366000       else
  676                 0.000578000         if !is_empty
  538   0.521437000   0.003442000           let line .= s:get_separator(self, prev_group, group, side)
  676                 0.000394000         endif
 1053                 0.000814000       endif
 1053   0.046612000   0.006734000       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
 1255                 0.000713000     endif
                                  
 1255                 0.001637000     let i = i + 1
 1457                 0.001301000   endwhile
                                  
  202                 0.000235000   if !self._context.active
                                      "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
   78                 0.003402000     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
  202                 0.000123000   endif
  202                 0.000240000   return line

FUNCTION  286()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:41
Called 77 times
Total time:   0.026095000
 Self time:   0.002737000

count     total (s)      self (s)
   77   0.007748000   0.000310000   let title = self.get_title(a:index)
   77   0.015924000   0.000319000   let title_size = s:tabline_evaluated_length(title) + a:sep_size
   77                 0.000142000   if a:force || self._remaining_space >= title_size
   77                 0.000095000     let pos = a:pos
   77                 0.000149000     if has_key(self, "get_pretitle")
                                        call self.insert_raw(self.get_pretitle(a:index), pos)
                                        let self._right_position += 1
                                        let pos += 1
   77                 0.000039000     endif
                                  
   77   0.000583000   0.000268000     call self.insert_section(a:group, title, pos)
   77                 0.000100000     let self._right_position += 1
   77                 0.000082000     let pos += 1
                                  
   77                 0.000136000     if has_key(self, "get_posttitle")
                                        call self.insert_raw(self.get_posttitle(a:index), pos)
                                        let self._right_position += 1
                                        let pos += 1
   77                 0.000041000     endif
                                  
   77                 0.000107000     let self._remaining_space -= title_size
   77                 0.000060000     return 1
                                    endif
                                    return 0

FUNCTION  <SNR>37_refreshCurrent()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:645
Called 20 times
Total time:   0.995962000
 Self time:   0.001160000

count     total (s)      self (s)
   20                 0.000044000     let node = a:node
   20                 0.000027000     if !node.path.isDirectory
                                          let node = node.parent
   20                 0.000016000     endif
                                  
   20   0.001623000   0.000164000     call nerdtree#echo('Refreshing node. This could take a while...')
   20   0.674682000   0.000551000     call node.refresh()
   20   0.106314000   0.000150000     call b:NERDTree.render()
   20   0.213134000   0.000086000     call nerdtree#echo('')

FUNCTION  airline#extensions#tabline#tabs#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/tabs.vim:24
Called 12 times
Total time:   0.000085000
 Self time:   0.000085000

count     total (s)      self (s)
   12                 0.000035000   if exists('#airline')
   12                 0.000023000     let s:current_bufnr = -1
   12                 0.000009000   endif

FUNCTION  <SNR>81_Highlight_Matching_Pair()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/plugin/matchparen.vim:44
Called 602 times
Total time:   0.091176000
 Self time:   0.080178000

count     total (s)      self (s)
  602                 0.002459000   if !exists("w:matchparen_ids")
   10                 0.000018000     let w:matchparen_ids = []
  602                 0.000442000   endif
                                    " Remove any previous match.
  602   0.012846000   0.002518000   call s:Remove_Matches()
                                  
                                    " Avoid that we remove the popup menu.
                                    " Return when there are no colors (looks like the cursor jumps).
  602                 0.004337000   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                      return
  602                 0.000339000   endif
                                  
                                    " Get the character under the cursor and check if it's in 'matchpairs'.
  602                 0.001885000   let c_lnum = line('.')
  602                 0.001867000   let c_col = col('.')
  602                 0.000782000   let before = 0
                                  
  602                 0.001929000   let text = getline(c_lnum)
  602                 0.014586000   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  602                 0.001742000   if empty(matches)
                                      let [c_before, c] = ['', '']
  602                 0.000671000   else
  602                 0.002804000     let [c_before, c] = matches[1:2]
  602                 0.000536000   endif
  602                 0.010128000   let plist = split(&matchpairs, '.\zs[:,]')
  602                 0.002306000   let i = index(plist, c)
  602                 0.000778000   if i < 0
                                      " not found, in Insert mode try character before the cursor
  593                 0.002608000     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    4                 0.000004000       let before = strlen(c_before)
    4                 0.000003000       let c = c_before
    4                 0.000005000       let i = index(plist, c)
  593                 0.000372000     endif
  593                 0.000681000     if i < 0
                                        " not found, nothing to do
  593                 0.000618000       return
                                      endif
    9                 0.000006000   endif
                                  
                                    " Figure out the arguments for searchpairpos().
    9                 0.000018000   if i % 2 == 0
                                      let s_flags = 'nW'
                                      let c2 = plist[i + 1]
    9                 0.000004000   else
    9                 0.000015000     let s_flags = 'nbW'
    9                 0.000014000     let c2 = c
    9                 0.000021000     let c = plist[i - 1]
    9                 0.000007000   endif
    9                 0.000012000   if c == '['
                                      let c = '\['
                                      let c2 = '\]'
    9                 0.000009000   endif
                                  
                                    " Find the match.  When it was just before the cursor move it there for a
                                    " moment.
    9                 0.000010000   if before > 0
                                      let has_getcurpos = exists("*getcurpos")
                                      if has_getcurpos
                                        " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                        let save_cursor = getcurpos()
                                      else
                                        let save_cursor = winsaveview()
                                      endif
                                      call cursor(c_lnum, c_col - before)
    9                 0.000004000   endif
                                  
    9                 0.000065000   if !has("syntax") || !exists("g:syntax_on")
                                      let s_skip = "0"
    9                 0.000008000   else
                                      " Build an expression that detects whether the current cursor position is
                                      " in certain syntax types (string, comment, etc.), for use as
                                      " searchpairpos()'s skip argument.
                                      " We match "escape" for special items, such as lispEscapeSpecial, and
                                      " match "symbol" for lispBarSymbol.
    9                 0.000046000     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                      " If executing the expression determines that the cursor is currently in
                                      " one of the syntax types, then we want searchpairpos() to find the pair
                                      " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                      " outside of the syntax types and s_skip should keep its value so we skip
                                      " any matching pair inside the syntax types.
                                      " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    9                 0.000010000     try
    9   0.007446000   0.007265000       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                      catch /^Vim\%((\a\+)\)\=:E363/
                                        " We won't find anything, so skip searching, should keep Vim responsive.
                                        return
    9                 0.000012000     endtry
    9                 0.000008000   endif
                                  
                                    " Limit the search to lines visible in the window.
    9                 0.000056000   let stoplinebottom = line('w$')
    9                 0.000023000   let stoplinetop = line('w0')
    9                 0.000018000   if i % 2 == 0
                                      let stopline = stoplinebottom
    9                 0.000003000   else
    9                 0.000019000     let stopline = stoplinetop
    9                 0.000007000   endif
                                  
                                    " Limit the search time to 300 msec to avoid a hang on very long lines.
                                    " This fails when a timeout is not supported.
    9                 0.000029000   if mode() == 'i' || mode() == 'R'
                                      let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    9                 0.000007000   else
    9                 0.000042000     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    9                 0.000008000   endif
    9                 0.000013000   try
    9   0.005557000   0.005068000     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                                    catch /E118/
                                      " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                      " a long time on closed folds and long lines.
                                      " The "viewable" variables give a range in which we can scroll while
                                      " keeping the cursor at the same position.
                                      " adjustedScrolloff accounts for very large numbers of scrolloff.
                                      let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                      let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                      let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                      " one of these stoplines will be adjusted below, but the current values are
                                      " minimal boundaries within the current window
                                      if i % 2 == 0
                                        if has("byte_offset") && has("syntax_items") && &smc > 0
                                  	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                                  	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                        else
                                  	let stopline = min([bottom_viewable, c_lnum + 100])
                                        endif
                                        let stoplinebottom = stopline
                                      else
                                        if has("byte_offset") && has("syntax_items") && &smc > 0
                                  	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                                  	let stopline = max([top_viewable, byte2line(stopbyte)])
                                        else
                                  	let stopline = max([top_viewable, c_lnum - 100])
                                        endif
                                        let stoplinetop = stopline
                                      endif
                                      let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    9                 0.000010000   endtry
                                  
    9                 0.000011000   if before > 0
                                      if has_getcurpos
                                        call setpos('.', save_cursor)
                                      else
                                        call winrestview(save_cursor)
                                      endif
    9                 0.000007000   endif
                                  
                                    " If a match is found setup match highlighting.
    9                 0.000026000   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    9                 0.000012000     if s:has_matchaddpos
    9                 0.000445000       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                      else
                                        exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                        call add(w:matchparen_ids, 3)
    9                 0.000007000     endif
    9                 0.000024000     let w:paren_hl_on = 1
    9                 0.000006000   endif

FUNCTION  <SNR>192_ansi()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:303
Called 5 times
Total time:   0.000935000
 Self time:   0.000195000

count     total (s)      self (s)
    5   0.000397000   0.000047000   let fg = s:get_color('fg', a:group)
    5   0.000329000   0.000034000   let bg = s:get_color('bg', a:group)
    5   0.000166000   0.000071000   let color = (empty(fg) ? s:ansi[a:default] : s:csi(fg, 1)) . (empty(bg) ? '' : ';'.s:csi(bg, 0))
    5                 0.000039000   return printf("\x1b[%s%sm%s\x1b[m", color, a:0 ? ';1' : '', a:str)

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:410
Called 38 times
Total time:   2.176805000
 Self time:   0.000536000

count     total (s)      self (s)
   38   2.176756000   0.000487000     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:109
Called 299 times
Total time:   0.070208000
 Self time:   0.031714000

count     total (s)      self (s)
  299                 0.001150000   if !get(w:, 'airline_active', 0)
                                      return ''
  299                 0.000175000   endif
                                    " Cache values, so that it isn't called too often
  299   0.010685000   0.006983000   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitsigns' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                      return b:airline_hunks
  299                 0.000224000   endif
  299   0.026081000   0.001376000   let hunks = airline#extensions#hunks#get_raw_hunks()
  299                 0.000402000   let string = ''
  299   0.003306000   0.001849000   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  299                 0.000574000   if !empty(hunks)
                                      " hunks should contain [added, changed, deleted]
  672                 0.000965000     for i in [0, 1, 2]
  504   0.006668000   0.002153000       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  504                 0.002858000         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  504                 0.000293000       endif
  672                 0.000481000     endfor
  299                 0.000168000   endif
  299   0.003645000   0.002569000   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                      " branch extension not loaded, skip trailing whitespace
                                      let string = string[0:-2]
  299                 0.000185000   endif
                                  
  299                 0.000699000   let b:airline_hunks = string
  299                 0.000705000   let b:airline_changenr = b:changedtick
  299   0.004083000   0.001044000   let s:airline_winwidth = airline#util#winwidth()
  299                 0.000321000   return string

FUNCTION  <SNR>104_check_mixed_indent_file()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:34
Called 15 times
Total time:   0.000577000
 Self time:   0.000577000

count     total (s)      self (s)
   15                 0.000081000   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
   15                 0.000031000   if index(c_like_langs, &ft) > -1
                                      " for C-like languages: allow /** */ comment style with one space before the '*'
    9                 0.000010000     let head_spc = '\v(^ +\*@!)'
    6                 0.000002000   else
    6                 0.000008000     let head_spc = '\v(^ +)'
   15                 0.000004000   endif
   15                 0.000099000   let indent_tabs = search('\v(^\t+)', 'nw')
   15                 0.000246000   let indent_spc  = search(head_spc, 'nw')
   15                 0.000019000   if indent_tabs > 0 && indent_spc > 0
                                      return printf("%d:%d", indent_tabs, indent_spc)
   15                 0.000005000   else
   15                 0.000011000     return ''
                                    endif

FUNCTION  <SNR>101_display_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:121
Called 27 times
Total time:   0.001849000
 Self time:   0.001319000

count     total (s)      self (s)
   27                 0.000054000   let name = b:buffer_vcs_config['git'].branch
   27                 0.000024000   try
   27   0.000832000   0.000302000     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                                  
   27                 0.000062000     if has_key(s:names, commit)
                                        let name = get(s:names, commit)."(".name.")"
   27                 0.000041000     elseif !empty(commit)
                                        if exists('*FugitiveExecute')
                                          let ref = FugitiveExecute(['describe', '--all', '--exact-match', commit], bufnr('')).stdout[0]
                                        else
                                          noautocmd let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                          if ref =~# ':'
                                            let ref = ''
                                          endif
                                        endif
                                        if !empty(ref)
                                          let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                        else
                                          let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                        endif
   27                 0.000014000     endif
                                    catch
   27                 0.000021000   endtry
   27                 0.000025000   return name

FUNCTION  <SNR>192_escape_for_bash()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:78
Called 1 time
Total time:   0.000094000
 Self time:   0.000014000

count     total (s)      self (s)
    1                 0.000002000   if !s:is_win
    1   0.000092000   0.000012000     return fzf#shellescape(a:path)
                                    endif
                                  
                                    if !exists('s:is_linux_like_bash')
                                      call system(s:bash . ' -c "ls /mnt/[A-Za-z]"')
                                      let s:is_linux_like_bash = v:shell_error == 0
                                    endif
                                  
                                    let path = substitute(a:path, '\', '/', 'g')
                                    if s:is_linux_like_bash
                                      let path = substitute(path, '^\([A-Z]\):', '/mnt/\L\1', '')
                                    endif
                                  
                                    return escape(path, ' ')

FUNCTION  go#config#HighlightChanWhitespaceError()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:398
Called 16 times
Total time:   0.000035000
 Self time:   0.000035000

count     total (s)      self (s)
   16                 0.000031000   return get(g:, 'go_highlight_chan_whitespace_error', 0)

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 72 times
Total time:   0.000638000
 Self time:   0.000638000

count     total (s)      self (s)
   72                 0.000107000   if &filetype ==# 'fzf'
                                      let spc = g:airline_symbols.space
                                      call a:1.add_section('airline_a', spc.'FZF'.spc)
                                      call a:1.add_section('airline_c', '')
                                      return 1
   72                 0.000036000   endif

FUNCTION  298()
    Defined: ~/.vim/plugged/vim-go/autoload/go/lsp.vim:82
Called 6 times
Total time:   0.002333000
 Self time:   0.001970000

count     total (s)      self (s)
    6                 0.000058000     let l:responses = []
    6                 0.000021000     let l:rest = a:data
                                  
   12                 0.000063000     while 1
                                        " Look for the end of the HTTP headers
   12                 0.000205000       let l:body_start_idx = matchend(l:rest, "\r\n\r\n")
                                  
   12                 0.000046000       if l:body_start_idx < 0
                                          " incomplete header
    6                 0.000007000         break
    6                 0.000009000       endif
                                  
                                        " Parse the Content-Length header.
    6                 0.000106000       let l:header = l:rest[:l:body_start_idx - 4]
    6                 0.000203000       let l:length_match = matchlist(   l:header,   '\vContent-Length: *(\d+)')
                                  
    6                 0.000033000       if empty(l:length_match)
                                          " TODO(bc): shutdown gopls?
                                          throw "invalid JSON-RPC header:\n" . l:header
    6                 0.000008000       endif
                                  
                                        " get the start of the rest
    6                 0.000062000       let l:next_start_idx = l:body_start_idx + str2nr(l:length_match[1])
                                  
    6                 0.000034000       if len(l:rest) < l:next_start_idx
                                          " incomplete response body
                                          break
    6                 0.000007000       endif
                                  
    6   0.000489000   0.000126000       call s:debug('received', l:rest[:l:next_start_idx - 1])
                                  
    6                 0.000053000       let l:body = l:rest[l:body_start_idx : l:next_start_idx - 1]
    6                 0.000034000       let l:rest = l:rest[l:next_start_idx :]
                                  
    6                 0.000008000       try
                                          " add the json body to the list.
    6                 0.000259000         call add(l:responses, json_decode(l:body))
                                        catch
                                          " TODO(bc): log the message and/or show an error message.
    6                 0.000016000       finally
                                          " intentionally left blank.
    6                 0.000013000       endtry
   12                 0.000039000     endwhile
                                  
    6                 0.000021000     return [l:rest, l:responses]

FUNCTION  go#config#HighlightDebug()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:471
Called 16 times
Total time:   0.000036000
 Self time:   0.000036000

count     total (s)      self (s)
   16                 0.000031000   return get(g:, 'go_highlight_debug', 1)

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:30
Called 588 times
Total time:   0.008520000
 Self time:   0.008520000

count     total (s)      self (s)
  588                 0.001172000   let buffer = +a:buffer
  588                 0.002048000   let ggvars = getbufvar(buffer, 'gitgutter')
  588                 0.003034000   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
  434                 0.000771000     return ggvars[a:varname]
  154                 0.000098000   endif
  154                 0.000156000   if a:0
  152                 0.000163000     return a:1
    2                 0.000002000   endif

FUNCTION  <SNR>172_is_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 44 times
Total time:   0.000078000
 Self time:   0.000078000

count     total (s)      self (s)
   44                 0.000071000   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  FugitiveParse()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:89
Called 27 times
Total time:   0.000530000
 Self time:   0.000496000

count     total (s)      self (s)
   27   0.000197000   0.000163000   let path = s:Slash(a:0 ? a:1 : @%)
   27                 0.000179000   if path !~# '^fugitive://'
   27                 0.000034000     return ['', '']
                                    endif
                                    let [rev, dir] = fugitive#Parse(path)
                                    if !empty(dir)
                                      return [rev, dir]
                                    endif
                                    throw 'fugitive: invalid Fugitive URL ' . path

FUNCTION  ale#events#InsertLeaveEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:128
Called 2 times
Total time:   0.000668000
 Self time:   0.000134000

count     total (s)      self (s)
    2   0.000131000   0.000022000     if ale#Var(a:buffer, 'lint_on_insert_leave')
                                          " Kill the InsertLeave emulation if the event fired.
    2                 0.000031000         call timer_stop(s:insert_leave_timer)
    2   0.000308000   0.000014000         call ale#Queue(0)
    2                 0.000002000     endif
                                  
                                      " Look for a warning to echo as soon as we leave Insert mode.
                                      " The script's position variable used when moving the cursor will
                                      " not be changed here.
                                      "
                                      " We don't echo this message in emulated insert leave mode, as the user
                                      " may want less work to happen on pressing <C-c> versus <Esc>
    2                 0.000010000     if exists('*ale#engine#Cleanup')
    2   0.000147000   0.000016000         call ale#cursor#EchoCursorWarning()
                                  
    2                 0.000011000         if g:ale_virtualtext_cursor is# 'current' || g:ale_virtualtext_cursor is# 1 || g:ale_virtualtext_cursor is# '1'
                                              " Show a virtualtext message if enabled.
                                              call ale#virtualtext#ShowCursorWarning()
    2                 0.000002000         endif
    2                 0.000002000     endif

FUNCTION  <SNR>37_initCustomOpenArgs()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:113
Called 10 times
Total time:   0.000517000
 Self time:   0.000470000

count     total (s)      self (s)
   10   0.000202000   0.000155000     let l:defaultOpenArgs = {'file': {'reuse': 'all', 'where': 'p', 'keepopen':!nerdtree#closeTreeOnOpen()}, 'dir': {}}
   10                 0.000010000     try
   10                 0.000063000         let g:NERDTreeCustomOpenArgs = get(g:, 'NERDTreeCustomOpenArgs', {})
   10                 0.000067000         call  extend(g:NERDTreeCustomOpenArgs, l:defaultOpenArgs, 'keep')
                                      catch /^Vim(\a\+):E712:/
                                          call nerdtree#echoWarning('g:NERDTreeCustomOpenArgs is not set properly. Using default value.')
                                          let g:NERDTreeCustomOpenArgs = l:defaultOpenArgs
   10                 0.000025000     finally
   10                 0.000018000         return g:NERDTreeCustomOpenArgs
                                      endtry

FUNCTION  <SNR>90_ResetConcealOption()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:115
Called 10 times
Total time:   0.000113000
 Self time:   0.000113000

count     total (s)      self (s)
   10                 0.000032000     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                          if exists("b:indentLine_original_concealcursor")
                                              let &l:concealcursor = b:indentLine_original_concealcursor
                                          endif
                                          if exists("b:indentLine_original_conceallevel")
                                              let &l:conceallevel = b:indentLine_original_conceallevel
                                          endif
                                          let b:indentLine_ConcealOptionSet = 0
   10                 0.000002000     endif

FUNCTION  go#config#HighlightFields()
    Defined: ~/.vim/plugged/vim-go/autoload/go/config.vim:431
Called 16 times
Total time:   0.000032000
 Self time:   0.000032000

count     total (s)      self (s)
   16                 0.000028000   return get(g:, 'go_highlight_fields', 0)

FUNCTION  <SNR>114_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 2334 times
Total time:   1.208173000
 Self time:   0.062064000

count     total (s)      self (s)
 2334                 0.003013000     if pumvisible()
                                        return
 2334                 0.000978000     endif
 2334                 0.005166000     let group = a:from.'_to_'.a:to.a:suffix
 2334   0.332470000   0.008250000     let l:from = airline#themes#get_highlight(a:from.a:suffix)
 2334   0.325855000   0.007436000     let l:to = airline#themes#get_highlight(a:to.a:suffix)
 2334                 0.001888000     if a:inverse
  861                 0.003630000       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
 1473                 0.000641000     else
 1473                 0.005409000       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
 2334                 0.000998000     endif
 2334                 0.006285000     let a:dict[group] = colors
 2334   0.511567000   0.008097000     call airline#highlighter#exec(group, colors)

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:64
Called 32 times
Total time:   0.005846000
 Self time:   0.005846000

count     total (s)      self (s)
   32                 0.005815000     let s:hl_groups = {}

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:65
Called 2772 times
Total time:   0.021156000
 Self time:   0.021156000

count     total (s)      self (s)
 2772                 0.006919000   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                      return ''
 2772                 0.001717000   endif
 2772                 0.008380000   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  140()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:147
Called 769 times
Total time:   0.226043000
 Self time:   0.004673000

count     total (s)      self (s)
  769   0.218676000   0.001363000     if !self.isCascadable()
  765                 0.000551000         return [self]
    4                 0.000002000     endif
                                  
    4   0.002077000   0.000008000     let vc = self.getVisibleChildren()
    4                 0.000006000     let visChild = vc[0]
                                  
    4                 0.000008000     return [self] + visChild.getCascade()

FUNCTION  <SNR>113_wrap_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:9
Called 31 times
Total time:   0.000629000
 Self time:   0.000475000

count     total (s)      self (s)
   31                 0.000104000   if exists('a:part.accent')
   31   0.000350000   0.000196000     call airline#highlighter#add_accent(a:part.accent)
   31                 0.000122000     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                                    endif
                                    return a:value

FUNCTION  airline#util#has_vcscommand()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:167
Called 3 times
Total time:   0.000029000
 Self time:   0.000029000

count     total (s)      self (s)
    3                 0.000010000   if !exists("s:has_vcscommand")
    1                 0.000003000     let s:has_vcscommand = exists('*VCSCommandGetStatusLine')
    3                 0.000003000   endif
    3                 0.000009000   return get(g:, 'airline#extensions#branch#use_vcscommand', 0) && s:has_vcscommand

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:117
Called 414 times
Total time:   0.049380000
 Self time:   0.034102000

count     total (s)      self (s)
  414                 0.004448000     let l:buffer = bufnr('')
                                  
  414                 0.001223000     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                          return
  414                 0.000302000     endif
                                  
                                      " Only echo the warnings in normal mode, otherwise we will get problems.
  414                 0.001754000     if mode(1) isnot# 'n'
    2                 0.000001000         return
  412                 0.000254000     endif
                                  
  412   0.007256000   0.002625000     call s:StopCursorTimer()
                                  
  412                 0.005177000     let l:pos = getpos('.')[0:2]
                                  
  412                 0.001370000     if !exists('w:last_pos')
    8                 0.000010000         let w:last_pos = [0, 0, 0]
  412                 0.000277000     endif
                                  
                                      " Check the current buffer, line, and column number against the last
                                      " recorded position. If the position has actually changed, *then*
                                      " we should echo something. Otherwise we can end up doing processing
                                      " the echo message far too frequently.
  412                 0.001378000     if l:pos != w:last_pos
  364   0.013486000   0.002839000         let l:delay = ale#Var(l:buffer, 'echo_delay')
                                  
  364                 0.001069000         let w:last_pos = l:pos
  364                 0.002913000         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
  412                 0.000313000     endif

FUNCTION  <SNR>44_init()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:15
Called 42 times
Total time:   0.000241000
 Self time:   0.000241000

count     total (s)      self (s)
   42                 0.000079000   if s:airline_initialized
   42                 0.000036000     return
                                    endif
                                    let s:airline_initialized = 1
                                  
                                    call airline#extensions#load()
                                    call airline#init#sections()
                                  
                                    let s:theme_in_vimrc = exists('g:airline_theme')
                                    if s:theme_in_vimrc
                                      try
                                        if g:airline_theme is# 'random'
                                          let g:airline_theme=s:random_theme()
                                        endif
                                        let palette = g:airline#themes#{g:airline_theme}#palette
                                      catch
                                        call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                        let g:airline_theme = 'dark'
                                      endtry
                                      try
                                        silent call airline#switch_theme(g:airline_theme)
                                      catch
                                        call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                        let g:airline_theme = 'dark'
                                        silent call airline#switch_theme(g:airline_theme)
                                      endtry
                                    else
                                      let g:airline_theme = 'dark'
                                      silent call s:on_colorscheme_changed()
                                    endif
                                  
                                    call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  airline#extensions#tabline#add_tab_label()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:37
Called 26 times
Total time:   0.000591000
 Self time:   0.000534000

count     total (s)      self (s)
   26                 0.000110000   let show_tab_count = get(g:, 'airline#extensions#tabline#show_tab_count', 1)
   26                 0.000039000   if show_tab_count == 2
                                      call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
   26                 0.000076000   elseif show_tab_count == 1 && tabpagenr('$') > 1
    5   0.000097000   0.000040000     call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
   26                 0.000016000   endif

FUNCTION  <SNR>101_init_buffer()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:51
Called 6 times
Total time:   0.000132000
 Self time:   0.000132000

count     total (s)      self (s)
    6                 0.000011000   let b:buffer_vcs_config = {}
   18                 0.000031000   for vcs in keys(s:vcs_config)
   12                 0.000047000     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',     'dirty': 0,   }
   18                 0.000013000   endfor
    6                 0.000007000   unlet! b:airline_head

FUNCTION  airline#util#getbufvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:73
Called 226 times
Total time:   0.000799000
 Self time:   0.000799000

count     total (s)      self (s)
  226                 0.000721000     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  <SNR>55_init()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim:44
Called 27 times
Total time:   0.026281000
 Self time:   0.006320000

count     total (s)      self (s)
                                  " Initialize variables:
                                    " autoclose
   27   0.001120000   0.000095000   call s:option_init("autoclose", 1)
                                    " matchpairs
   27   0.000882000   0.000165000   call s:option_init("matchpairs", string(&matchpairs)[1:-2])
   27   0.001957000   0.000739000   call s:option_init("matchpairs_list", map(split(s:get('matchpairs', ''), '.:.\zs,\ze.:.'), 'split(v:val, ''^.\zs:\ze.$'')'))
   27   0.000600000   0.000106000   let pairs = s:get('matchpairs_list', [])
   27                 0.000223000   if len(filter(pairs, 'v:val[0] ==# v:val[1]'))
                                      echohl ErrorMsg
                                      echom 'delimitMate: each member of a pair in delimitMate_matchpairs must be different from each other.'
                                      echom 'delimitMate: invalid pairs: ' . join(map(pairs, 'join(v:val, ":")'), ', ')
                                      echohl Normal
                                      return 0
   27                 0.000013000   endif
   27   0.001400000   0.000282000   call s:option_init("left_delims", map(copy(s:get('matchpairs_list', [])), 'v:val[0]'))
   27   0.001357000   0.000250000   call s:option_init("right_delims", map(copy(s:get('matchpairs_list', [])), 'v:val[1]'))
                                    " quotes
   27   0.000735000   0.000072000   call s:option_init("quotes", "\" ' `")
   27   0.001331000   0.000262000   call s:option_init("quotes_list",split(s:get('quotes', ''), '\s\+'))
                                    " nesting_quotes
   27   0.000717000   0.000062000   call s:option_init("nesting_quotes", [])
                                    " excluded_regions
   27   0.000724000   0.000069000   call s:option_init("excluded_regions", "Comment")
   27   0.001380000   0.000211000   call s:option_init("excluded_regions_list", split(s:get('excluded_regions', ''), ',\s*'))
   27   0.000628000   0.000145000   let enabled = len(s:get('excluded_regions_list', [])) > 0
   27   0.000742000   0.000075000   call s:option_init("excluded_regions_enabled", enabled)
                                    " expand_space
   27                 0.000097000   if exists("b:delimitMate_expand_space") && type(b:delimitMate_expand_space) == type("")
                                      echom "b:delimitMate_expand_space is '".b:delimitMate_expand_space."' but it must be either 1 or 0!"
                                      echom "Read :help 'delimitMate_expand_space' for more details."
                                      unlet b:delimitMate_expand_space
                                      let b:delimitMate_expand_space = 1
   27                 0.000011000   endif
   27                 0.000088000   if exists("g:delimitMate_expand_space") && type(g:delimitMate_expand_space) == type("")
                                      echom "delimitMate_expand_space is '".g:delimitMate_expand_space."' but it must be either 1 or 0!"
                                      echom "Read :help 'delimitMate_expand_space' for more details."
                                      unlet g:delimitMate_expand_space
                                      let g:delimitMate_expand_space = 1
   27                 0.000010000   endif
   27   0.000748000   0.000062000   call s:option_init("expand_space", 0)
                                    " expand_cr
   27                 0.000091000   if exists("b:delimitMate_expand_cr") && type(b:delimitMate_expand_cr) == type("")
                                      echom "b:delimitMate_expand_cr is '".b:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                      echom "Read :help 'delimitMate_expand_cr' for more details."
                                      unlet b:delimitMate_expand_cr
                                      let b:delimitMate_expand_cr = 1
   27                 0.000014000   endif
   27                 0.000074000   if exists("g:delimitMate_expand_cr") && type(g:delimitMate_expand_cr) == type("")
                                      echom "delimitMate_expand_cr is '".g:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                      echom "Read :help 'delimitMate_expand_cr' for more details."
                                      unlet g:delimitMate_expand_cr
                                      let g:delimitMate_expand_cr = 1
   27                 0.000011000   endif
   27                 0.000207000   if ((&backspace !~ 'eol' || &backspace !~ 'start') && &backspace != 2) && ((exists('b:delimitMate_expand_cr') && b:delimitMate_expand_cr == 1) || (exists('g:delimitMate_expand_cr') && g:delimitMate_expand_cr == 1))
                                      echom "delimitMate: There seems to be some incompatibility with your settings that may interfer with the expansion of <CR>. See :help 'delimitMate_expand_cr' for details."
   27                 0.000008000   endif
   27   0.000750000   0.000072000   call s:option_init("expand_cr", 0)
                                    " expand_in_quotes
   27   0.000700000   0.000063000   call s:option_init('expand_inside_quotes', 0)
                                    " jump_expansion
   27   0.000847000   0.000066000   call s:option_init("jump_expansion", 0)
                                    " smart_matchpairs
   27   0.000791000   0.000089000   call s:option_init("smart_matchpairs", '^\%(\w\|\!\|[£$]\|[^[:punct:][:space:]]\)')
                                    " smart_quotes
                                    " XXX: backward compatibility. Ugly, should go the way of the dodo soon.
   27   0.000681000   0.000223000   let quotes = escape(join(s:get('quotes_list', []), ''), '\-^[]')
   27                 0.000104000   let default_smart_quotes = '\%(\w\|[^[:punct:][:space:]' . quotes . ']\|\%(\\\\\)*\\\)\%#\|\%#\%(\w\|[^[:space:][:punct:]' . quotes . ']\)'
   27                 0.000084000   if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) == type(0)
                                      if g:delimitMate_smart_quotes
                                        unlet g:delimitMate_smart_quotes
                                      else
                                        unlet g:delimitMate_smart_quotes
                                        let g:delimitMate_smart_quotes = ''
                                      endif
   27                 0.000011000   endif
   27                 0.000079000   if exists('b:delimitMate_smart_quotes') && type(b:delimitMate_smart_quotes) == type(0)
                                      if b:delimitMate_smart_quotes
                                        unlet b:delimitMate_smart_quotes
                                        if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) && g:delimitMate_smart_quotes
                                          let b:delimitMate_smart_quotes = default_smart_quotes
                                        endif
                                      else
                                        unlet b:delimitMate_smart_quotes
                                        let b:delimitMate_smart_quotes = ''
                                      endif
   27                 0.000007000   endif
   27   0.000737000   0.000079000   call s:option_init("smart_quotes", default_smart_quotes)
                                    " apostrophes
   27   0.000706000   0.000066000   call s:option_init("apostrophes", "")
   27   0.001326000   0.000225000   call s:option_init("apostrophes_list", split(s:get('apostrophes', ''), ":\s*"))
                                    " tab2exit
   27   0.000693000   0.000060000   call s:option_init("tab2exit", 1)
                                    " balance_matchpairs
   27   0.000724000   0.000064000   call s:option_init("balance_matchpairs", 0)
                                    " eol marker
   27   0.000714000   0.000074000   call s:option_init("insert_eol_marker", 1)
   27   0.000709000   0.000062000   call s:option_init("eol_marker", "")
                                    " Everything is fine.
   27                 0.000021000   return 1

FUNCTION  <SNR>142_GitDir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:569
Called 18 times
Total time:   0.000658000
 Self time:   0.000075000

count     total (s)      self (s)
   18   0.000657000   0.000074000   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  go#util#IsWin()
    Defined: ~/.vim/plugged/vim-go/autoload/go/util.vim:40
Called 95 times
Total time:   0.000641000
 Self time:   0.000641000

count     total (s)      self (s)
   95                 0.000548000   return has('win32')

FUNCTION  delimitMate#Set()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim:258
Called 621 times
Total time:   0.006207000
 Self time:   0.001712000

count     total (s)      self (s)
  621   0.006069000   0.001574000   return call('s:set', a:000)

FUNCTION  <SNR>62_get_version()
    Defined: ~/.fzf/plugin/fzf.vim:170
Called 6 times
Total time:   0.369552000
 Self time:   0.001686000

count     total (s)      self (s)
    6                 0.000033000   if has_key(s:versions, a:bin)
    4                 0.000007000     return s:versions[a:bin]
    2                 0.000002000   end
    2   0.000085000   0.000060000   let command = (&shell =~ 'powershell\|pwsh' ? '&' : '') . s:fzf_call('shellescape', a:bin) . ' --version --no-height'
    2   0.369121000   0.001280000   let output = systemlist(command)
    2                 0.000056000   if v:shell_error || empty(output)
                                      return ''
    2                 0.000006000   endif
    2                 0.000140000   let ver = matchstr(output[-1], '[0-9.]\+')
    2                 0.000045000   let s:versions[a:bin] = ver
    2                 0.000006000   return ver

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 11 times
Total time:   0.000411000
 Self time:   0.000092000

count     total (s)      self (s)
   11   0.000230000   0.000048000   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
   11   0.000169000   0.000032000   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>62_collect()
    Defined: ~/.fzf/plugin/fzf.vim:965
Called 2 times
Total time:   0.000968000
 Self time:   0.000968000

count     total (s)      self (s)
    2                 0.000002000   try
    2                 0.000291000     return filereadable(a:temps.result) ? readfile(a:temps.result) : []
    2                 0.000005000   finally
    5                 0.000014000     for tf in values(a:temps)
    3                 0.000641000       silent! call delete(tf)
    5                 0.000006000     endfor
    2                 0.000002000   endtry

FUNCTION  fzf#run()
    Defined: ~/.fzf/plugin/fzf.vim:490
Called 2 times
Total time:   0.163150000
 Self time:   0.000772000

count     total (s)      self (s)
    2                 0.000004000 try
    2   0.000123000   0.000025000   let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()
                                  
    2                 0.000021000   let dict   = exists('a:1') ? copy(a:1) : {}
    2   0.000077000   0.000028000   let temps  = { 'result': s:fzf_tempname() }
    2   0.000047000   0.000022000   let optstr = s:evaluate_opts(get(dict, 'options', ''))
    2                 0.000003000   try
    2   0.000239000   0.000024000     let fzf_exec = shellescape(fzf#exec())
                                    catch
                                      throw v:exception
    2                 0.000003000   endtry
                                  
    2   0.000092000   0.000030000   if !s:present(dict, 'dir')
    2   0.000396000   0.000020000     let dict.dir = s:fzf_getcwd()
    2                 0.000004000   endif
    2                 0.000016000   if has('win32unix') && s:present(dict, 'dir')
                                      let dict.dir = fnamemodify(dict.dir, ':p')
    2                 0.000003000   endif
                                  
    2                 0.000007000   if has_key(dict, 'source')
    1                 0.000001000     let source = dict.source
    1                 0.000003000     let type = type(source)
    1                 0.000001000     if type == 1
                                        let prefix = '('.source.')|'
    1                 0.000001000     elseif type == 3
    1   0.000012000   0.000004000       let temps.input = s:fzf_tempname()
    1   0.004352000   0.000012000       call s:writefile(source, temps.input)
    1   0.000072000   0.000016000       let prefix = (s:is_win ? 'type ' : 'command cat ').fzf#shellescape(temps.input).'|'
                                      else
                                        throw 'Invalid source type'
    1                 0.000001000     endif
    1                 0.000002000   else
    1                 0.000003000     let prefix = ''
    2                 0.000001000   endif
                                  
    2                 0.000017000   let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0) || has_key(dict, 'tmux')
    2                 0.000050000   let use_height = has_key(dict, 'down') && !has('gui_running') && !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) && executable('tput') && filereadable('/dev/tty')
    2                 0.000025000   let has_vim8_term = has('terminal') && has('patch-8.0.995')
    2                 0.000023000   let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
    2   0.000157000   0.000041000   let use_term = has_nvim_term || has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || s:present(dict, 'down', 'up', 'left', 'right', 'window'))
    2                 0.000034000   let use_tmux = (has_key(dict, 'tmux') || (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:splittable(dict)) && s:tmux_enabled()
    2                 0.000004000   if prefer_tmux && use_tmux
                                      let use_height = 0
                                      let use_term = 0
    2                 0.000002000   endif
    2                 0.000004000   if use_term
    2                 0.000013000     let optstr .= ' --no-height'
                                    elseif use_height
                                      let height = s:calc_size(&lines, dict.down, dict)
                                      let optstr .= ' --height='.height
    2                 0.000001000   endif
                                    " Respect --border option given in $FZF_DEFAULT_OPTS and 'options'
    2   0.000615000   0.000086000   let optstr = join([s:border_opt(get(dict, 'window', 0)), s:extract_option($FZF_DEFAULT_OPTS, 'border'), optstr])
    2                 0.000026000   let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                                  
    2                 0.000004000   if use_term
    2   0.156520000   0.000025000     return s:execute_term(dict, command, temps)
                                    endif
                                  
                                    let lines = use_tmux ? s:execute_tmux(dict, command, temps) : s:execute(dict, command, use_height, temps)
                                    call s:callback(dict, lines)
                                    return lines
    2                 0.000001000 finally
    2   0.000024000   0.000015000   let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
    2                 0.000002000 endtry

FUNCTION  <SNR>90_InitColor()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:40
Called 38 times
Total time:   0.003114000
 Self time:   0.003114000

count     total (s)      self (s)
   38                 0.000065000     if !g:indentLine_setColors
                                          return
   38                 0.000016000     endif
                                  
   38                 0.000059000     let default_term_bg = "NONE"
   38                 0.000045000     let default_gui_bg  = "NONE"
   38                 0.000047000     if &background ==# "light"
                                          let default_term_fg = 249
                                          let default_gui_fg = "Grey70"
   38                 0.000019000     else
   38                 0.000040000         let default_term_fg = 239
   38                 0.000037000         let default_gui_fg = "Grey30"
   38                 0.000023000     endif
                                  
   38                 0.000045000     if g:indentLine_defaultGroup != ""
                                          let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                          let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
                                          let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
                                          let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                          let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
   38                 0.000023000     endif
                                  
   38                 0.000073000     if !exists("g:indentLine_color_term")
                                          let term_color = default_term_fg
   38                 0.000012000     else
   38                 0.000056000         let term_color = g:indentLine_color_term
   38                 0.000012000     endif
                                  
   38                 0.000068000     if !exists("g:indentLine_bgcolor_term")
   38                 0.000046000         let term_bgcolor = default_term_bg
                                      else
                                          let term_bgcolor = g:indentLine_bgcolor_term
   38                 0.000016000     endif
                                  
   38                 0.000067000     if !exists("g:indentLine_color_gui")
                                          let gui_color = default_gui_fg
   38                 0.000019000     else
   38                 0.000044000         let gui_color = g:indentLine_color_gui
   38                 0.000017000     endif
                                  
   38                 0.000064000     if !exists("g:indentLine_bgcolor_gui")
   38                 0.000041000         let gui_bgcolor = default_gui_bg
                                      else
                                          let gui_bgcolor = g:indentLine_bgcolor_gui
   38                 0.000015000     endif
                                  
   38                 0.000603000     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
   38                 0.000340000     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                                  
   38                 0.000050000     if &term ==# "linux"
                                          if &background ==# "light"
                                              let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                          else
                                              let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                          endif
                                          execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
   38                 0.000009000     endif

FUNCTION  <SNR>107_update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:127
Called 12 times
Total time:   0.002345000
 Self time:   0.000731000

count     total (s)      self (s)
   12                 0.000061000     if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                        return
   12                 0.000012000     endif
                                      " loading a session file
                                      " On SessionLoadPost, g:SessionLoad variable is still set :/
   12                 0.000044000     if !a:forceit && get(g:, 'SessionLoad', 0)
                                        return
   12                 0.000004000     endif
   12                 0.000263000     let match = expand('<afile>')
   12                 0.000027000     if pumvisible()
                                        return
   12                 0.000040000     elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                        return
                                      " return, if buffer matches ignore pattern or is directory (netrw)
   12   0.000374000   0.000098000     elseif empty(match) || airline#util#ignore_buf(match) || isdirectory(match)
   11                 0.000010000       return
    1                 0.000000000     endif
    1   0.000101000   0.000005000     call airline#util#doautocmd('BufMRUChange')
    1   0.001251000   0.000009000     call airline#extensions#tabline#redraw()

FUNCTION  gitgutter#buffer_disable()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:97
Called 2 times
Total time:   0.000658000
 Self time:   0.000063000

count     total (s)      self (s)
    2                 0.000013000   let bufnr = a:0 ? a:1 : bufnr('')
    2   0.000114000   0.000022000   call gitgutter#utility#setbufvar(bufnr, 'enabled', 0)
    2   0.000524000   0.000021000   call s:clear(bufnr)

FUNCTION  nerdtree#caseSensitiveFS()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:222
Called 1415 times
Total time:   0.012338000
 Self time:   0.009240000

count     total (s)      self (s)
 1415   0.011757000   0.008659000     return g:NERDTreeCaseSensitiveFS == 1 ||((g:NERDTreeCaseSensitiveFS == 2 || g:NERDTreeCaseSensitiveFS == 3) &&nerdtree#osDefaultCaseSensitiveFS())

FUNCTION  <SNR>41_TabLeaveHandler()
    Defined: ~/.vim/plugged/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim:567
Called 2 times
Total time:   0.000170000
 Self time:   0.000031000

count     total (s)      self (s)
    2                 0.000004000   if g:nerdtree_tabs_meaningful_tab_names
    2   0.000079000   0.000011000     call s:SaveGlobalFocus()
    2   0.000082000   0.000011000     call s:NERDTreeUnfocus()
    2                 0.000002000   endif

FUNCTION  airline#extensions#ale#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:112
Called 55 times
Total time:   0.007419000
 Self time:   0.000575000

count     total (s)      self (s)
   55   0.007375000   0.000531000   return airline#extensions#ale#get('warning')

FUNCTION  <SNR>12_LoadFTPlugin()
    Defined: /opt/homebrew/Cellar/vim/9.1.0400/share/vim/vim91/ftplugin.vim:23
Called 17 times
Total time:   0.059171000
 Self time:   0.029056000

count     total (s)      self (s)
   17                 0.000066000   if exists("b:undo_ftplugin")
                                      # We assume b:undo_ftplugin is using legacy script syntax
    8                 0.000795000     legacy exe b:undo_ftplugin
    8                 0.000030000     unlet! b:undo_ftplugin b:did_ftplugin
    8                 0.000001000   endif
                                  
   17                 0.000012000   var s = expand("<amatch>")
   17                 0.000018000   if s != ""
   17                 0.000075000     if &cpo =~# "S" && exists("b:did_ftplugin")
                                        # In compatible mode options are reset to the global values, need to
                                        # set the local values also when a plugin was already used.
                                        unlet b:did_ftplugin
                                      endif
                                  
                                      # When there is a dot it is used to separate filetype names.  Thus for
                                      # "aaa.bbb" load "aaa" and then "bbb".
   17                 0.000053000     for name in split(s, '\.')
   17   0.057990000   0.027875000       exe 'runtime! ftplugin/' .. name .. '.vim ftplugin/' .. name .. '_*.vim ftplugin/' .. name .. '/*.vim'
   17                 0.000008000     endfor
   17                 0.000000000   endif

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:531
Called 299 times
Total time:   0.001076000
 Self time:   0.001076000

count     total (s)      self (s)
  299                 0.000793000   return s:loaded_ext

FUNCTION  <SNR>192_rstrip()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:256
Called 3 times
Total time:   0.000058000
 Self time:   0.000058000

count     total (s)      self (s)
    3                 0.000056000   return substitute(a:str, '\s*$', '', 'g')

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:234
Called 176 times
Total time:   0.004548000
 Self time:   0.004548000

count     total (s)      self (s)
  176                 0.001353000   let builder = copy(s:prototype)
  176                 0.000397000   let builder._context = a:context
  176                 0.000281000   let builder._sections = []
                                  
  176                 0.001893000   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
  176                 0.000193000   return builder

FUNCTIONS SORTED ON TOTAL TIME
count     total (s)      self (s)  function
   53  48.929607000   0.001853000  AutoSave()
   11  48.926226000   0.057940000  DoSave()
    9  48.704535000   0.003793000  go#auto#fmt_autosave()
    9  48.700323000   0.044142000  go#fmt#Format()
    9  48.519654000   0.000368000  go#fmt#run()
    9  48.518355000   0.000717000  go#util#Exec()
    9  48.491336000   0.000718000  <SNR>74_exec()
    9  48.488685000   0.004011000  <SNR>74_system()
   38   2.176805000   0.000536000  nerdtree#ui_glue#invokeKeyMap()
   38   2.176269000   0.003988000  76()
   38   1.846786000   0.001264000  75()
  720   1.496724000   0.100143000  airline#check_mode()
   84   1.472348000   0.160200000  airline#highlighter#highlight()
10439   1.411302000   0.489121000  airline#highlighter#get_highlight()
 1598   1.288206000   1.092225000  131()
 2334   1.208173000   0.062064000  <SNR>114_exec_separator()
 4475   1.036330000   0.296873000  airline#highlighter#exec()
   20   0.995962000   0.001160000  <SNR>37_refreshCurrent()
  202   0.932872000   0.107163000  284()
   76   0.905470000   0.006202000  airline#update_statusline()

FUNCTIONS SORTED ON SELF TIME
count     total (s)      self (s)  function
 1598   1.288206000   1.092225000  131()
41756                 0.873110000  <SNR>114_get_syn()
10439   1.411302000   0.489121000  airline#highlighter#get_highlight()
   54                 0.393496000  nerdtree#echo()
17640   0.523706000   0.388309000  27()
  683   0.644801000   0.307225000  139()
 4475   1.036330000   0.296873000  airline#highlighter#exec()
 6281   0.533552000   0.290283000  38()
 4650   0.285718000   0.228990000  22()
22182                 0.176952000  19()
   84   1.472348000   0.160200000  airline#highlighter#highlight()
 2520   0.687904000   0.136818000  26()
  202   0.932872000   0.107163000  284()
  719   0.174536000   0.105193000  34()
  720   1.496724000   0.100143000  airline#check_mode()
 2325   0.377761000   0.092043000  nerdtree#compareNodePaths()
 6168   0.217509000   0.089923000  43()
15317                 0.086252000  nerdtree#runningWindows()
 4475                 0.080343000  <SNR>114_CheckDefined()
  602   0.091176000   0.080178000  <SNR>81_Highlight_Matching_Pair()

